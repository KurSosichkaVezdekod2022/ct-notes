\documentclass{article}
\input{Headers/header}

\usepackage{adjustbox}
\usepackage[outputdir=T:/TeX, cachedir=_minted-caches]{minted}
\usemintedstyle{tango}
      
\makeatletter
\renewcommand*{\minted@cleancache}{}
\makeatother

\fancyhead[L]{C++-advanced}

\begin{document}
    \tableofcontents\pagebreak
    \setcounter{page}{1}
    \section{Move-семантика.}
    \paragraph{Мотивация.}
    Пусть у нас есть
    \begin{minted}{c++}
        #include <string>
        #include <vector>

        int main()
        {
            std::string string = "Some-very-long-string";
            std::vector<std::string> strings;
            
            strings.push_back(string);
        }
    \end{minted}
    Как мы знаем, в последней строке происходит копирование. А если строка очень длинная, то это долго. И не всегда нам это надо, иногда исходная строка нам не нужна, хочется просто указатели поперекидывать и всё.\\
    Хуже ситуация обстоит с переаллокациями, потому что там происходят копирования (очень много копирований). \textit{Вообще в C++03 компилятор мог знать, что \mintinline{c++}{std::vector<std::string>} можно как-то оптимизировать}, но если тип ваш, то нет.\\
    А есть ещё другая проблема: есть некопируемые типы. Правда ли, что мы не можем сделать\\\mintinline{c++}{std::vector<std::fstream>}? Традиционное решение~--- \mintinline{c++}{std::vector<std::fstream*>}. Но это, понятно, не очень (это indirection и не exception-safe). Вариант, с которым можно жить:\\
    \label{абьюз shared_ptr}\mintinline{c++}{std::vector<boost::shared_ptr<std::fstream>>} (до C++11 не было \mintinline{c++}{std::shared_ptr}), но это лишние расходы под счётчик ссылок (который всегда 1 или 2).
    \paragraph{Избегание копирования.}
    Rvalue-ссылки~--- по сути метод оптимизации копирований. Поэтому давайте сначала поймём, где копирование есть, а где~--- нет.
    \begin{minted}{c++}
        #include <string>

        void f(std::string);
        std::string g();

        int main()
        {
            f(g());
        }
    \end{minted}
    В функции \mintinline{c++}{main} осуществляется ноль копирований. Почему?
    \begin{itemize}
        \item Сначала посмотрим на \mintinline{c++}{f}. Что происходит, когда мы передаём в функцию какой-то большой тип? Например, GCC делает две вещи: копирует объект и передаёт его по ссылке. Но тут возникает вопрос: а где происходит копирование, внутри \mintinline{c++}{f} или вне? Все компиляторы C++ делают вне. Потому что иначе вы никак не сможете этой копии избежать. А иногда избежать хочется, потому что не всё имеет смысл копировать. А если точнее, \textbf{по стандарту при передаче в функцию копируются только lvalue}.
        \item Теперь давайте разберёмся с возвращаемыми значениями. Что происходит в компиляторе, когда вы возвращаете что-то большое? Оттранслировать возврат большой структуры можно в передачу дополнительного указателя в функцию, по которому пишется ответ. Во что оттранслируется, например, вот это?
        \begin{minted}{c++}
            my_type g()
            {
                return my_type();
            }
        \end{minted}
        Вот что-то примерно такое:
        \begin{minted}{c++}
            void g(my_type* uninitialized_result)
            {
                new (uninitialized_result) mytype();
            }
        \end{minted}
        То есть мы просто на нашей неинициализированной памяти вызываем конструктор. Иногда, правда, это конструктор копирования от чего-то. От чего это зависит? Вот тут уже не так просто. По сути ситуация следующая. Если вы возвращаете prvalue (это особый вид rvalue, смотри \hyperref[par:xvalue]{ниже}), то копирования не происходит (это называется RVO~--- return value optimization). Но иногда его также не происходит, если вы возвращаете lvalue. Например, вот когда:
        \begin{minted}{c++}
            std::array<int, 100> h()
            {
                std::array<int, 100> arr;

                arr[2] = 42;
                arr[3] = 43;

                return arr;
            }
        \end{minted}
        Тут никто не мешает вам транслировать это так:
        \begin{minted}{c++}
            void h(std::array<int, 100>* ununitialized_result)
            {
                new (ununitialized_result) std::array<int, 100>();
                
                (*ununitialized_result)[2] = 42;
                (*ununitialized_result)[3] = 43;
            }
        \end{minted}
        Это называется NRVO (named return value optimization).
    \end{itemize}
    \paragraph{К move-семантике.}
    Давайте посмотрим на то, что можно было бы сделать вместо копирования. Ну, теоретически, мы могли бы сделать что-то, что похоже на копирование, но такое, которое может менять объект. Типа такого:
    \begin{minted}{c++}
        string(string& other) // Типа перемещение.
            : data(other.data)
            , size(other.size)
            , capacity(other.capacity)
        {
            other.size = other.capacity = 0;
            other.data = nullptr;
        }
    \end{minted}
    Таким образом можно жить и с контейнерами (они обычно работают с указателями), и с потоками данных (скопировать все данные одного в другой, а другой сделать как будто закрытым).\\
    Хорошо, вот выдумали мы такую операцию. Как бы она работала для строк, например? В каком состоянии она бы оставляла строку, которую вы перемещаете? А вот unspecified, потому что у вас может быть small-object оптимизация, и маленькую строку проще скопировать, чем скопировать и очистить.\\
    Хорошо. А какими бы ещё свойствами обладала бы наша выдуманная операция? А нам надо было бы к многим методам (например, \mintinline{c++}{push_back}) присобачить вариант, который такой же, но для перемещения. Это неудобно. Чисто теоретически можно было бы пытаться реализовать то же самое на C++03, но была бы куча проблем, поэтому язык расширили и...
    \paragraph{Синтаксис rvalue-ссылок.}
    ...и поэтому придумали новый вид ссылок.
    \begin{minted}{c++}
        int a;
        
        int&  l1 = a;  // Успех.
        int&  l2 = 42; // Ошибка.

        int&& r1 = a;  // Ошибка.
        int&& r2 = 42; // Успех.
    \end{minted}
    Теперь мы можем написать вот это:
    \begin{minted}{c++}
        template <class T>
        class vector
        {
            // ...

            void push_back(const T& element) { /* Для lvalue. */ }
            void push_back(T&&)              { /* Для rvalue. */ }
        };
    \end{minted}
    Первый копирует, второй перемещает.
    \paragraph{Специальные функции-члены класса.}
    Понятно, что теперь мы можем и наши объекты перемещать друг в друга. А значит помимо копирующего конструктора и копирующего оператора присваивания, теперь есть и перемещающая пара.
    \begin{minted}{c++}
        class my_type
        {
            my_type(my_type&&);
            my_type& operator=(my_type&&) &;
        };
    \end{minted}
    \paragraph{\mintinline{c++}{std::move}.}
    Всё это, конечно, прелестно, но давайте научимся перемещать существующий объект. Ну, изи вообще.
    \begin{minted}{c++}
        std::string string;
        std::vector<std::string> strings;

        strings.push_back(static_cast<std::string&&>(string));
    \end{minted}
    Правда, это уже есть, и называется \mintinline{c++}{std::move}.
    \paragraph{Некоторые интересные проблемы.}
    \begin{minted}{c++}
        class person
        {
        private:
            std::string name;

        public:
            person(const std::string& name)
                : name(name)
            {}

            person(std::string&& name)
                : name(name)
            {}
        };
    \end{minted}
    Корректен ли этот код?\\
    Увы, нет, потому что во втором конструкторе \mintinline{c++}{name}~--- это lvalue (переменная же), поэтому правильно так:
    \begin{minted}{c++}
        class person
        {
        private:
            std::string name;
            
        public:
            person(const std::string& name)
                : name(name)
            {}
            
            person(std::string&& name)
                : name(std::move(name))
            {}
        };
    \end{minted}
    \paragraph{Best practices.}
    А давайте возьмём предыдущий пример, но добавим ещё \mintinline{c++}{surname}. Нам что, 4 конструктора писать? Не хочется, знаете ли. А смотрите, как можно:
    \begin{minted}{c++}
        class person
        {
        private:
            std::string name, surname;
            
        public:
            person(std::string name, std::string surname)
                : name(std::move(name)), surname(std::move(surname))
            {}
        };
    \end{minted}
    Теперь смотрите. Тот параметр, который надо скопировать, скопируют. Который не надо~--- не скопируют. А потом эти копии мы просто переместим в наши переменные, и всё хорошо, и слава тебе, Буреотец.\\
    Понятно, что тут вы лишний раз перемещаете то, что скопировали, и если вы предполагаете, что ваш тип долго перемещать, то так не надо. Однако это ещё недо поискать такой тип, что его перемещение будет дорогим.
    \paragraph{Worst practices.}\mbox{}
    \begin{multicols}{3}
        \begin{minted}{c++}
std::string foo()
{
    std::string res;
    res += "Hello, ";
    res += "world!";
    return res;
}
        \end{minted}
        \columnbreak
        \begin{minted}{c++}
std::string&& foo()
{
    std::string res;
    res += "Hello, ";
    res += "world!";
    return std::move(res);
    // Без move не компилируется.
}
        \end{minted}
        \columnbreak
        \begin{minted}{c++}
std::string foo()
{
    std::string res;
    res += "Hello, ";
    res += "world!";
    return std::move(res);
}
        \end{minted}
    \end{multicols}\noindent
    Правильный вариант здесь первый. Второй в принципе не работает (вы возвращаете ссылку на локальную переменную из функции), а третий предотвращает NRVO. Если у вас работает в первом случае NRVO, оно и так работает, без перемещения. Если не сработает, то там и так будет вызываться конструктор перемещения.
    \paragraph{xvalue.}
    \label{par:xvalue}
    \begin{minted}{c++}
        struct mytype {};
        
        mytype rvalue();
        mytype& lvalue();
        
        void foo(const mytype&);
        void foo(mytype&&);
        
        mytype test()
        {
            foo(rvalue());   // rvalue.
            foo(lvalue());   // lvalue.
            
            return rvalue(); // rvalue, RVO.
            return lvalue(); // lvalue, нет RVO.
        }
    \end{minted}
    А теперь давайте создадим вот такую штуку:
    \begin{minted}{c++}
        struct mytype {};
        
        mytype&& unknown();
        
        void foo(const mytype&);
        void foo(mytype&&);
        
        mytype test()
        {
            foo(unknown());   // rvalue.
            
            return unknown(); // Не можем RVO, нам же ссылку дали, значит lvalue.
        }
    \end{minted}
    Так вот такое промежуточное~--- это xvalue. Он считается подвидом rvalue, а те rvalue, которые не xvalue, называются prvalue.
    \paragraph[Увеличение времени жизни.]{Увеличение времени жизни \textit{(since C++03)}.}
    Давайте посмотрим на вот это:
    \begin{minted}{c++}
        const my_type& ref = my_type();
    \end{minted}
    Казалось бы, \mintinline{c++}{ref} ссылается на некорректный объект, потому что он же временный, его удалят в этой же строке. Но это не практично, как оказалось, поэтому есть правило продление жизни. \textbf{Когда вы вешаете на временный объект (prvalue) ссылку (\mintinline{c++}{const&} или \mintinline{c++}{&&}), время жизни временного объекта длится до окончания жизни ссылки.}
    \section{Intrusive контейнеры.}
    \paragraph{Наблюдение касательно двусвязных списков.}
    Насколько мы знаем, двусвязные списки, например, используются очень редко. Да, они поддерживают быстрое удаление середины, но эту середину обычно надо найти, поэтому в среднем не очень хорошо получаются. Да, они поддерживают splic'ы, но это бывает нужно очень редко.\\
    Но есть же те 0.1\% програм, где двусвязные списки используются (то же ядро Linux, где их тьма). Они любо тупые, либо что-то знают.
    \paragraph{Пример.}
    Давайте вообразим себе то, что у нас есть StarCraft. Там все юниты хранятся в двусвязном списке. А мы хотим хранить какое-то их подмножество. Тривиальное решение: \mintinline{c++}{std::unordered_set<unit*>}. Почему \mintinline{c++}{unordered_map}? Ну, потому что мы хотим делать юнит не-выбранным, без \mintinline{c++}{unordered_set} сложно.\\
    О'кей, как это чудо выглядит в памяти? Ну, есть хэш-таблица, в ней по каждому ключу список, в каждом элементе которого указатель на другой список. Кажется, что список внутри таблицы избыточен. Можно сделать таблицу с открытой адресацией, но давайте рассмотрим другое решение:
    \begin{minted}{c++}
        struct unit
        {
            unit* next;
            unit* prev;
            // ...
            unit* selected_next;
            unit* selected_prev;
        };
    \end{minted}
    То есть мы берём наш основной список, и мы <<провязываем>> сквозь него выбранные узлы. По факту в StarCraft выбранные юниты хранятся не так, но много чего другого~--- так. И у этого куча преимуществ:
    \begin{itemize}
        \item Нет аллокаций при вставке/удалении
        \item Двусвязный список содержит на константу операций меньше, чем таблица.
        \item Лучшая локальность ссылок (не заводятся узлы для таблицы).
    \end{itemize}
    А ещё, кстати, к этой задаче можно приспособить и \mintinline{c++}{std::list}. Взять две штуки, первый хранит все элементы, а второй~--- указатели на выбранные из первого (в то время как в первом есть указатели обратно). Выглядит это как-то так:
    \begin{minted}{c++}
        struct unit
        {
            // ...
            std::list<unit*>::iterator backlink;
            // ...
        };

        std::list<unit*> selected;
    \end{minted}
    В случае предыдущего способа (с двумя указателями внутри) проблема в том, что мы храним два указателя даже для тех, кому не надо, а в случае с этим способом~--- расходы имеются в виде лишнего указателя. Что из этого выгоднее~--- зависит от того, насколько много у вас выделенных юнитов.
    \paragraph{Ещё пример.}
    А теперь вот что смотрите: совершенно в любую структуру мы можем провязать внутрь дерево поиска, чтобы там что-то искать. Или тот же список, чтобы хранить подмножество. Да что там, хоть хэш-таблицу со списками. Используя это чудо, можно создать, например, такую структуру данных как LRU-кэш (least recently used):\\
    У нас есть функция, которая долго считается. И мы хотим кэшировать её результаты. Нам поможет \mintinline{c++}{std::map}, но тогда память будет бесконечно расти, поэтому мы хотим выкидывать то, к чему не обращались дольше всего. Как это сделать? Ну, провязать списком, у которого в хвосте самые давно используемые элементы. Произошло обращение~--- внутри списка перекидываем элемент в начало. Добавляют новый~--- удаляем старый из хвоста.
    \begin{minted}{c++}
        struct node
        {
            Key key;
            Value value;

            // Ordered by key:
            node* parent;
            node* left;
            node* right;

            // Ordered by access time:
            node* next;
            node* prev;
        };
    \end{minted}
    \paragraph{Вынесение общего кода.}
    Хм-м, кажется, мы умеем встраивать любую структуру данных в любую. Хочется как-то промышленно это делать, а не руками вписывать два поля в каждую структуру.
    \subparagraph{На C.}
    На C мы бы сделали так:
    \begin{minted}{c++}
        struct list_node
        {
            list_node next;
            list_node prev;
        };

        struct unit
        {
            // ...
            list_node everything_list;
            list_node selected_list;
        };
    \end{minted}
    Тут есть существенная проблема: наш список ссылается на \mintinline{c++}{list_node}, а не на \mintinline{c++}{unit}. Делается вот такое чудо:
    \begin{minted}{c}
    #define container_of(ptr, type, member) \
        ((type*)((char*)(ptr) - offsetof(type, member)))
    \end{minted}
    Это минималистичный вариант, который не проверяет типы, например, но суть ясна: по полю структуры мы достаём саму структуру. Подобная штука используется в C в ядре Linux везде вообще, а в C++ с этим есть сложности. Во-первых, это большой UB, который, конечно, работает, но давайте так не надо. Во-вторых, \mintinline{c}{offsetof} применяется не ко всем штукам. Например, если есть виртуальна функция, туда по стандарту нельзя.
    \subparagraph{На C++.}
    А давайте найдём аналогичную ситуацию в C++ (когда у нас указатель надо двигать походим образом). А это же множественное наследование! Мы это проговаривали в подобном разделе, вот такой пример там был:
    \begin{minted}{c++}
        struct base1
        {
            int x;
        };
        struct base2
        {
            int y;
        };
        struct derived : base1, base2 {};

        base2& to_base2(derived& d)
        {
            return static_cast<base2&>(d); // Тут происходит смещение указателя.
        }
    \end{minted}
    Следующая проблема: нам надо дважды отнаследоваться от одного и того же. Это по канону пишется при помощи тегов:
    \begin{minted}{c++}
        template <class Tag> // Не используется внутри
        struct list_element
        {
            list_element* next;
            list_element* prev;
        };

        struct everything_tag;
        struct selected_tag;
        
        struct unit : list_element<everything_tag>, list_element<selected_tag>
        {
            // ...
        };

        intrusive_list<unit, everything_tag> all_units;
        intrusive_list<unit, selected_tag> selected_units;
    \end{minted}
    Или, даже чуть проще,
    \begin{minted}{c++}
        template <class Tag> // Не используется внутри
        struct list_element
        {
            list_element* next;
            list_element* prev;
        };
        
        struct unit : list_element<struct everything_tag>, list_element<struct selected_tag>
        {
            // ...
        };
        
        intrusive_list<unit, everything_tag> all_units;
        intrusive_list<unit, selected_tag> selected_units;
    \end{minted}
    \paragraph{Реализация.}
    Когда-то давно появился proposal в стандарт, чтобы добавить туда intrusive контейнеры, но он как-то забросился. Зато контейнеры есть в boost'е, причём там они умеют работать и через наследование, и через \mintinline{c++}{offsetof}. Более того, там есть возможность 3 различными способами взаимодействовать с контейнерами (ничего особенного не делать, автоматически отвязываться в деструкторе, проверять, что вы не вставляетесь в контейнер дважды).
    \paragraph{Сравнение с обычными контейнерами.}\mbox{}
    \begin{figure}[H]
        \begin{tabular}{|l|cc|}
            \hline
            & Intrusive & Не intrusive\\
            \hline
            Менеджмент памяти & Внешнее & Внутреннее\\
            Время на вставку/удаление & Быстрее & Медленнее\\
            Локальность памяти & Лучше & Хуже\\
            Можно вставить один объект в два контейнера & Нет & Да\\
            Гарантия исключений & Nothrow & Как попало\\
            Получить итератор из значения & Тривиально & Очень сложно\\
            Использование памяти & Минимально & Не настолько минимально\\
            Вставить объект, сохраняя полиморфизм & Можно & Нельзя из-за slicing'а\\
            Пользователь должен изменить определение объекта & Да & Нет\\
            Возможность копировать контейнер & Нельзя & Можно\\
            Время жизни определяется...  & Пользователем & Контейнером\\
            Возможность сломать инварианты контейнера & На изи вообще & Очень сложно\\
            Аналитика потокобезопасности & Сложная & Простая\\
            \hline
        \end{tabular}
    \end{figure}
    \paragraph{Мультииндекс.}
    Есть такая весёлая штука, называется boost \mintinline{c++}{multi_index_container}. Это штука, в которую можно запихнуть, что вы хотите иметь внутри заданные intrusive-контейнеры, но чтобы они владелись. И именно этим и занимается мультииндекс. Например, написав вот такую штуку, мы получим LRU-кэш:
    \begin{minted}{c++}
        boost::multi_index::indexed_by<
            boost::multi_index::sequenced<>,
            boost::multi_index::ordered_unique<
                boost::multi_index::member<value_type, const key_type, &value_type::first>>>
    \end{minted}
    Потому что тут последовательность и упорядоченность по полю \mintinline{c++}{first} типа \mintinline{c++}{key_type} в структуре типа \mintinline{c++}{value_type}.
    \section{\mintinline{c++}{shared_ptr}.}
    Как мы знаем, умный указатель~--- это то, что позволяет ссылаться на объект, и в деструкторе в том или ином случае удаляет его. С \mintinline{c++}{unique_ptr} мы уже знакомы, например.\\
    \mintinline{c++}{shared_ptr} же~--- это штука, которую можно скопировать, и вы будете просто копировать указатели до тех пор, пока все указатели не умрут. Когда умрёт последний, объект удалят. Чтобы понять, что последний умер, используется просто счётчик.
    \paragraph{Bad practices.}
    Не надо абьюзить \mintinline{c++}{shared_ptr} (как, например мы уже обсуждали \hyperref[абьюз shared_ptr]{пример} в секции про move). Используйте \mintinline{c++}{shared_ptr} тогда, когда вы уверены в том, что именно как указатель вы хотите его использовать.
    \paragraph{Фичи этого чуда.}
    Но вообще там же, где число, можно хранить информацию о том, как мы создали объект. А точнее, информацию, как его удалять. Это может быть \mintinline{c++}{free}, \mintinline{c++}{delete}, какой-нибудь возврат объекта в наш пул, что-то ещё.\\
    Давайте вот на что посмотрим. У нас есть машина. И у неё есть 4 колеса. И нам хочется, чтобы кто-то мог отдельно ссылаться на колёса, а не на саму машину. Более того, вам может захотеться, чтобы если кто-то ссылался на колёса, то сама машина не удалялась. Это делается так:
    \begin{minted}{c++}
        std::shared_ptr<vehicle> v(new vehicle());
        std::shared_ptr<wheel> v(v, &v->wheel[2]);
    \end{minted}
    Это называется \href{https://en.cppreference.com/w/cpp/memory/shared_ptr/shared_ptr}{aliasing constructor}, и он делится владением с оригинальным конструктором, но содержит внутри себя другой указатель. И тут уже ваша ответственность следит за тем, что колесо не умрёт раньше автомобиля. В данном случае это так, но в более сложном случае это может быть не так. То же самое также типично используется, если вам нужно хранить \mintinline{c++}{shared_ptr} с базовым классом. Через это чудо работают \href{https://en.cppreference.com/w/cpp/memory/shared_ptr/pointer_cast}{pointer cast}'ы.
    \paragraph{Реализация.}
    Необходимо где-то считать ссылки. И делается это, разумеется, в каком-то месте, общем для всех \mintinline{c++}{shared_ptr}'ов. То есть создаётся отдельный кусочек памяти:
    \begin{figure}[H]
        \begin{tikzpicture}
            \draw (0,0) rectangle ++(2,2) node[midway]{pointer} rectangle ++(2,-2) node[midway,text width=1.5cm,align=center] {shared count};
            \draw (-.25,-.5) rectangle ++(4.5,2.75);
            \node at (2,-.25) {sp1};
            
            \draw (-1,6) node[coordinate] (O_) {} rectangle ++(6,2) node[midway,coordinate] (O) {} node[midway] {object};
            
            \draw (7,6) rectangle ++(2,2) node[midway] {2} rectangle ++(2,-2) node[midway] {pointer} rectangle ++(4,2) node[midway] {deleter};
            
            \draw (8,0) rectangle ++(2,2) node[midway]{pointer} rectangle ++(2,-2) node[midway,text width=1.5cm,align=center] {shared count};
            \draw (7.75,-.5) rectangle ++(4.5,2.75);
            \node at (10,-.25) {sp2};
            
            \draw[->] (1,2) -- (\currentnode |- O_) node[coordinate] (O1) {};
            \draw[->] (9,2) -- ($(O1)+(2,0)$);
            \draw[->] (3,2) -- (8,6);
            \draw[->] (11,2) -- (8,6);
            \draw[->] (10,8) node[coordinate] (cbP^) {} -- ++(0,1) -| (cbP^ -| O);
        \end{tikzpicture}
    \end{figure}
    \begin{minted}{c++}
        std::shared_ptr<type> sp1(new type());
        std::shared_ptr<type> sp2 = sp1;
    \end{minted}
    В Windows этот кусочек справа сверху называется control block. Зачем там хранится ещё указатель? А для того, чтобы работал aliasing constructor. Как выглядит в таком случае \mintinline{c++}{shared_ptr}? Ну, вот так:
    \begin{figure}[H]
        \begin{tikzpicture}
            \draw (0,0) rectangle ++(2,2) node[midway]{pointer} rectangle ++(2,-2) node[midway,text width=1.5cm,align=center] {shared count};
            \draw (-.25,-.5) rectangle ++(4.5,2.75);
            \node at (2,-.25) {v};
            
            \draw (-1,6) node[coordinate] (O_) {} rectangle ++(6,2) node[midway,coordinate] (O) {};
            \draw (-.75,6.5) rectangle ++(1,1.25) rectangle ++(1,-1.25) rectangle ++(1,1.25) node[coordinate, midway] (w2) {} rectangle ++(1,-1.25) rectangle ++(.5,1.25) node[midway] {...};
            \node at (2,6.25) {object};
            
            \draw (7,6) rectangle ++(2,2) node[midway] {2} rectangle ++(2,-2) node[midway] {pointer} rectangle ++(4,2) node[midway] {deleter};
            
            \draw (8,0) rectangle ++(2,2) node[midway]{pointer} rectangle ++(2,-2) node[midway,text width=1.5cm,align=center] {shared count};
            \draw (7.75,-.5) rectangle ++(4.5,2.75);
            \node at (10,-.25) {w2};
            
            \draw[->] (1,2) -- (\currentnode |- O_) node[coordinate] (O1) {};
            \draw[->] (9,2) -- ($(w2)-(0,1.25/2)$);
            \draw[->] (3,2) -- (8,6);
            \draw[->] (11,2) -- (8,6);
            \draw[->] (10,8) node[coordinate] (cbP^) {} -- ++(0,1) -| (cbP^ -| O);
        \end{tikzpicture}
    \end{figure}
    Понятно, что имея только \mintinline{c++}{w2}, очень сложно откуда-то взять, что это за колесо, и как из него получить оригинальной объект. Поэтому указатель на оригинальный объект надо бы похранить.
    \subparagraph{\mintinline{c++}{make_shared}.}
    \label{spar:make_shared}
    Хочется не иметь две аллокации памяти, а иметь одну. И control block можно запихать внутрь объекта. Это делается при помощи \mintinline{c++}{std::make_shared}, которому в качестве параметров передаются параметры конструктора вашего объекта:
    \begin{minted}{c++}
        struct my_type
        {
            my_type(int, int, int);
        };

        std::shared_ptr<my_type> pointer = std::make_shared(1, 2, 3);
    \end{minted}
    Притом тогда можно даже выпилить из этого блока deleter и ptr. Потому что зачем они.
    \paragraph{\mintinline{c++}{weak_ptr}.}
    Это штука, которая не мешает объекту удалиться, но позволяет смотреть за ним. И проверять, удалился он или нет. Чтобы это реализовать, вам надо как-то продлевать время жизни control block'а, и обычно это делается при помощи добавления в control block ещё одного числа. Оно равно количеству слабых ссылок, если сильных ссылок нет, либо тому же, но плюс один, если есть. Потому что так получается меньше \mintinline{c++}{if}'ов.
    \paragraph{Пример.}
    Представим себе, что у нас есть функция, которая грузит виджет. При этом разные куски могут просить одно и то же. Хочется им одно и то же и давать. Тогда мы обернём виджеты в \mintinline{c++}{shared_ptr}.
    \begin{minted}{c++}
        std::shared_ptr<widget> get_widget(int id)
        {
            static std::map<int, std::weak_ptr<widget>> cache;
            auto sp = cahce[id].lock();
            if (!sp)
                cache[id] = sp = load_widget(id);
            return sp;
        }
    \end{minted}
    Но тут есть существенная проблема: если мы грузом виджеты по порядку (в процессе их удаляя), мы получаем в итоге очень большой \mintinline{c++}{std::map}, в котором виджетов, конечно, нет, то там куча пустых \mintinline{c++}{weak_ptr}'ов. Их надо как-то убрать. Как это править?\\
    При помощи deleter'а, очевидно. Мы подсунем каждому объекту deleter, который знает, по какому итератору хранится данный объект. Это, кстати, причина, почему в примере \mintinline{c++}{std::map}, а не \mintinline{c++}{std::unordered_map}.\\
    Но тут имеется проблема: у нас три объекта в памяти (данные, control block и узел дерева). Давайте уменьшим их количество. Во-первых, зачем на deleter. Он нужен, только если мы не знаем, как удалять объект. А мы делаем что-то вместе с удалением, давайте это <<что-то>> в деструктор запихнём. Теперь мы умеем делать \mintinline{c++}{make_shared}, потому что нет необходимости в деструкторе. А дальше заменяем \mintinline{c++}{map} на его интрузивный вариант, и получаем всего один объект.
    \paragraph{\mintinline{c++}{std::enable_shared_from_this}.}
    Пусть мы делаем вот такой стандартный код:
    \begin{minted}{c++}
        std::shared_ptr<int> sp1(new int(42));
        std::shared_ptr<int> sp2 = sp1;
    \end{minted}
    Тут всё хорошо, мы в первой строке забираем владение, генерируем control block, а потом просто меняем данные в нём. А можно ещё ошибиться и случайно написать так:
    \begin{minted}{c++}
        int* p = new int(42);

        std::shared_ptr<int> sp1(p);
        std::shared_ptr<int> sp2(p);
    \end{minted}
    Тут понятно, какая ошибка, double free. Но всё же. Бывают такие случаи, когда мы сделали \mintinline{c++}{shared_ptr}, а потом достали из него указатель и куда-то передали. Например, чтобы вызвать на нём метод. А потом в методе захотели что-то сделать с \mintinline{c++}{shared_ptr}'ом. Но мы не можем новый сделать. И старый получить не можем. Поэтому есть такая штука как \mintinline{c++}{std::enable_shared_from_this}~--- отнаследовавшись от неё, вы сможете пользоваться методом \mintinline{c++}{shared_from_this}, который даёт вам тот самый \mintinline{c++}{shared_ptr}. Работает она тривиально, просто внутри себя храня \mintinline{c++}{weak_ptr} на текущий объект.
    \section{Идеальная передача и шаблоны с переменным количеством аргументов.}
    \paragraph{Мотивация.}
    Есть у нас \hyperref[spar:make_shared]{\mintinline{c++}{std::make_shared}} и \mintinline{c++}{std::make_unique}. Они принимают на вход параметры конструктора. Вопрос: это что за магия такая?\\
    Что мы глобально хотим? У нас есть функция, она имеет несколько перегрузок:
    \begin{minted}{c++}
        void f(int&);
        void f(char);
        void f(std::string*);
    \end{minted}
    А нам хочется написать функцию \mintinline{c++}{g}, которая принимает на вход всё, что угодно, и передаёт это на вход функции \mintinline{c++}{f}. Ну так идейно понятно, давайте сделаем наш параметр шаблонным:
    \begin{minted}{c++}
        template <class T>
        void g(T x)
        {
            f(x);
        }
    \end{minted}
    Но тут есть пара проблем:
    \begin{enumerate}
        \item Если \mintinline{c++}{f} принимает, скажем, \mintinline{c++}{std::vector<int>&&}, то у нас при передаче из \mintinline{c++}{g} в \mintinline{c++}{f} передастся \mintinline{c++}{std::vector<int>&}, потому что в \mintinline{c++}{f} мы будем передавать \mintinline{c++}{x}, то есть переменную, то есть lvalue, и будет \mintinline{c++}{f(std::vector<int>&)}.
        \item Если у нас есть переменная типа \mintinline{c++}{int}, то \mintinline{c++}{g} внутри делает копию, и передача в \mintinline{c++}{f(int&)} бесполезна. Более того, если мы передадим в \mintinline{c++}{g} временный объект типа \mintinline{c++}{int}, то мы вполне сможем его передать (\mintinline{c++}{f} вызовется с ссылкой на перемещённое значение), а хочется, чтобы это даже не компилировалось.
    \end{enumerate}
    В итоге хочется решение, которое, во-первых, сохраняет \mintinline{c++}{const}'ы, во-вторых, запоминает value category.
    \paragraph{Специальные правила для rvalue-ссылок в C++11.}
    \subparagraph{Правило сворачивания ссылок.}
    В C++ вы не можете создать ссылку на ссылку. Но тем не менее, никто же не мешает вам написать что-то такое:
    \begin{minted}{c++}
        using type = int&;
        tyoe& x;
    \end{minted}
    Или такое:
    \begin{minted}{c++}
        template <class T> void foo(T& x);

        foo<int&>(x);
    \end{minted}
    У Вас технически возникает ссылка на ссылку. В результате все компиляторы в C++03 считали, что ссылка на ссылку~--- это просто ссылка. А в C++11 Вам надо определить, что происходит, если Вы сворачиваете разные ссылки. Так вот, когда вы сворачиваете две ссылки, одна из которых lvalue, получается lvalue-ссылка. Если вы сворачиваете две rvalue-ссылки, получаете rvalue-ссылку. Почему это так определено? Чтобы работал perfect forwarding.
    \subparagraph{Правило вывода ссылок.}
    Вот есть у вас
    \begin{minted}{c++}
        template <class T>
        void foo(T x);
    \end{minted}
    Как на основе вызова определить, какой тип у нас у \mintinline{c++}{x}? У компилятора есть какие-то правила для разных вещей. Для вот такого есть какие-то правила, например:
    \begin{minted}{c++}
        template <class T>
        void foo(std::pair<T, T*> x);
    \end{minted}
    А в C++11 надо ввести правило, как выводился тип у такого
    \begin{minted}{c++}
        template <class T>
        void foo(T&& x);
    \end{minted}
    А вот выводится оно так:
    \begin{minted}{c++}
        template <class T>
        void foo(T&& x);
        
        int main()
        {
            foo(42); // T -> int.
            foo(static_cast<int const&&>(42)); // T -> int const.
            
            int u;
            int const v;
            foo(u); // T -> int&.
            foo(v); // T -> int const&
        }
    \end{minted}
    \paragraph{Непосредственно, perfect forwarding.}
    Теперь мы можем беспрепятственно написать идеальную передачу для примера выше:
    \begin{minted}{c++}
        template <class T>
        void g(T&& x)
        {
            f(static_cast<T&&>(x));
        }
    \end{minted}
    Почему это работает? Если в \mintinline{c++}{g} приходит \mintinline{c++}{42}, то \mintinline{c++}{T} выводится в \mintinline{c++}{int}, и наша функция превращается в
    \begin{minted}{c++}
        void g(int&& x)
        {
            f(static_cast<int&&>(x));
        }
    \end{minted}
    Это же ровно то, что нам нужно.\\
    Если Вы передадите переменную типа \mintinline{c++}{int}, \mintinline{c++}{T} выведется в \mintinline{c++}{T&}, а значит, с учётом сворачивания ссылок, \mintinline{c++}{g} превратится в
    \begin{minted}{c++}
        void g(int& x)
        {
            f(static_cast<int&>(x));
        }
    \end{minted}
    С \mintinline{c++}{const}'ами тоже всё будет хорошо, можете проверить сами.\\
    То, что мы только что сделали, называется perfect forwarding. Кстати, обычно он делается не при помощи \mintinline{c++}{static_cast}'а, а специальной функцией: \mintinline{c++}{std::forward}, которая, по сути, \mintinline{c++}{static_cast} и делает. Давайте попробуем сами её написать:
    \begin{minted}{c++}
        template <typename T>
        T&& forward(T& x)
        {
            return static_cast<T&&>(x);
        }
    \end{minted}
    Но тут есть существенная проблема: если мы напишем \mintinline{c++}{forward(x)} вместо \mintinline{c++}{forward<T>(x)}, у нас будет тупо \mintinline{c++}{std::move}. Поэтому в стандартной библиотеке решили подавить автоматический вывод ссылок (чтобы всегда явно передавали). Самый простой сделать это вот так:
    \begin{minted}{c++}
        template <class T>
        struct identity
        {
            using type = T;
        };

        template <typename T>
        T&& forward(typename identity<T>::type& x)
        {
            return static_cast<T&&>(x);
        }
    \end{minted}
    Когда у вас в аргументах подобный dependent-тип, его в общем случае очень сложно вывести Но в случае со стандартным \mintinline{c++}{std::forward} решили не заводить отдельную структуру, а использовать \mintinline{c++}{std::remove_reference_t}, который, вообще говоря, полностью эквивалентен \mintinline{c++}{identity}, потому что в \mintinline{c++}{identity} у нас всё равно ссылки коллапсируют в lvalue-ссылку.
    \paragraph{Variadic templates.}
    Кто такой эти ваши variadic-шаблоны? Да всё элементарно, вы просто можете взять и добавить в шапку шаблона произвольное количество параметров:
    \begin{minted}{c++}
        template <class... T>
        class tuple
        {
            // ?????.
        }

        template <class... T>
        void foo(T... args)
        {
            tuple<T...>(args) t;
            // ...
        }
    \end{minted}
    Возникает вопрос, а почему \mintinline{c++}{tuple<T...>}, а не просто \mintinline{c++}{tuple<T>}? Да понятно, на самом деле, вот есть у нас \mintinline{c++}{tuple<tuple<T>>}, и непонятно, что это должно быть, \mintinline{c++}{tuple<tuple<T...>>} или \mintinline{c++}{tuple<tuple<T>...>}. С \mintinline{c++}{tuple} немного дурацкий пример, но если вот с какими-нибудь функциями это вполне адекватно:
    \begin{minted}{c++}
        template <class... T>
        void foo(T... args)
        {
            f(g(args...)); // f(g(arg0, arg1, arg2, ...))
            f(g(args)...); // f(g(arg0), g(arg1), g(arg2), ...)
        }
    \end{minted}
    Правда, вообще многоточие может раскрыть очень много всего. Мы можем раскрыть такое:
    \begin{minted}{c++}
        f(g(args, args...)...);
    \end{minted}
    И это будет два разных раскрытия. Сначала у нас раскроется внутренний \mintinline{c++}{args}, а потом внешний:
    \begin{minted}{c++}
        f(g(arg0, arg0, arg1, arg2, ...),
          g(arg1, arg0, arg1, arg2, ...),
          g(arg2, arg0, arg1, arg2, ...)
          ...);
    \end{minted}
    Можем раскрыть такое:
    \begin{minted}{c++}
        f(g(args, args)...)
    \end{minted}
    И это раскроется в
    \begin{minted}{c++}
        f(g(arg0, arg0),
          g(arg1, arg1),
          g(arg2, arg2),
          ...)
    \end{minted}
    При этом pack'и даже разными могут быть (в последнем примере, если они отличаются по длине, ошибка компиляции).
    \paragraph{Примеры.}
    Давайте попытаемся сделать \mintinline{c++}{std::make_unique}, пользуясь то, что мы только что изучили. Как это сделать, если у нас один аргумент? Ну, вот так:
    \begin{minted}{c++}
        template <class T, class Arg0>
        std::unique_ptr<T> make_shared(Arg0&& arg0)
        {
            return std::unique_ptr<T>(new T(std::forward<Arg0>(arg0)));
        }
    \end{minted}
    А как это обобщить на несколько параметров? Ну, всего лишь понять, где мы хотим раскрыть наши аргументы:
    \begin{minted}{c++}
        template <class T, class... Args>
        std::unique_ptr<T> make_shared(Args&&... args)
        {
            return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
        }
    \end{minted}
    И тут у нас по сути две вещи, которые надо распаковывать (\mintinline{c++}{Args} и \mintinline{c++}{args}), и многоточие распаковывает их одновременно парами, как было в примере с \mintinline{c++}{f(g(args, args)...)}.
    \paragraph{<<Perfect backwarding>>.}
    \subparagraph{\mintinline{c++}{decltype}, \mintinline{c++}{declval}.}.
    Теперь представьте, что мы хотим не только forward'ить аргументы, но ещё и возвращать значение.
    \begin{minted}{c++}
        template <typename T>
        ??? g(T&& x)
        {
            return f(std::forward<T>(x));
        }
    \end{minted}
    Для этого есть ключевое слово \mintinline{c++}{decltype}, которое по значению даёт его тип по сути:
    \begin{minted}{c++}
        decltype(2 + 2) x = 7;
    \end{minted}
    При этом \mintinline{c++}{decltype} сохраняет все ссылки и все \mintinline{c++}{const}'ы:
    \begin{minted}{c++}
        int foo();
        int& bar();
        int&& baz();
        
        int main()
        {
            decltype(foo()) x; // prvalue  int x;
            decltype(bar()) x; // lvalue   int& x;
            decltype(baz()) x; // xvalue   int&& x;
        }
    \end{minted}
    По-научному \mintinline{c++}{decltype} даёт вам тот или иной вид ссылок в зависимости от value category.\\
    Но на самом деле существует по сути два \mintinline{c++}{decltype}: для выражений и для имён. То есть мы можем сделать что-то такое:
    \begin{minted}{c++}
        struct mytype
        {
            int nested;
        };

        decltype(mytype::nested) a;
    \end{minted}
    То есть \mintinline{c++}{mytype::nested}~--- некорректное выражение, но брать от него \mintinline{c++}{decltype} можно.\\
    Давайте больше мемов:
    \begin{minted}{c++}
        int a;
        decltype(a) b;   // int b, так как от переменной.
        decltype((a)) c; // int& c, так как от выражения, а это lvalue.
    \end{minted}
    О'кей, а теперь как написать нашу функцию?
    \begin{minted}{c++}
        template <typename T>
        decltype(f(std::forward<T>(x))) g(T&& x)
        {
            return f(std::forward<T>(x));
        }
    \end{minted}
    Но это не компилируется, потому что компилятор на этапе разбора возвращаемого значения не знает об \mintinline{c++}{x}. Ну так и пофиг, давайте так сделаем:
    \begin{minted}{c++}
        template <typename T>
        decltype(f(T())) g(T&& x)
        {
            return f(std::forward<T>(x));
        }
    \end{minted}
    Это не норм, потому что конструктор по-умолчанию может отсутствовать, да и как сконструировать ссылку от ничего, не ясно. Поэтому, для порождения значений переменной из ниоткуда, в стандартной библиотеке есть функция \mintinline{c++}{std::declval}, которая возвращает значение типа \mintinline{c++}{T&&}:
    \begin{minted}{c++}
        template <typename T>
        decltype(f(std::declval<T>())) g(T&& x)
        {
            return f(std::forward<T>(x));
        }
    \end{minted}
    При этом сама функция обычно не имеет тела, чтобы никакой дурак не вздумал её вызвать, вы можете её использовать только там, где не происходит вычисление. Это называется unevaluated context (другими его примерами, помимо \mintinline{c++}{decltype}, являются \mintinline{c++}{sizeof} или \mintinline{c++}{alignof}).
    \subparagraph{Trailing return type.}. На самом деле вам может всё же захотеться сослаться на \mintinline{c++}{x}.
    \begin{minted}{c++}
        struct foobar
        {
            using type = int;
            
            type f();
            void g(type);
        };
    \end{minted}
    Что будет, если мы напишем реализацию этих функций вне класса? Ну, всё будет хорошо
    \begin{minted}{c++}
        void foobar::g(type x) {...}
    \end{minted}
    Но при этом мы не можем также написать \mintinline{c++}{f}:
    \begin{minted}{c++}
        type foobar::f() {...} // ошибка компиляции
        foobar::type foobar::f() {...} // норм
    \end{minted}
    Фундаментальная проблема здесь в одном: мы пишем возвращаемый тип до параметров, а не после. Поэтому есть другой синтаксис:
    \begin{minted}{c++}
        auto foobar::f() -> type {...}
    \end{minted}
    И тут нам полностью всё равно, квалификаторы у нас, не квалификаторы, нужны параметры, не нужны, всё хорошо работает:
    \begin{minted}{c++}
        template <class T>
        auto f(T&& x) -> decltype(f(std::forward<T>(x)))
        {
            return f(std::forward<T>(x));
        }
    \end{minted}
    \subparagraph{\mintinline{c++}{auto}.}
    А что будет, если мы просто напишем 
    \begin{minted}{c++}
        template <class T>
        auto f(T&& x)
        {
            return f(std::forward<T>(x));
        }
    \end{minted}
    А будет, на самом деле, не то, что хочется. Но для этого обсудим \mintinline{c++}{auto}.\\
    Что происходит, если мы напишем \mintinline{c++}{auto x = expr}? А тип будет ровно тот же самый, что выведется в примере:
    \begin{minted}{c++}
        template <class T>
        void test(T x);
    \end{minted}
    Это, вообще, почти всегда правда, но мы пока не проходили конструкций, которые приводят к случаю, когда это не так. Так вот, если у нас написано \mintinline{c++}{auto&& x} или \mintinline{c++}{auto const& x}, то просто \mintinline{c++}{test} становится \mintinline{c++}{test(T&& x)} или \mintinline{c++}{test(T const& x)}.\\
    Начиная с C++14 вы можете писать \mintinline{c++}{auto} как возвращаемое значение функции, и тогда оно определится на основе \mintinline{c++}{return}. В частности, в нашем примере
    \begin{minted}{c++}
        template <class T>
        auto f(T&& x)
        {
            return f(std::forward<T>(x));
        }
    \end{minted}
    У нас всегда \mintinline{c++}{return}~--- это rvalue, и мы будем получать не то, что хотим. Ровно как мы и не можем написать
    \begin{minted}{c++}
        template <class T>
        auto& f(T&& x)
        {
            return f(std::forward<T>(x));
        }
    \end{minted}
    или
    \begin{minted}{c++}
        template <class T>
        auto&& f(T&& x)
        {
            return f(std::forward<T>(x));
        }
    \end{minted}
    \subparagraph{\mintinline{c++}{decltype(auto)}.}
    Боже мой, что это за ужас? Ну, а это то, что нам нужно, оно берёт возвращаемое выражение, делает ему \mintinline{c++}{decltype} и это тип возвращаемого значения. И это же можно написать в любом месте.
    \paragraph{\mintinline{c++}{nullptr}.}
    До C++11 у вас не было \mintinline{c++}{nullptr}, а вам приходилось руками делать \mintinline{c++}{int* p = 0;} (выражение, на этапе компиляции имеющее значение 0, можно привести в указатель). Это создавало не так уж и много проблем, но потом появился perfect forwarding, и \mintinline{c++}{std::forward<T>(x)}~--- это ни в каком месте не compile-time константа, равная нулю. Поэтому и ввели \mintinline{c++}{nullptr}~--- константу, имеющую тип \mintinline{c++}{std::nullptr_t}. Этот тип тупо неявно приводится к любому указателю.
    \section{Анонимные функции и их друзья.}
    \paragraph{Статический и динамический полиморфизм. Мотивация анонимных функций.}
    Давайте сравним два способа вызвать сортировку: когда мы передаём \mintinline{c++}{less<int>()} и \mintinline{c++}{&int_less}, где
    \begin{minted}{c++}
        template <class T>
        struct less
        {
            bool operator()(const T& a, const T& b)
            {
                return a < b;
            }
        };

        bool int_less(int a, int b)
        {
            return a < b;
        }
    \end{minted}
    Оказывается, вариант \mintinline{c++}{less<int>} будет быстрее процентов на 30. Более того, если массив уже отсортирован, то \mintinline{c++}{less<int>} будет быстрее более чем вдвое, (а в этом случае у нас сортировка сама по себе делает меньше работы и больше работы делает компаратор).\\
    В чём дело? Давайте посмотрим, что у нас произойдёт, если мы скомпилируем что-то такое:
    \begin{minted}{c++}
        void foo(bool (*cmp)(int, int))
        {
            cmp(1, 2);
        }
    \end{minted}
    У нас по сути нет варианта, кроме как взять и вызвать функцию, которую мы передали. С другой стороны, если у нас что такое:
    \begin{minted}{c++}
        template <typename F>
        void bar(F f)
        {
            f(1, 2);
        }
    \end{minted}
    Тут при подстановке шаблона мы чётко знаем, что такое \mintinline{c++}{F}, какие у него методы, а значит мы можем спокойно их подставлять.\\
    То есть идейно в \mintinline{c++}{foo} у нас код генерируется однократно, и мы можем туда подставлять что угодно, а для \mintinline{c++}{bar} создаётся код для каждого типа отдельно.\\
    То, что мы сейчас обсуждаем,~--- это на самом деле виды полиморфизма. Когда мы на этапе компиляции знаем, что мы хотим делать~--- это статический полиморфизм, а когда у нас указатель на функцию~--- это динамический (ведь знаем его мы только на этапе исполнения).
    \begin{figure}[H]
        \begin{tabular}{|m{0.5\textwidth}|m{0.5\textwidth}|}
            \hline
            Преимущества статического полиморфизма. & Недостатки статического полиморфизма\\
            \hline
            Возможность оптимизации на этапе компиляции. & Возможность получить большое количество копий одинаковых сущностей.\\
            \hline
            & Невозможность выбирать сущность на этапе исполнения.\\
            \hline
        \end{tabular}
    \end{figure}\noindent
    Понятно, что у компиляторов есть способ бороться с недостатками динамического полиморфизма. Например, GCC под LTO может анализировать, какие аргументы приходят к Вам в сортировку, и если они всегда одни и те же, то inline'ить. Ещё GCC на \mintinline{console}{-O3} умеет в ещё один трюк: \mintinline{console}{-fipa-cp-clone}. Это вот что. GCC видит, что вашу функцию для какого-то конкретного параметра хорошо оптимизируется. Он может её взять и склонировать с заданным параметром. А ещё бывает вот какая оптимизация:
    \begin{minted}{c++}
        // ...
        if (comp == &int_less)
            int_less(a, b);
        else if (comp == &int_greater)
            int_greater(a, b);
        else
            comp(a, b);
        // ...
    \end{minted}
    Так, а с чего это вдруг оптимизация? А потому что эти \mintinline{c++}{if}'ы выносятся за пределы кода, и тогда у нас получается почти такой же эффект, как и \mintinline{console}{-fipa-cp-clone}. И в GCC тоже такое есть, оно называется \mintinline{console}{-fdevirtualize-speculatively}.\\
    Кстати. Дело тут не только в inline'инге, потому что вообще GCC может не inline'ить, но всё равно вытаскивать из функции какую-то информацию о ней (типа, может она не пишет в память, значит нам не надо лишний раз читать память).
    \paragraph{Безымянные функции (a.k.a. лямбда-функции).}
    Представьте, что мы хотим со специфическим компаратором отсортировать массив. Традиционно до C++11 вам приходилось писать честные структуры, что не очень удобно, да и раскидано определение компаратора от использования. Поэтому теперь Вы можете написать вот такую чудесную конструкцию:
    \begin{minted}{c++}
        [](int a, int b) { return a % 10 < b % 10; };
    \end{minted}
    Во что это преобразуется компилятором? Ну, в тривиальную вещь, в локальный класс, который вы создали прямо внутри функции и у него есть \mintinline{c++}{operator()}. А вообще безымянная функция~--- это некоторый тип, который имеет конструктор копирования, присваивание, ещё немного штук, но не имеет имени.
    \subparagraph{Списки захвата.}
    Теперь поговорим немного за синтаксис. Что происходит в круглых и фигурный скобках, я думаю, понятно, параметры и тело \mintinline{c++}{operator()}. Но вот что такое квадратные? А представьте, что мы хотим сравнивать не по модулю \mintinline{c++}{10}, а по модулю \mintinline{c++}{n}. Тогда локальный класс можно было бы написать так:
    \begin{minted}{c++}
        class mod_n_less
        {
        private:
            int n;

        public:
            bool operator()(int a, int b) const
            {
                return a % n < b % n;
            }

            mod_n_less(int n) : n(n) {}
        };
    \end{minted}
    И то же самое Вы можете сделать и с лямбдой:
    \begin{minted}{c++}
        [n](int a, int b) { return a % n < b % n; };
    \end{minted}
    Но есть вопрос: а Вам надо ссылку на \mintinline{c++}{n} или копию? Тут копия, а можно ссылку: \mintinline{c++}{[&n]}. И ещё есть короткие записи: \mintinline{c++}{[=]} и \mintinline{c++}{[&]}. Это способ передать по значению или ссылке соотвественно все переменные, на которые лямбда ссылается. И ещё можно написать что-то такое: \mintinline{c++}{[=, &a]}~--- передать всё по значению, а \mintinline{c++}{a}~--- по ссылке. Квадратные скобки называются список захвата (capture).\\
    Вопрос на 3000000 рублей: а можете ли вы захватить глобальную переменную? Нет, зачем вам, Вы же можете и так к глобальной переменной обратиться без проблем. Теперь вопрос на 5000000 рублей: а поле класса можно? Так вот нет. \textbf{Мы умеем захватывать только локальные переменные и параметры функции}. Поэтому Вам нужно захватить \mintinline{c++}{this}. Или \mintinline{c++}{[*this]} (второе по значению). После этого Вы можете использовать все поля текущего класса. Кстати, важно знать, что \mintinline{c++}{[=]} захватывает \mintinline{c++}{[this]} (не \mintinline{c++}{[*this]}). Поэтому, по причине ассиметрии, это на данный момент deprecated, и лучше Вам явно писать \mintinline{c++}{[=, this]} или \mintinline{c++}{[=, *this]}.\\
    Всё это очень хорошо, но вдруг нам надо, например, переместить объект внутрь списка захвата или ещё что сложное сделать. Так вот, в C++14 на здоровье:
    \begin{minted}{c++}
        void foo(std::string str)
        {
            [s = std::move(str)]() { /* ... */ };
        }
    \end{minted}
    \subparagraph{Возвращаемое значение?}
    Кстати, а что у лямбды с возвращаемым значением? А вот то, что мы не написали, это \mintinline{c++}{auto}. А можно явно указать тип:
    \begin{minted}{c++}
        [n](int a, int b) -> bool { return a % 10 < b % 10; };
    \end{minted}
    \subparagraph{\mintinline{c++}{mutable}.}
    А вот ещё. Представьте вот такую лямбду: \mintinline{c++}{[n]() { return n++; }}. То есть по сути лямбда, которая считает, сколько её вызвали. Так просто у Вас не получится, потому что сгенерируется код
    \begin{minted}{c++}
        class
        {
        private:
            int n;
            
        public:
            bool operator()(int a, int b) const
            {
                return n++; // Error: const this.
            }
        };
    \end{minted}
    Тогда можно указать \mintinline{c++}{[n]() mutable { return n++; }}.
    \subparagraph{Шаблонные лямбды.}
    Теперь представьте себе разницу
    \begin{minted}{c++}
        template <typename T>
        class less1
        {
            bool operator()(const T&, const T&) { /* ... */ }
        };

        class less2
        {
            template <typename T>
            bool operator()(const T&, const T&) { /* ... */ }
        };
    \end{minted}
    Если бы мы могли сделать шаблонную лямбду, что нам из этого надо? Ну, объективно, простое, потому что лямбду вы моментально создаёте, зачем вам шаблонный класс. И как шаблонную лямбду сделать? Есть общий способ (C++20):
    \begin{minted}{c++}
        []<typename T>(const T& a, const T& b){ /* ... */ }
    \end{minted}
    А ещё есть способ из C++17:
    \begin{minted}{c++}
        [](auto a, auto b){ /* ... */ }
    \end{minted}
    Означает это, что каждое \mintinline{c++}{auto}~--- отдельный шаблонный параметр-тип. Кстати, с C++20, синтаксис с \mintinline{c++}{auto} в параметрах перешёл и на обычные функции (с такой же семантикой: каждое \mintinline{c++}{auto} в аргументах функции~--- отдельный шаблонный параметр типа). Причём буквально:
    \begin{minted}{c++}
        void foo(auto x)
        {
            // ...
        }

        foo<int>(23);
    \end{minted}
    \subparagraph{Прочее.}
    Круто, а какими свойствами обладает лямбда? В смысле, какие у неё есть методы в классе? Во-первых, они умеют копироваться и перемещаться (до тех пор, пока захваченные сущности это умеют). Во-вторых, у них есть конструктор по-умолчанию, если они ничего не захватывают. И, в-третьих, они не умеют присваиваться (ни одним из двух способов). А ещё лямбды с пустым списком захвата можно конвертировать в указатель на функцию. Шаблонные можно только если их присваивать как-то так:
    \begin{minted}{c++}
        void (*p)(int) = []<typename T>(T x) { /* ... */ }; // deduced lambda<int>.
    \end{minted}
    Как с обычными шаблонными функциями, короче.
    \paragraph{Type erasure. \mintinline{c++}{std::function}.}
    Давайте попытаемся передать лямбду в зависимости от флага куда-то. При этом у нас нет проблемы с производительностью, потому что лямбда вызывается редко, а ещё лямбда создаётся где-то далеко от вызова. То есть хочется
    \begin{minted}{c++}
        std::vector<int> v;
        
        /* unknown-type */ cmp = cond ? less<int>() : greater<int>();
        std::ranges::sort(v, cmp);
    \end{minted}
    Да, это будет динамический полиморфизм, но всё же, если нам надо, то надо. Так вот, в C++11 есть специальный тип \mintinline{c++}{std::function}. Так вот нужный нам тип~--- \mintinline{c++}{std::function<bool (int, int)}. Тернарный оператор всё также нам не поможет, но присвоить мы можем без проблем:
    \begin{minted}{c++}
        std::vector<int> v;
        
        std::function<bool (int, int)> cmp;
        if (cond)
            cmp = less<int>()
        else
            cmp = greater<int>();
        std::ranges::sort(v, cmp);
    \end{minted}
    Как эта чёрная магия устроена? Начнём с простого: что такое \mintinline{c++}{bool (int, int)}? Это тип. Функция. Как указатель на функцию, только сама функция. И дальше понятно, как это в шаблон засунуть:
    \begin{minted}{c++}
        template <class T>
        struct function;
        
        template <class R, class... Args>
        struct function<R (Args...)
        {
            /* ... */
        };
    \end{minted}
    Теперь ближе к делу. Что наш \mintinline{c++}{function} должен уметь? Он должен уметь создаваться от любого функционального объекта (будь это лямбда, \mintinline{c++}{std::less} или ещё что). Ну, тут мы можем сделать только одну штуку: шаблонный конструктор. Но непонятно пока, как это сохранить. Ну, как бы, \mintinline{c++}{void*}.
    \begin{minted}{c++}
        template <class T>
        struct function;
        
        template <class R, class... Args>
        struct function<R (Args...)
        {
        private:
            void* func;

        public:
            template <class F>
            function(F func)
                : func(new F(std::move(func)))
            {}
        };
    \end{minted}
    Но тогда у нас проблема с деструктором. Нам нужно как-то освободить память, при этом вызвав деструктор. А вот что можно:
    \begin{minted}{c++}
        template <class T>
        void deleter_func(void* ptr)
        {
            delete static_cast<T*>(ptr);
        }

        template <class T>
        struct function;
        
        template <class R, class... Args>
        struct function<R (Args...)
        {
        private:
            void* func;
            void (*deleter)(void*);
            
        public:
            template <class F>
            function(F func)
                : func(new F(std::move(func)))
                , deleter(deleter_func<F>)
            {}

            ~function()
            {
                deleter(p);
            }
        };
    \end{minted}
    И ровно то же самое можно сделать для \mintinline{c++}{operator()}:
    \begin{minted}{c++}
        template <class T>
        void deleter_func(void* ptr)
        {
            delete static_cast<T*>(ptr);
        }
        template <class F, class R, class... Args>
        R invoker_func(void* ptr, Args args...)
        {
            return (static_cast<T*>(ptr))(args...);
        }
        
        template <class T>
        struct function;
        
        template <class R, class... Args>
        struct function<R (Args...)
        {
        private:
            void* func;
            void (*deleter)(void*);
            R (*invoker)(void*, Args...);
            
        public:
            template <class F>
            function(F func)
                : func(new F(std::move(func)))
                , deleter(deleter_func<F>)
                , invoker(invoker_func<F, R, Args...>)
            {}

            ~function()
            {
                deleter(p);
            }

            R operator()(Args... args)
            {
                return invoker(p, args...);
            }
        };
    \end{minted}
    Дальше бывает нужно учиться делать копию, перемещать, и всё прочее, но это уже понятно.\\
    Кроме \mintinline{c++}{function} люди пытались писать похожие типы (\mintinline{c++}{std::any}, например). Или в разных библиотеках есть \mintinline{c++}{any_iterator}. Правда, в жизни \mintinline{c++}{any_iterator} очень сильно медленные. Тот паттерн, что мы только что написали~--- type erasure, знакомьтесь. А если Вы хотите почитать что-то ещё по теме, то \href{https://github.com/boostcon/2010_presentations/blob/master/thu/type_erasure_pattern_boostcon.pdf}{вот}.
    \section{Сигналы. Реентерабельность.}
    Давайте представим ситуацию, что у нас есть несколько компонент программы, и когда что-то происходит в одном месте, должно что-то происходить совсем в другом. Например, когда мы в тестовом редакторе тыкаем правую кнопку мыши, у нас появляется контекстное меню (которое к редактору отношения не имеет совершенно). Как бы мы могли это реализовать? Ну, мы могли бы хранить у себя какой-нибудь \mintinline{c++}{std::function}, и при происхождении какого-то события его вызывать. Обычно такого достаточно, но нем всегда. Например, вашим событием интересуется несколько сущностей. С нажатием ПКМ это вряд ли, но вот если у вас текст в редакторе поменялся, вы можете хотеть сделать несколько действий. Поэтому вам нужно будет сделать \mintinline{c++}{std::vector<std::function</* ??? */>>}. В таком случае событие называется \textbf{сингалом}, обработчики называются \textbf{слотами}, добавление нового обработчика~--- \textbf{connect}'ом, а вызов всех обработчиков~--- \textbf{emit}'ом.\\
    Давайте это писать. Кажется, что это просто вектор функций, но на самом деле есть детали. У нас будет сигнал \mintinline{c++}{() -> void}, но вообще можно и параметры передавать, и даже иногда (в \mintinline{c++}{boost}, например) возвращать значение. Но это не суть сейчас.
    \begin{minted}{c++}
        struct signal
        {
            using slot_t = std::functional<void ()>;

            signal() = default;

            void connect(slot_t slot)
            {
                slots.push_back(std::move(slot));
            }

            void operator()() const
            {
                for (slot_t const& slot : slots)
                    slot();
            }

        private:
            std::vector<slot_t> slots;
        };
    \end{minted}
    Здесь не хватает \mintinline{c++}{disconnect}. Причём непонятно, как его реализовывать, \mintinline{c++}{std::function} не умеют сравниваться, чтобы их в \mintinline{c++}{vector}'е искать, да и обязывать пользователя сохранять к себе каждый \mintinline{c++}{std::function}, который он добавляет~--- такое себе. Поэтому можно возвращать из \mintinline{c++}{connect} итератор вектора, а в \mintinline{c++}{disconnect} его принимать. Разве что давать любому лоху сам итератор, во-первых, небезопасно (нельзя вызывать на нём \mintinline{c++}{++} и \mintinline{c++}{--}), а, во-вторых, то что у нас вектор~--- деталь реализации. Поэтому создадим обёртку.
    \begin{minted}{c++}
        struct signal
        {
            using slot_t = std::functional<void ()>;

            signal() = default;

            struct connection
            {
                signal* sig;
                std::vector<slot_t>::iterator it;
                
                connection(signal* sig, std::vector<slot_t>::iterator it)
                    : sig(sig), it(it) {}

                void disconnect()
                {
                    sig->slots.erase(it);
                    sig = nullptr;
                }
            };

            connection connect(slot_t slot)
            {
                slots.push_back(std::move(slot));
                return connection(this, std::prev(slots.end()));
            }

            void operator()() const
            {
                for (slot_t const& slot : slots)
                    slot();
            }

            signal(signal&&) = delete;
            signal(signal const&) = delete;

            std::vector<slot_t> slots;
        };
    \end{minted}
    Можно было сделать \mintinline{c++}{disconnect} и в \mintinline{c++}{signal}, но в boost он внутри \mintinline{c++}{connection}, но это не так важно.\\
    А вот что важно, так это то, что \mintinline{c++}{vector} инвалидирует итераторы много когда. И у нас при \mintinline{c++}{disconnect}'е или при добавлении. Это можно поправить через \mintinline{c++}{std::list} или придумать соединением идентификаторы, которые хранить в хэш-таблице. Но это нам не от всего поможет. Есть вот такой случай, когда ничего не работает:
    \begin{minted}{c++}
        struct text_editor
        {
            signal text_changed;
        };

        struct my_component
        {
        private:
            text_editor& editor;
            connection text_changed_connection;

            my_component()
            {
                text_changed_connection =
                        editor.signal.connect([this] { text_changed_handler(); });
            }

            void text_changed_handler()
            {
                /* ... */
                text_changed_connection.disconnect();
            }
        };
    \end{minted}
    Тут у нас на середине emit'а мы будем удалять соединение. То есть в середине collection for'а мы удаляем текущий итератор. Можно пытаться это поправить, заменив collection for на обычный, и делать \mintinline{c++}{*(it++)}. Это поможет от удаления самого себя, но тогда мы не можем отписать другой компонент. Необходимость делать так довольно редка, но всё же встречается (типа вы при сигнале удаляете какой-то компонент, а он подписан на то же событие, и отпишется от него).\\
    Как править будем? Самый просто вариант~--- превентивно скопируем список и будем итерироваться по нему. Тут у нас вот в чём может быть проблема. Представьте, что у вас есть компонент, который при рождении подписывается, в при смерти~--- отписывается от сигнала. Тогда если в вызове сигнала ваш объект кто-то удалит, он не удалится из копии списка, и вам придёт оповещение после смерти.\\
    Поэтому правильный подход другой. Мы можем как-то помечать наши connection'ы как удалённые. Например, мы можем очищать \mintinline{c++}{std::function} при удалении, а из списка удалять соединения при emit'е. Это работает, но если у нас emit происходит редко, а disconnect~--- часто, то мы проиграли. Поэтому давайте в сигнале хранить флаг, находится ли он сейчас в emit'е.
    \begin{minted}{c++}
        struct signal
        {
            using slot_t = std::functional<void ()>;

            signal() = default;

            struct connection
            {
                signal* sig;
                std::vector<slot_t>::iterator it;

                connection(signal* sig, std::vector<slot_t>::iterator it)
                        : sig(sig), it(it) {}

                void disconnect()
                {
                    if (sig->inside_emit)
                        *it = slot_t();
                    else
                        sig->slots.erase(it);
                    sig = nullptr;
                }
            };

            connection connect(slot_t slot)
            {
                slots.push_back(std::move(slot));
                return connection(this, std::prev(slots.end()));
            }

            void leave_emit() const noexcept
            {
                inside_emit = false;
                
                for (auto it = slots.begin(); it != slot.end();)
                    if (*it)
                        ++it;
                    else
                        it = slots.erase(it);
            }

            void operator()() const
            {
                inside_emit = true;
                try
                {
                    for (slot_t const& slot : slots)
                        slot();
                }
                catch (...)
                {
                    leave_emit();
                    throw;
                }
                leave_emit();
            }

            signal(signal&&) = delete;
            signal(signal const&) = delete;

            mutable std::list<slot_t> slots;
            mutable bool inside_emit = false;
        };
    \end{minted}
    У этого всё ещё есть проблемы, но в очень специфичном случае: если у нас сигнал подписан на сам себя (возможно, косвенно). Поэтому \mintinline{c++}{inside_emit} делают счётчиком вложенности.\\
    Есть ещё более интересная ситуация. Когда мы при исполнении слота убиваем сигнал целиком. Обычно это происходит, когда мы убиваем не сигнал, а класс, в котором он лежит. И тут можно либо обмазаться \mintinline{c++}{shared_ptr}, либо сделать иначе: можно добавить в сигнал \mintinline{c++}{bool* destroyed}, и в emit'е делать вот что:
    \begin{minted}{c++}
        void operator()() const
        {
            bool is_destroyed = false;
            
            bool* old_destroyed = destroyed;
            destroyed = &is_destroyed;
            
            ++inside_emit;
            try
            {
                for (slot_t const& slot : slots)
                {
                    if (slot)
                    {
                        slot();
                        if (is_destroyed)
                        {
                            *old_destroyed = true;
                            return;
                        }
                    }
                }
            }
            catch (...)
            {
                destroyed = old_destroyed;
                leave_emit();
                throw;
            }
            
            destroyed = old_destroyed;
            leave_emit();
        }
        
    \end{minted}
    Мораль от всего отсюда:
    \begin{enumerate}
        \item \textbf{Никогда не пишите сигналы руками}. Не надо думать: <<А, я сделаю \mintinline{c++}{std::vector<std::function>} и всё будет норм>>. Нет, не будет.
        \item Когда вы используете сигналы из библиотеки, ознакомьтесь с её документацией. Она может давать не все гарантии. Библиотека может делать копию слотов при emit'е, например.
        \item Если у вас простой случай, и вы хотите написать простой \mintinline{c++}{signal} чисто под этот случай, то напишите, но поставьте \mintinline{c++}{assert}'ы.
    \end{enumerate}
    Вообще у нас тут происходит вот что: мы думаем о том, можем ли мы, находясь в глубине стека, делать что-то. Это имеет научное название: реентерабельность. И мы тут изобретали такой сигнал, чтобы все его методы были реентерабельными. Причём тут вопрос ещё более грустный. Мы справились с \mintinline{c++}{signal}'ом. Но он же у нас где-то лежит, и не будет ли проблем с реентерабельностью методов того класса...\\
    Кстати, обычно, реентерабельность проявляется много где. Вот считаете вы хэш-код. И вызываете функцию. Может ли она взять и в эту таблицу полезть? Да ну бред какой-то, зачем вам это. Но вот она: реентерабельность во всей красе. Только тут вы изначально делаете что-то странное. И в большинстве случаев про реентерабельность просто не говорят.
    \section{Обработка ошибок, ассёрты, контракты.}
    В этой теме есть фундаментальная проблема. В её обсуждении люди расходятся во мнениях. И неправда, что кто-то из них глуп или не обладает информацией или ещё чего. Тут разница во мнениях, вероятно, вызвана индивидуальными предпочтениями.\\
    Но всё же наличие спорных моментов не значит, что про эту тему не надо говорить. Во многом мнения людей сходятся, да и для обсуждения разных мнений нам нужна терминология.
    \paragraph{\mintinline{c++}{assert}.}
    Несмотря на то, что эта тема уже была, давайте вкратце её повторим.\\
    \mintinline{c++}{assert}~--- это макрос, который, в зависимости от макроса \mintinline{c++}{NDEBUG} может значит либо ничего, либо проверка условия и \mintinline{c++}{std::abort()}.
    \begin{minted}{c++}
        #ifdef NDEBUG
        #  define assert(condition) ((void)0)
        #else
        #  define assert(condition) /*implementation defined*/
        // В жизни бывает что-то такое:
        // if (!(condition))
        //     std::abort();
        #endif
    \end{minted}
    Когда этой штукой надо пользоваться? Ну, например, когда мы пишем структуру данных и хотим проверить, что у нас всегда выполняется инвариант. Или мы пишем свою функцию сортировки, и после этого хотим проверить, что массив у нас отсортирован: \mintinline{c++}{assert(std::is_sorted(vec.begin(), vec.end()))}.\\
    И зачем это идейно всё нужно? Чтобы мы не могли получить некорректные данные, а потом их передать. Получив некорректные данные, мы сразу узнаем их некорректность, тем самым сэкономив себе время на отладку.\\
    Когда \mintinline{c++}{assert} не надо использовать? Ну, например тут не надо:
    \begin{minted}{c++}
        FILE* f = fopen("filename.txt", "r");
        assert(f);
    \end{minted}
    Когда файл не открылся, это штатная ситуация. Более того, если мы пишем, что наша программа не может работать без файла, логично сообщить об этом пользователю и завершиться напрямую. Ведь \mintinline{c++}{assert}'ы можно выключит и остаться без этой проверки. Или ещё \mintinline{c++}{assert} не надо использовать так:
    \begin{minted}{c++}
        assert(fclose(f) == 0);
    \end{minted}
    Тут, если отключить вам \mintinline{c++}{assert}'ы, вы никогда не закроете файл.\\
    Это всё очень хорошо, но зачем тогда \mintinline{c++}{assert}'ы отключать? Ну, потому что когда вы написали достаточно \mintinline{c++}{assert}'ов, ваша программа замедляется вдвое. Вы пишете двоичный поиск и ставите \mintinline{c++}{assert} на то, что массив отсортирован. И асимптотика с $O(\log n)$ возрастает до $O(n)$.\\
    Кстати. Пишите \mintinline{c++}{assert}'ы, пожалуйста, попроще. Если у вас сложные \mintinline{c++}{assert}'ы, вы могли набагать в самих условиях, которые вы пишете. И тут у вас совсем всё грустно получается.\\
    Также помимо \mintinline{c++}{assert}'ов у нас есть санитайзеры, которые работают сходим образом и дебажная версия стандартной библиотеки. Второе нужно, чтобы мы не делали \mintinline{c++}{++} past-to-end итератору списка (\mintinline{c++}{std::list} обычно циклический, сделав \mintinline{c++}{++} итератору \mintinline{c++}{end}, получим \mintinline{c++}{begin}, и никакие address sanitizer'ы нас не спасут).\\
    А чем отличаются все вот эти друзья:
    \begin{minted}{c++}
        std::abort();
        std::terminate();
        std::exit(EXIT_FAILURE);
        std::quick_exit(EXIT_FAILURE);
        std::_Exit(EXIT_FAILURE);
        __debugbreak();   // MSVC only.
        __builtin_debugtrap(); // Clang only.
        raise(SIGTRAP);   // POSIX only.
        __builtin_trap(); // GCC only.
    \end{minted}
    А вот:
    \begin{minted}{c++}
        /* Функция из C, аварийно завершающая программу.
         * Для операционной системы это то же, что и деление на ноль или ещё что страшное.
         */
        std::abort();
        /* До C++03 вызывается из-за проблемы с исключениями.
         * Двойное исключение, или исключение из noexcept-функции, или ещё чего такое.
         * Но в C++11 появились и другие причины.
         * Поэтому сейчас это скорее плюсовый аналог abort.
         * Ещё terminate можно перекрыть обработчиком,
         *     но вообще это то же самое аварийное завершение.
         */
        std::terminate();

        /* Более штатное завершение программы. Для операционной системы всё хорошо.
         * Всем троим можно повесить обработчики, но у них есть проблемы.
         * Ни exit, ни quick_exit не вызовут деструкторы локальных переменных.
         * Exit вообще ничей деструктор не вызовет, а просто завершит программу.
         * В случае с exit и quick_exit всё осбенно плохо с многопоточным кодом:
         *     вы начнёте удалять глобальные переменные, а у вас ещё потоки работают.
         * Лучше просто выходите из main'а по return.
         */
        std::exit(EXIT_FAILURE);
        std::quick_exit(EXIT_FAILURE);
        std::_Exit(EXIT_FAILURE);

        /* Функции, приводящая к специальной инструкции.
         * Инструкция называется int 3 --- используется отладчиками для break point'ов.
         * Если у вас нет отладчика, программа завершается.
         * Кстати, в MSVC abort является похож __debugbreak.
         */
        __debugbreak();   // MSVC only.
        __builtin_debugtrap(); // Clang only.
        raise(SIGTRAP);   // POSIX only.

        // Целенаправленно некорректная инструкция (ud2). 
        __builtin_trap(); // GCC only.
    \end{minted}
    Мораль: если вы хотите сообщить о критической ошибке~--- используйте \mintinline{c++}{std::abort}/\mintinline{c++}{std::terminate}. Эти двое могут дать управление отладчику, чтобы всё у вас было хорошо.\\
    Всё, что мы обсуждали, все наши ошибки, можно разделить на два класса: internal consistency error и uncommon case. Первое~--- это всё, когда у нас проблема в Вашем коде, второе~--- просто странные ситуации, а которых мы обычно не думаем (файл не открылся, например). Второе нужно обрабатывать честно в зависимости от контекста. Не открылся файл~--- сообщите об этом вызывающей функции, чтобы она с этим разобралась. Или если у вас есть контекст, сами уведомите об этом пользователя. А вот что делать с internal consistency error, уже вопрос. Есть 4 стратегии:
    \begin{enumerate}
        \item Игнорирование.
        \item \mintinline{c++}{std::abort}.
        \item Уведомить об этом вызывавшего (исключение или код ошибки).
        \item Запись в лог и продолжение работы.
    \end{enumerate}
    \begin{enumerate}
        \item Используется намного чаще, чем хотелось бы и чем задумано. Чтобы это написать, надо подумать, а постоянно думать~--- сложно и энергозатратно. Но не делайте так, пожалуйста. Лучше пишите логи.
        \item Сразу при возникновении ошибки мы видим, что происходит. Не можем записать в базу данных некорректные данные, а некорректные данные в базе данных~--- то, с чем просто невозможно разобраться пост-фактум.\\
        Но есть и аргументы против. Если у нас сломался какой-то декор (или что-то другое необязательное), не обязательно абортиться.
        \item Плюсы исключений мы прекрасно знаем, а давайте обсудим минусы. А минус тут вот какой: когда у вас есть исключения, вы получаете понятие exception-safe. Вам приходится думать о том, что будет, если будет исключение. А если не подумаете, у вас может всё сломаться совсем иначе, и будет как с игнорированием ошибок.
        \item В отличие от исключения это нельзя заигнорировать (в исключениях какой-то дурак может написать \mintinline{c++}{try {/*...*/} catch (...) {}}). И всё также при поломке декора всё у нас норм.\\
        А из минусов: ошибки такого рода чинятся с меньшим приоритетом. Если \mintinline{c++}{abort}, то всё, программа не работает. А если у вас логи, то вы ещё должны заставить вашего коллегу это починить.
    \end{enumerate}
    Что ещё можно сказать про \mintinline{c++}{assert}'ы? А то, что они выполняют ещё и документирующую функцию. По классу сложно догадаться, какой у него инвариант, а по хорошо написанным \mintinline{c++}{assert}'ам~--- очень легко.
    \paragraph{Контракты.}
    Мы знаем, что такое контракты. Но пока мы не знаем ещё пару терминов.\\
    Есть \textit{narrow contract}: когда мы накладываем ограничения, их нарушение~--- UB, а есть \textit{wide contract}: всё совершенно чётко определено. Например, мы чётко говорим, что мы кидаем исключение в случае чего. Например, в C++ сложение чисел обладает узким контрактом для знаковых чисел и широким~--- для беззнаковых.
    \section{Разные языковые конструкции на примере \mintinline{c++}{std::optional}.}
    \paragraph{\mintinline{c++}{std::optional}.}
    Пусть у нас есть какой-то класс, который позволяет отложить какое-то вычисление. Понятно, что его просто реализовать так: храним значение и флаг, посчитали ли его:
    \begin{minted}{c++}
        struct deferred_value
        {
        public:
            int get_value() const
            {
                if (!is_initialized)
                {
                    value = compute_value();
                    is_initialized = true;
                }

                return value;
            }

            int compute_value() const;

        private:
            mutable int value;
            mutable bool is_initialized = false;
        };
    \end{minted}
    В чём проблема? В том, что у нас две переменные. Поля этого класса связаны: можно обращаться к одному, только если второе. Пока класс у нас небольшой, всё хорошо, а когда подобные штуки есть в классах побольше, связь улетучивается. А ещё хочется, чтобы корректное обращение компилятор проверял, а не человек. И третье: нам нужно, чтобы значение было DefaultConstructible, хотя нам это совершенно не нужно. Это легко исправляется при помощи \mintinline{c++}{std::aligned_storage_t}, но для этого в стандартной библиотеке уже есть тип: \mintinline{c++}{std::optional}.
    \begin{minted}{c++}
    template <class T>
    struct optional
    {
    public:
        optional() : is_initialized(false) {}
        optional(T value) : is_initialized(true)
        {
            new (&storage) T(std::move(value));
        }
        optional(optional const& other) : is_initialized(other.is_initialized)
        {
            if (is_initialized)
                new (&storage) T(*other);
        }
    \end{minted}
    \pagebreak
    \begin{minted}{c++}
        optional& operator=(optional const& other)
        {
            if (is_initialized)
            {
                if (other.is_initialized)
                    **this = *other;
                else
                {
                    reinterpret_cast<T&>(storage).~T();
                    is_initialized = false;
                }
            }
            else
                if (other.is_initialized)
                {
                    new (&storage) T(*other);
                    is_initialized = true;
                }
        }
        ~optional()
        {
            if (is_initialized)
            reinterpret_cast<T&>(storage).~T();
        }
        operator bool() const
        {
            return is_initialized;
        }
        T& operator*()
        {
            return reinterpret_cast<T&>(storage).~T();
        }
        T const& operator*() const
        {
            return reinterpret_cast<T const&>(storage).~T();
        }

    private:
        bool is_initialized;
        std::aligned_storage_t<sizeof(T), alignof(T)> storage;
    };
    \end{minted}
    И теперь, используя \mintinline{c++}{optinal}, мы получим явно видимую связь \mintinline{c++}{bool} и \mintinline{c++}{T}, все адекватные реализации \mintinline{c++}{optional} кидают исключение в отладочном режиме, если некорректно обращаться, и вообще всё хорошо.\\
    Что ещё имеет смысл сказать про \mintinline{c++}{optional}? В нашей реализации мы должны создать объект вне и \mintinline{c++}{move}'нуть объект внутрь. А это может быть плохо, поэтому ещё \mintinline{c++}{optinal} умеет в \mintinline{c++}{emplace}:
    \begin{minted}{c++}
        template <class... Args>
        void emplace(Args&&... args)
        {
            if (!is_initialized)
                reinterpret_cast<T&>(storage).~T();
            new (&storage) T(std::forward<Args>(args)...);
            is_initialized = true;
        }
    \end{minted}
    И ещё у \mintinline{c++}{optional}'е есть такая же функция, но конструктор, которая просто принимает дополнительный параметр (пустую структуру) своим аргументом.\\
    Ещё у \mintinline{c++}{optinal} есть такая штука как \mintinline{c++}{nullopt_t}~--- пустая структурка, которая при присваивании её в \mintinline{c++}{optional} сбрасывает его состояние.\\
    Ещё \mintinline{c++}{optinal} умеет в сравнение (если в сравнение умеет шаблонный тип): при этом \mintinline{c++}{nullopt} считается меньше все.\\
    Как у \mintinline{c++}{vector}'а есть \mintinline{c++}{at} и \mintinline{c++}{operator[]} с широким и узким контрактом соотвественно, так и у \mintinline{c++}{optinal}'а есть \mintinline{c++}{value} и \mintinline{c++}{operator*}.\\
    А что делать с \mintinline{c++}{optional}'ом при перемещении? Надо ли разрушать тот, из которого переместили? Нет, не надо, кому надо~--- сам разрушит. В стандартной библиотеке даже явно написано, что \mintinline{c++}{optional}, из которого переместили, хранит значение, (из которого переместили).
    \paragraph{\mintinline{c++}{noexcept}.}
    Если всё это примитивно дописать, у полученного класса будет некоторое количество недостатков. Например, у нас есть конструктор перемещения и оператор перемещения. Обычно хотят, чтобы они были \mintinline{c++}{noexcept}. Ст\'{о}ит ли так написать? Ну, нет, ведь внутренний тип может бросать исключение при перемещении. А почему плохо не писать \mintinline{c++}{noexcept}? Ну, ничего плохого не случится, но если у нас тип \verb|nothrow_move_constructible|, то можно применить некоторые оптимизации (чтобы \mintinline{c++}{std::function} мог применить small-object optimization, тип должен быть именно таким). Ещё пример~--- реаллокация \mintinline{c++}{vector}'а. Если у тебя адекватное перемещение, ты можешь просто переместить элементы из старого буфера в новый и не париться. Если же они могут бросить исключение, то тебе придётся их копировать. Поэтому бывает полезно помечать конструктор и оператор перемещения как \mintinline{c++}{noexcept}.\\
    Кстати, что интересно, ещё одна операция, которую очень полезно делать \mintinline{c++}{noexcept}~--- подсчёт хэша. По той же причине: когда у нас происходит перехэширование, нам надо посчитать много хэш-кодов, и если вы при этом можете исключение бросить, перехэширование не работает, поэтому рядом с каждым элементом начинают хранить хэш-код.\\
    Вторая функция \mintinline{c++}{noexcept}~--- документирующая, когда нам хочется полагаться на это корректности программы ради. А ещё давайте вспомним zero-cost исключения. На самом деле даже если исключений нет, то их возможность стоит нескольких процентов скорости (почему~--- вопрос: возможно, нужно меньше переупрядочивать код, возможно, это артефакты и т.д.) и довольно много стоит по размеру файла. Поэтому \mintinline{c++}{noexcept} позволяет избавляться от этой проблемы.\\
    Но вообще не надо помечать всё как \mintinline{c++}{noexcept}: имея тело функции компилятор может и сам сообразить, что \mintinline{c++}{noexcept}, а что нет, но это только с LTO, а без LTO становится грустно:
    \pagebreak
    \begin{minted}{c++}
        optional(optional&& other) noexcept(std::is_nothrow_move_constructible_v<T>)
            : is_initialized(other.is_initialized)
        {
            if (is_initialized)
                new (&storage) T(*other);
        }
        optional& operator=(optional&& other)
            noexcept(std::is_nothrow_move_constructible_v<T>
                  && std::is_nothrow_move_assigneble_v<T>)
        {
            if (is_initialized)
            {
                if (other.is_initialized)
                    **this = std::move(*other);
                else
                {
                    reinterpret_cast<T&>(storage).~T();
                    is_initialized = false;
                }
            }
            else
                if (other.is_initialized)
                {
                    new (&storage) T(std::move(*other));
                    is_initialized = true;
                }
        }
    \end{minted}
    А вообще в языке существует возможность проверить любое выражение на \mintinline{c++}{noexcept}. Напишите его так: \mintinline{c++}{noexcept(expr)}, и теперь можно написать так: \mintinline{c++}{noexcept(noexcept(expr))}, и ваша функция будет \mintinline{c++}{noexcept} тогда и только тогда, когда \mintinline{c++}{expr}.
    \paragraph{Тривиальные операции.}
    Пусть есть два класса:
    \begin{minted}{c++}
    struct foo
    {
        int a, b;
    }

    struct bar
    {
        int a, b;

        ~bar() {}
    }
    \end{minted}
    В чём разница? В том, что на \mintinline{c++}{foo} можно не вызывать деструктор при уничтожении, а в \mintinline{c++}{bar}~--- надо.\\
    С точки зрения компилятора эти два типа отличаются тем, что \mintinline{c++}{foo} не имеет никакого деструктора. А \mintinline{c++}{bar} имеет деструктор, и это обычная функция (но так уж сложилась, что она ничего не делает).\\
    Говорят, что класс обладает тривиальным деструктором, если
    \begin{enumerate}
        \item Он не написан (т.е. сгенерирован автоматически) или явно прописан как \mintinline{c++}{default}.
        \item Он не виртуальный.
        \item Деструкторы всех баз тривиальны.
        \item Деструкторы всех нестатических полей тривиальны.
    \end{enumerate}
    Аналогично определяется тривиальность копирования (обоих копирований), перемещения (обоих перемещений), и создания по умолчанию. Когда нам эти штуки важны? Ну, во-первых, это необходимо для некоторых классов (например, в \mintinline{c++}{std::atomic} вы можете запихать любой созданный вами тип, если он тривиально копируется). Тривиальное копирование~--- это когда копирование равносильно \mintinline{c++}{memcpy}. И отсюда становится понятно, что, например, при реаллокации вектора можно просто этот \mintinline{c++}{memcpy} и сделать, а не в цикле что-то вызывать.\\
    И на что тривиальность влияет~--- так это на ABI. Тривиально-разрушаемый тип можно в регистрах вернуть, а нетривиально-разрушаемый придётся передавать параметром в функцию и конструировать на памяти.\\
    Кстати, а что мешает компилятору увидеть \mintinline{c++}{~bar() {}} и удалить его за ненадобностью? А вот мы хотим, чтобы где бы у нас не был написан деструктор, ABI был один, а если он написан в другом месте, мы так сделать не сможем. А проблема тут в том, что в следующем обновлении мы можем сделать деструктор не пустым, и любой код, использующий \mintinline{c++}{bar}, проиграет. И в чём ещё проблема~--- хочется быть независимым от версии компилятора. Если у нас ABI меняется от оптимизирующих способностей компилятора, то грустно жить. На тему ABI можно ещё посмотреть презентацию \href{https://www.youtube.com/watch?v=rHIkrotSwcc}{<<There are no zero-cost abstractions>>} и увидеть, что у нас даже \mintinline{c++}{unique_ptr} из-за нетривиального разрушения не может быть возвращён из функции через регистры как указатель.\\
    Итак, что нам хочется? Нам хочется, чтобы когда \mintinline{c++}{T} тривиально разрушается, то \mintinline{c++}{optional<T>}~--- тоже тривиально разрушается. Как это сделать? \mintinline{c++}{enable_if}? Ну, для деструктора это не сработает совсем, а если сделать шаблонные конструктор копирования, то это будет уже не конструктор копирования, и компилятор сгенерирует свои. Можно взять и сделать специализацию \mintinline{c++}{optinal}'а, но у нас 6 операций, которые могут быть тривиальными, и у 5 из них хочется сохранить свойства. Поэтому нам придётся написать $2^5$ вариантов \mintinline{c++}{optinal}'а, что совершенно огромное дублирование кода. Что можно с этим сделать? Можно создать несколько шаблонных баз и просто отнаследовать от одной из них в зависимости от тривиальности копирований/разрушения/перемещений...
    \paragraph{SFINAE-friendly функции.}
    Что ещё мы можем протаскивать как свойство~--- копируется ли тип в принципе. В нашей реализации копирование и так не скомпилируется, но нам же хочется, чтобы у нас ещё и \mintinline{c++}{std::is_copy_constructible_v} был правильно задан (например, \mintinline{c++}{std::variant} работает по-разному в зависимости от этого). Так вот если снаружи можно проверить, всё ли будет хорошо при вызове функции с заданным параметром (в нашем случае при вызове метода с заданным параметром шаблона), то такая функция называется SFINAE-friendly. Поэтому, кстати, в \mintinline{c++}{std::atomic} (где условия написаны \mintinline{c++}{static_assert}'ами) всё с этим плохо.\\
    А насколько важно вообще иметь SFINAE-friendly операции? Ну, важно, но очень геморройно (до появления концептов в C++20).\\
    Как можно было бы реализовать это для \mintinline{c++}{optional}'а? Да тривиально, у нас есть два варианта базы, отвечающей за копирование, давайте будет три.
    \begin{minted}{c++}
    template <typename T,
    bool CopyConstructible = std::is_copy_constructible_v<T>,
    bool TriviallyCopyConstructible = std::is_trivially_copy_constructible_v<T>>
    struct optional_copy_constructor_base : optional_storage_base<T>
    {
        optional_copy_constructor_base() = default;
        optional_copy_constructor_base(optional_copy_constructor_base const& other) = delete;
        optional_copy_constructor_base(optional_copy_constructor_base&&) = default;
    };
    \end{minted}
    \pagebreak
    \begin{minted}{c++}
    template <typename T>
    struct optional_copy_constructor_base<T, true, false> : optional_storage_base<T>
    {
        using optional_storage_base<T>::is_initialized;
        using optional_storage_base<T>::storage;
        
        optional_copy_constructor_base() = default;
        optional_copy_constructor_base(optional_copy_constructor_base const& other)
        {
            is_initialized = other.is_initialized;
            if (is_initialized)
                new (&storage) T(*other);
        }
        optional_copy_constructor_base(optional_copy_constructor_base&&) = default;
    };
    
    template <typename T>
    struct optional_copy_constructor_base<T, true, true> : optional_storage_base<T>
    {};
    \end{minted}
    \paragraph{Conditionally-explicit конструктор.}
    И всё бы у нас было хорошо, если бы не одно но. У \mintinline{c++}{std::optional<T>} есть конструктор от \mintinline{c++}{std::optional<U> const&}. Причём хочется, чтобы он мог быть явным или неявным в зависимости от того, конвертируется ли \mintinline{c++}{U} в  \mintinline{c++}{T} явно или нет.\\
    Ну, это тоже тривиально пишется, благо у \mintinline{c++}{explicit} тоже можно логическое выражение написать:
    \begin{minted}{c++}
        template <typename U,
                  std::enable_if_t<std::is_constructible_v<T, const U&>, bool> = true>
        explicit(!std::is_convertible_v<const U&, T>)
        optional(optional<U> const& other)
        {
            if (other)
                emplace(*other);
        }
    \end{minted}
    \paragraph{\mintinline{c++}{constexpr}.}
    \subparagraph{Мотивация.}
    А давайте сейчас на \mintinline{c++}{variant} посмотрим. Чем он глобально отличается от \mintinline{c++}{optional}'а? Ну, у него вместо флага индекс. И \mintinline{c++}{std::aligned_storage_t} такой, что может хранить любой из типов. Вот, например, \mintinline{c++}{std::variant} от двух типов:
    \begin{minted}{c++}
        template <class A, class B>
        struct either
        {
            size_t which;
            std::aligned_storage_t<std::max(sizeof(A), sizeof(B)),
                                   std::lcm(sizeof(A), sizeof(B))> storage;
        };
    \end{minted}
    Но вот в C++03 была бы существенная проблема: \mintinline{c++}{std::max} не умеет в вычисления на этапе компиляции. Поэтому пришлось извращаться бы:
    \begin{minted}{c++}
        template <size_t a, size_t b>
        struct max
        {
            static size_t const value = a < b ? b : a;
        };
    \end{minted}
    И это чудо не только читается сложно и пишется долго, это и для компилятора не так просто: класс~--- не самая простая штука.\\
    А во время компиляции считать хочется: иногда (как тут) это жизненно необходимо, а иногда можно и во время исполнения, но очень хочется при компиляции. Вспомните \mintinline{c++}{function}: каждый новый объект, который мы подставляем в \mintinline{c++}{function} заводит новую статическую таблицу. А давайте посмотрим, как это работает. Что происходит, если мы напишем что-то такое:
    \begin{minted}{c++}
        int foo() { /* ... */ }
        int a = foo();
    \end{minted}
    Здесь до запуска \mintinline{c++}{main} запустится \mintinline{c++}{foo} и проинициализирует переменную. И у нас то же самое происходило бы каждый раз в \mintinline{c++}{function}'ах, чем больше бы мы их использовали.\\
    Или вот ещё пример: у нас есть парсер, лексер или ещё какой-то разборщик языка. И мы хотим каждое ключевое слово запихнуть в хэш-таблицу. И очень-очень хочется, чтобы хэш-функция была построена с маленьким количеством бакетов, если все ключевые слова мы знаем заранее. В C для этого использовали кодогенераторы (берём слова, наша программа генерирует нам код той хэш-функции, что нам нужна). Но зачем, можно же сделать так, чтобы на нашем родном языке всё было бы хорошо. И ещё тысячу разных примеров можно придумать, когда хочется вычисления на этапе компиляции: \href{https://github.com/hanickadot/compile-time-regular-expressions}{регулярные выражения}, например.
    \subparagraph{\mintinline{c++}{constexpr}-функции.}
    Итак, что сделали? Сделали возможность пометить функцию как такую, что можно посчитать во время компиляции.
    \begin{minted}{c++}
        template <class T>
        constexpr T max(T const& a, T const& b)
        {
            return a < b ? b : a;
        }
    \end{minted}
    В C++11 всё было консервативно: Вы не можете написать что угодно в \mintinline{c++}{constexpr}-функции (там должен был быть только один \mintinline{c++}{return}, да и вернуть всё что угодно нельзя...) Но чем дальше в лес, тем больше стало можно делать во время компиляции. Типа, почему тернарный оператор написать можно, а \mintinline{c++}{if} нельзя? Давайте разрешим. Почему рекурсию можно, а \mintinline{c++}{while} нельзя? Давайте тоже разрешим. Это было сделано в C++14. И таким образом у нас есть интерпретатор C++ внутри компилятора C++. В LLVM ещё и компилятор туда вставили, чтобы интерпретировать не код сразу, а ещё переведём его в более удобное представление. Осталось только сделать JIT-компилятор на этапе компиляции. В C++17 лямбды стали \mintinline{c++}{constexpr}, в C++20 стало возможно вызывать виртуальные функции и делать аллокации (правда, не любые, вы обязаны в \mintinline{c++}{constexpr} всё освободить), в C++23 появился \mintinline{c++}{constexpr} \mintinline{c++}{unique_ptr}, математические функции...\\
    Кстати. А всегда ли обязана функция вычислиться во время компиляции? Ну, объективно, нет
    \begin{minted}{c++}
        int isqrt(int n)
        {
            if (n < 0)
                throw new runtime_error("Integer square root of negative value.");
            /*
             * Вычисляем целочисленный квадратный корень.
             */
        }

        int x = isqrt(-1);
    \end{minted}
    Ну, разумеется, нет. И тут даже нет ошибки компиляции, тут просто во время исполнения вы получите исключения. Исключения нельзя выкидывать из \mintinline{c++}{constexpr}. Ровно как и нельзя, чтобы \mintinline{c++}{constexpr}-функция делала UB: иначе вашу функцию просто не посчитают во время компиляции (кстати, этим даже пользуются: UB в \mintinline{c++}{constexpr} ловит вам UB и утечки памяти, напишем всё \mintinline{c++}{constexpr} и хороший компилятор сам найдёт обращение вне массива, неверное обращение к \mintinline{c++}{union}'у и кучу всего другого...) В конце концов вы можете вызвать не-\mintinline{c++}{constexpr} функцию в \mintinline{c++}{constexpr}, и тогда, если исполнение дойдёт до этого, во время компиляции вашу функцию считать не будут. Короче, \mintinline{c++}{constexpr}~--- то, что можно попробовать вычислить во время компиляции.\\
    Так а какой тогда у \mintinline{c++}{constexpr}'а смысл, если это разрешает компилятору считать функции во время компиляции? Не сделать ли все функции \mintinline{c++}{constexpr} по умолчанию? Вон, в GCC есть флаг \mintinline{console}{-fimplicit-constexpr}, который так делает. Ну, да, но нет. Если Вы знаете, что вашу функцию бессмысленно (но можно) считать во время компиляции, то компиляторы бы тратили кучу времени на то, что пытались.\\
    Кстати, а что нельзя писать в \mintinline{c++}{constexpr}? \mintinline{c++}{goto}. Или \mintinline{c++}{try}. Но это, вероятно, пока никто proposal соответствующий не написал. А вот что делать явно и фундаментально нельзя~--- это ASM-вставки и вызов функций без тела. Это понятно, почему так. А вот что непонятно, это \mintinline{c++}{reinterpret_cast}. С ним просто непонятно, его фундаментально нельзя или ещё какая причина, но вот можете почитать \href{https://lists.isocpp.org/std-discussion/2021/10/1442.php}{тред на эту тему}. А вообще есть \mintinline{c++}{std::bit_cast}, который в хороших компиляторах даже проверяется, что объекты не содержат паддинг.\\
    Кстати, про аллокации. Как уже было сказано, мы можем их использовать только если мы всё освободим в конце (такие аллокации называются \textit{transient}). Но это же не удобно, если мы хотим заполнить \mintinline{c++}{vector} заранее и вернуть его. И поэтому есть спрос на non-transient аллокации внутри \mintinline{c++}{constexpr}, но пока совершенно непонятно, как это сделать.\\
    А ещё вот за что поговорим: может ли компилятор проигнорировать \mintinline{c++}{new} и \mintinline{c++}{delete}, если видит их рядом и не видит нужны действительно выделять и освобождать память? Ну, может, а почему нет. Но вот что не может, так это вот что:
    \begin{minted}{c++}
        delete new int(42);               // Можно обойти.
        operator delete(operator new(8)); // Нельзя обойти.
    \end{minted}
    Почему? Ну, потому что \mintinline{c++}{operator new} и \mintinline{c++}{operator delete}~--- обычные функции, \textbf{и их можно подменить}. Поэтому лучше использовать вызовы \mintinline{c++}{std::allocator}, их обходить по стандарту можно. К чему это, собственно, всё? А к тому, что в \mintinline{c++}{constexpr} разрешено только то, что можно обходить.
    \subparagraph{\mintinline{c++}{constexpr}-переменные.}
    Если у нас переменная~--- compile-time константа, то её значение просто вбивается в бинарник, а если нет, то компилятор создаёт специальную функцию, которая инициализирует переменную. Но иногда мы хотим заставить компилятор посчитать переменную во время компиляции. Для этого и можно пометить переменную как \mintinline{c++}{constexpr}.\\
    Что ещё важно понимать про \mintinline{c++}{constexpr}-переменные, так это то, что по умолчанию они видны только в единице трансляции. Почему? А потому что \mintinline{c++}{constexpr}~--- это конъюнкция двух вещей: \mintinline{c++}{const} и наличия статического инициализатора, а \mintinline{c++}{const} расширяет \mintinline{c++}{static}. Почему \mintinline{c++}{const} включает в себя \mintinline{c++}{static}? Потому что \mintinline{c++}{const} придумали отчасти для того, чтобы не использовать \mintinline{c++}{#define}'ы, а \mintinline{c++}{#define}'ы часто встречаются в заголовочных файлах. В связи с этим \mintinline{c++}{constexpr}-переменные статические, а значит, когда вы определяете переменную в заголовочном файле, вам надо явно указать ей \mintinline{c++}{inline}, если вы не хотите много копий данной переменной.
    \subparagraph{\mintinline{c++}{constinit}.}
    А можем ли мы хотеть изменяемую переменную, но со статическим инициализатором? Ну, можем, для этого есть \mintinline{c++}{constinit}. Нужно это бывает для многопоточности. Есть такой модификатор~--- \mintinline{c++}{thread_local}~--- каждый поток имеет свою копию переменной. Вообще все компиляторы имели свои аналоги \mintinline{c++}{thread_local}, но они требовали ещё и статический инициализатор (так взаимодействие с ОС проще получалось). Поэтому теперь добавили \mintinline{c++}{constinit}, который часто встречается вместе с \mintinline{c++}{thread_local}. Зачем нам для этого ключевое слово, почему просто не \mintinline{c++}{if}'ать, какой там инициализатор? Потому что Вы можете только объявить переменную где-то, а не определить. И тогда компилятор обязан предполагать худшее. А с \mintinline{c++}{constinit}'ом в объявлении Вам гарантируют, что всё будет хорошо.
    \subparagraph{\mintinline{c++}{consteval}.}
    В C++ есть proposal, связанный с compile-time reflection'ом. Т.е. позволить изнутри программы во время компиляции получать, например, список полей. Понятно, что мы не хотим отправлять это в runtime (иначе нам всю информацию о классах засовывать в бинарник), а во время компиляции~--- почему нет. Самый простой пример~--- автоматическая генерация сереализаторов.\\
    И для этого нам нужны функции, которые \textbf{обязаны} посчитаться во время компиляции. Для этого есть модификатор \mintinline{c++}{consteval}. Поскольку в данный момент compile-time reflection'а у нас нет, он применяется очень редко, но всё же пара примеров есть. Например, \mintinline{c++}{std::source_location::current()}~--- функция, являющаяся более хорошим способом во время компиляции указывать кому-нибудь файл и номер строки (нежели макросы \mintinline{c++}{__FILE__} и \mintinline{c++}{__LINE__}).
    \subparagraph{\mintinline{c++}{is_constent_evaluated}. \mintinline{c++}{if consteval}.}
    На \mintinline{c++}{constexpr}-функции наложены некоторые ограничения: нельзя, например, делать \mintinline{c++}{memcpy}. И в таком случае есть беда: может быть такая функция, что runtime'овый код, который там написан, нельзя посчитать в compile-time'е, а использовав то, что в compile-time посчитать можно, в runtime'е получим что-то неэффективное. Хотим, например использовать секретную инструкцию Вашего процессора. Тогда нам надо написать разный compile-time и runtime код.\\
    Поэтому в язык добавили функцию \mintinline{c++}{is_constent_evaluated}. Эта функция вернёт вам \mintinline{c++}{true}, если Вы считаете её во время компиляции, иначе \mintinline{c++}{false}. Но у неё есть две проблемы.
    \begin{enumerate}
        \item Даже если вы уже узнали, что сейчас время компиляции, вы не можете соответствующим образом жить (засунуть, например, нечто странное в параметр шаблона).
        \item Нельзя написать \mintinline{c++}{if constexpr (is_constent_evaluated())}, потому что в таком случае \mintinline{c++}{is_constent_evaluated} всегда вычислится в \mintinline{c++}{true}.
    \end{enumerate}
    Отсюда в C++23 появилась такая штука как \mintinline{c++}{if consteval} и \mintinline{c++}{if !consteval}.
    \paragraph{\mintinline{c++}{variant}.}
    В чём мотивация этого чуда? Когда у нас был \mintinline{c++}{optional}, мотивация была в том, чтобы не раскидывать по коду \mintinline{c++}{bool} и значение. И конкретно мы привели пример класса, который лениво считает значение
    \begin{minted}{c++}
        struct deferred_value
        {
        public:
            int get_value() const
            {
                if (!value)
                    value = compute_value();
                return value;
            }
            
            int compute_value() const;
            
        private:
            mutable std::optional<T> value;
        };
    \end{minted}
    Но обычно мы хотим передавать функцию в конструктор, например:
    \pagebreak
    \begin{minted}{c++}
        struct deferred_value
        {
        public:
            deferred_value(std::function<T ()> compute) : compute(std::move(compute)) {}

            int get_value() const
            {
                if (!value)
                {
                    value = compute();
                    compute = {};
                }
                return *value;
            }
            
        private:
            mutable std::optional<T> value;
            mutable std::function<T ()> compute;
        };
    \end{minted}
    И функцию стоило бы уничтожить после использования, потому что потенциально в \mintinline{c++}{std::function} может быть лишнее место.\\
    Но блин, тут же у нас всегда хранится либо одно, либо другое. Это же \mintinline{c++}{union} и пометка о том, какая альтернатива в данный момент хранится. Иначе говоря \mintinline{c++}{std::variant}:
    \begin{minted}{c++}
        struct deferred_value
        {
        public:
            deferred_value(std::function<T ()> compute) : state(std::move(compute)) {}
            
            int get_value() const
            {
                if (state.index() == 1)
                    state = std::get<std::function<T ()>>(value)();
                return std::get<T>(value);
            }
            
        private:
            std::variant<T, std::function<T ()>> state;
        };
    \end{minted}
    Тут у нас разнесены по времени проверка на индекс и взятие элемента, поэтому у \mintinline{c++}{variant}'а есть ещё \mintinline{c++}{get_if}:
    \begin{minted}{c++}
        struct deferred_value
        {
        public:
            deferred_value(std::function<T ()> compute) : state(std::move(compute)) {}
            
            int get_value() const
            {
                if (std::function<T ()>* compute_ptr = std::get_if<0>(&state))
                   state = (*compute_ptr)();
                return std::get<1>(value);
            }
            
        private:
            std::variant<T, std::function<T ()>> state;
        };
    \end{minted}
    Теперь давайте вот что обсудим. В \mintinline{c++}{optional}'е есть ровно один адекватный вариант создания. В boost'е он был до включения в стандарт и не отличался ничем. А вот с \mintinline{c++}{variant}'ом есть, \textit{барабанная дробь}, варианты! Вон, в boost'е есть \mintinline{c++}{variant} и \mintinline{c++}{variant2}. Они отвечают по-разному на разные вопросы. Например, когда мы присваиваем в \mintinline{c++}{variant} тот тип, что там уже есть, мы должны разрушить тип и пересоздать или использовать \mintinline{c++}{operator=}? В \mintinline{c++}{optinal}'е у нас первое, например. А вот в \mintinline{c++}{variant}'е были сильные споры на эту тему. В той форме, что он в стандарте~--- он использует присваивание.\\
    Второй вопрос: вот мы присваиваем в \mintinline{c++}{variant} не то, что там есть. Если мы разрушим то, что там было, и создадим новое, это непонятная гарантия исключений. Что можно с этим сделать?
    \begin{enumerate}
        \item Добавить в \mintinline{c++}{variant} некорректное состояние (тогда гарантия исключений будет слабая, но лучше, чем ничего). Это довольно неплохо, но людей очень смущает некорректное состояние. Это как \mintinline{c++}{null} в Java. С ним можно жить, но хотелось бы в типах информацию кодировать, а не в контракте писать, что \mintinline{c++}{variant} должен быть не пуст. Ещё базовая гарантия исключений~--- не очень круто, в следующих вариантах бу
        \item Если у того типа, что присваиваем, noexcept-move, то можно это абьюзить, но если нет, то непонятно, как жить. Эта стратегия полностью работает только если мы \textbf{требуем} noexcept-move, но это явно не хорошо. Можно доопределить, что тот, кто бросил~--- сам виноват, и это UB либо \mintinline{c++}{std::terminate}. Требовать noexcept-move-constructible~--- совсем плохо (дебажные коллекции вон выделяют память под контрольный блок при любом конструкторе), а \mintinline{c++}{terminate} или UB не стоит делать там, где мы потенциально можем проверить, что происходит.
        \item Стратегия из \mintinline{c++}{boost::variant}'а (т.е. первой версии). Пусть у нас есть \mintinline{c++}{variant<A, B>}. Давайте введём не некорректное состояние, а добавим возможность хранить не только \mintinline{c++}{A} и \mintinline{c++}{B}, но и \mintinline{c++}{A*} или \mintinline{c++}{B*}. И тогда мы перемещаем \mintinline{c++}{A} у новый указатель, попытаемся присвоить \mintinline{c++}{B}, если у нас не получится, вернёмся в состояние \mintinline{c++}{A}, но на самом деле это будет \mintinline{c++}{A*}. Эта стратегия имеет название: <<heap backup>>. Что тут плохого~--- разве что потенциально ненужная аллокация (исключения должны быть редкими), происходящая всегда.
        \item <<Double buffering>>. То же самое, что и раньше, но копию мы делаем не на куче, а в поля кладём точно такой же \mintinline{c++}{storage}, и копируем в него. Тут понятно, чего плохо~--- вдвое больше памяти используем. Если такой \mintinline{c++}{variant} один, то можно пережить, но если их много, то не надо, пожалуйста.
    \end{enumerate}
    И вот по этому поводу и происходили зарубы, что же из этого выбрать. Конкретно в \mintinline{c++}{std::variant} вделано некорректное состояние. Но там его ещё чуть допилили. Некорректное состояние можно сделать по-разному: можно сказать, что некорректное состояние~--- это полноценное состояние, а можно сказать, что из него работают только ограниченный набор методов. И в стандартной библиотеке пошли вторым путём. Более того, его ещё сильнее спрятали: в конструкторе по умолчанию у нас создаётся первая альтернатива (вместо того, чтобы создавать его в некорректном состоянии). Вообще по этой теме можно посмотреть \href{https://www.youtube.com/watch?v=JUxhwf7gYLg}{видос с CppNow}\\
    Но тут резонный вопрос, а что делать, если мы таки хотим пустое состояние явно и честно? Ну, создаёте пустую структуру и засуньте её в \mintinline{c++}{variant} как альтернативу. Точнее,её создали за вас и назвали \mintinline{c++}{std::monostate}.\\
    Где ещё была заруба~--- это в сравнении. Есть два варианте: можно сравнить сначала по номеру альтернативы, а потом по значению, но тут возникают такие странности:
    \begin{minted}{c++}
        constexpr variant<int, long> a = 10;
        constexpr variant<int, long> b = 5L;
        static_assert(a < b);
    \end{minted}
    Тогда можно попытаться определить \mintinline{c++}{<} для каждых пар типов, что у нас есть, но это $n^2$ кода и должно быть определено сравнение для каждой пары. И как бы ладно с \mintinline{c++}{<}. А вот что с \mintinline{c++}{==}?
    \begin{minted}{c++}
        constexpr variant<int, long> a = 10;
        constexpr variant<int, long> b = 10L;
        static_assert(a != b);
    \end{minted}
    И тут вопрос возникает ещё интереснее, можно ли сделать \mintinline{c++}{veriant<int, int>}?\\
    Так вот, в STL разрешён \mintinline{c++}{variant<int, int>} (мы можем написать шаблонный \mintinline{c++}{variant<mytype, T>}, и так случайно получится, что \mintinline{c++}{T} совпадёт с нашим типом), а \mintinline{c++}{<} и \mintinline{c++}{==} сравнивает сначала по номеру альтернативы, потом по значению. Некорректное состояние считается раньше всех. Оно, кстати, называется \mintinline{c++}{valueless_by_exception}.
    \subparagraph{Best practice.}
    Помните наш
    \begin{minted}{c++}
        struct deferred_value
        {
        public:
            deferred_value(std::function<T ()> compute) : state(std::move(compute)) {}
            
            int get_value() const
            {
                if (std::function<T ()>* compute_ptr = std::get_if<0>(&state))
                    state = (*compute_ptr)();
                return std::get<1>(value);
            }
            
        private:
            std::variant<T, std::function<T ()>> state;
        };
    \end{minted}
    Что у нас в случае \mintinline{c++}{valueless_by_exception}? Ну, всё плохо. Но вообще у нас бывает и другая ситуация: \mintinline{c++}{compute} бросает исключение. И тут тоже вообще логично бы делать некорректное состояние. Поэтому тут можно материализовать некорректное состояние:
    \begin{minted}{c++}
        struct deferred_value
        {
        public:
            deferred_value(std::function<T ()> compute) : state(std::move(compute)) {}
            
            int get_value() const
            {
                if (std::function<T ()>* compute_ptr = std::get_if<0>(&state))
                    try
                    {
                        state = (*compute_ptr)();
                    }
                    catch (...)
                    {
                        state = computation_failed();
                        throw;
                    }

                return std::get<1>(value);
            }
            
        private:
            struct computation_failed {};
            std::variant<T, std::function<T ()>, computation_failed> state;
        };
    \end{minted}
    \subparagraph{Визитеры.}
    Очень хочется pattern-matching в \mintinline{c++}{variant}. Но фиг нам его кто даст, в языке таких фич нет. А писать постоянно проверки на тип и \mintinline{c++}{get} не хочется. Поэтому есть такой паттерн как визитеры.
    \begin{minted}{c++}
        struct visitor
        {
            void operator()(A const&) const { /* ... */ }
            void operator()(B const&) const { /* ... */ }
            void operator()(C const&) const { /* ... */ }
        };

        int main()
        {
            std::variant<A, B, C> v;
            std::visit(visitor(), v);
        }
    \end{minted}
    Но писать свои классы -- очень не хочется. Формально у нас есть лямбды, но их нельзя перегрузить. Может, существует способ как-то их таки использовать? В один тип, например соединить.
    \begin{minted}{c++}
        template <class... Fs>
        struct overload;

        template <class F0, class... Frest>
        struct overload<F0, Frest...> : F0, overload<Frest...>
        {
            overload(F0 f0, Frest ...frest) : F0(fstd::move(f0)), overload<Frest...>(std::move(frest)...) {}

            using F0::operator();
            using overload<Frest...>::operator();
        };

        template <class F0>
        struct overload<F0> : F0
        {
            overload(F0 f0) : F0(fstd::move(f0)) {}
            
            using F0::operator();
        };

        template <class... Fs>
        overload<Fs...> make_overload(Fs&& ...fs)
        {
            return overload<std::decay_t<Fs>...>(std::forward<Fs>(fs)...);
        }
    \end{minted}
    Тут есть очень крупные проблемы с передачей (последний тип переместится N раз), но все мы знаем, как это поправить. Ещё есть проблемы с тем, чтобы передавать указатель на функцию (от него не отнаследоваться), но это тоже поправите сами.
    \section{Концепты.}
    \paragraph{Мотивация.}
    Пусть у нас есть \mintinline{c++}{vector}. Когда мы пишем \mintinline{c++}{template <typename T>}, мы можем в качестве \mintinline{c++}{T} подставить всё, что угодно (ссылки, типы-функции, хоть \mintinline{c++}{void}). Но нам же не любой тип подходит: нам нужно nothrow destructible или ещё какие хорошие свойства у типа (вообще в случае с вектором ограничения не на тип \mintinline{c++}{T}, а на аллокатор~--- второй шаблонный параметр \mintinline{c++}{vector}'а, но не суть). И выразить это ограничение в языке мы никак не могли до C++20.\\
    Ну, хорошо, а зачем? Зачем явно уметь указывать ограничения?\\
    Самый ходовой пример выглядит так: пока у нас программа компилируется, всё хорошо. Но давайте попытаемся подставить в вектор то, что подставить нельзя. Например, нет деструктора. Понятно, что мы увидим ошибку. Но какую? Компилятор скажет, что предпринята попытка ссылки на удалённую функцию (деструктор) и покажет цепочку функций, откуда и кто хочет вызвать этот деструктор. У нас ошибка компиляции где-то глубоко в коде зарыта, да ещё и сообщение не очень содержательное сообщение выводится. В случае \mintinline{c++}{vector<int&>} мы получим сообщение <<невозможно создать указатель на ссылку>>. Если мы подставим \mintinline{c++}{vector<void()>}, то у нас совсем будет что-то несодержательное (arithmetic on pointers to type \mintinline{c++}{void ()}, и совсем непонятно, причём тут это вообще). Причём в разных компиляторах будут разные источники ошибок.\\
    Хочется более адекватных сообщений об ошибках и не где-то, а при подстановке шаблона. Тут нам может помочь \mintinline{c++}{static_assert}, но поможет не везде. Поэтому давайте посмотрим на второй пример:\\
    У \mintinline{c++}{vector}'а есть метод \mintinline{c++}{assign}:
    \begin{minted}{c++}
        void assign(size_t n, T const& value);

        template <typename InputIt>
        void assign(InputIt first, InputIt last);
    \end{minted}
    Тогда мы проиграем, если сделаем
    \begin{minted}{c++}
        vector<int> v;
        v.assign(10, 42);
    \end{minted}
    Почему? Потому что первая перегрузка требует преобразования типов, а вторая~--- нет, там \mintinline{c++}{assign(int, int)}. И мы проиграем во время компиляции. Тут нам не поможет \mintinline{c++}{static_assert}, но поможет SFINAE. То есть тоже в целом решаемо, но тут мы получаем не очень приятный код, да ещё и сложно объяснить новичку, что в этих \mintinline{c++}{enable_if}'ах происходит. К тому же SFINAE сложно понять не только человеку, но и компилятору. Мы в целом абьюзим языковые механизмы, которые изначально не для того сделаны. И в-третьих, у нас в SFINAE очень страшно выглядят ошибки компиляции. Ошибка подстановки \textit{какая-то страшная хрень}: не найдён \mintinline{c++}{type} у \mintinline{c++}{enable_if<}\textit{что-то}\mintinline{c++}{>}. Поэтому компиляторам пришлось специально проверять, что у нас ошибка подстановки не по какой-то причине, а потому что у нас \mintinline{c++}{enable_if}.\\
    И есть ещё проблемы SFINAE. Вспомним \mintinline{c++}{std::advance}. Он по-разному работает для разных типов итераторов, там какой-то tag dispatching или \mintinline{c++}{if constexpr}, и с этом опять же можно жить, но нам надо либо какие-то функции создавать, какие-то свои теги, что-то ещё. Причём в обоих этих решениях мы не можем просто дописать перегрузку к набору. Ровно как и со SFINAE также не можем просто расширить: если у нас какие-то две сущности, что одна обладает всеми свойствами, что вторая, но ещё какими-то, нам придётся явно выражать условие, что тип обладает одним свойством, но не другим.\\
    Как это с обычными перегрузками работает?
    \begin{minted}{c++}
        struct A {};
        struct B : A {};
        struct C : B {};

        void foo(A&);
        void foo(B&);
        void foo(C&);

        int main()
        {
            C c;
            foo(c);
        }
    \end{minted}
    Несмотря на то, что у нас во все три перегрузки \mintinline{c++}{c} подходит, из этих трёх мы можем выбрать наиболее специализированную перегрузку, и всё будет хорошо. Когда мы сделаем структуру \mintinline{c++}{struct D : C {}}, мы можем спокойно написать \mintinline{c++}{void foo(D&)}, и всё будет работать хорошо.\\
    А теперь представьте, что у нас \mintinline{c++}{A}, \mintinline{c++}{B} и \mintinline{c++}{C}~--- это свойства какие-то, а не типы. Тогда, написав что-то подобное, мы проиграем:
    \begin{minted}{c++}
        template <class T>
        std::enable_if<A<T>> foo(T&);
        template <class T>
        std::enable_if<A<T> && B<T>> void foo(T&);
        template <class T>
        std::enable_if<A<T> && B<T> && C<T>> void foo(T&);
    \end{minted}
    Тут мы получим, что у нас в случае \mintinline{c++}{C} всё подходит, поэтому ambiguous. Надо так:
    \begin{minted}{c++}
        template <class T>
        std::enable_if<A<T> && !B<T>> foo(T&);
        template <class T>
        std::enable_if<A<T> && B<T> && !C<T>> void foo(T&);
        template <class T>
        std::enable_if<A<T> && B<T> && C<T>> void foo(T&);
    \end{minted}
    Добавляя новую перегрузку, придётся дописать \mintinline{c++}{&& !D<T>} ко всем уже имеющимся вариантам.\\
    Так вот концепты также умеют в ранжирование компилятором, поэтому с ними нет проблем с расширяемостью.
    \paragraph{Немного истории. Дизайн концептов.}
    Ещё Александр Степанов в описании STL ввёл термин <<концепт>>, и ещё тогда, в девяностых, была идея что-то такое сделать. Но тогда и шаблоны были в новинку, считалось, что это уже очень сложно, и добавлять ещё и концепты было бы очень сложно. Но в целом работа над концептами началась уже тогда, когда началась работа над C++11. У людей был прототип компилятора (concept gcc), эти люди концептуализировали STL, и казалось, что всё это будет уже в C++11, в черновиках стандарта уже были концепты, но прямо перед выпуском C++11 концепты решили удалить из стандарта, потому что не у всех была уверенность в том, что дизайн концептов в том виде, как они есть, вызывал вопросы, насколько он долговечен и хорош.\\
    На какую тему шли дискусии?
    \begin{enumerate}
        \item Разница между explicit и implicit концептами.\\
        Пусть у нас есть класс \mintinline{c++}{my_type}, у которого написан \mintinline{c++}{<}. Чтобы наш тип удовлетворял концепту comparable, этого достаточно, или надо как в Java написать \mintinline{java}{implements Comparable<T>}? Аргументы есть и за и против. За explicit~--- не факт, что одинаковые названия операций значат одинаковый смысл. В изначальной реализации были и те, и другие концепты, большая часть была явной, но с течением времени разные люди приходили, говорили, что для данного концепта явность~--- плохо, есть совершенно тупой пример, который не работает, и со временем всё больше и больше интерфейсов становились неявными. Те концепты, которые вошли в C++20, они уже совершенно неявные. Впрочем, если нам надо, чтобы какой-то концепт был явным, заведите рядом с ним trait. А вообще в жизни это бывает нужно довольно редко. В STL это только итераторы и диапазоны. В первом есть \mintinline{c++}{iterator_traits}, во втором~--- есть шаблонная переменная \mintinline{c++}{enable_borrowed_range}.
        \item Definition checking.\\
        \begin{minted}{c++}
            void advance(std::input_iterator auto& iter, std::integral auto distance)
            {
                // ...
            }
        \end{minted}
        Тут можно двояко понимать то, что написано. Либо мы обязуемся использовать только то, что написано в \mintinline{c++}{std::input_iterator}, либо нет. Когда компилятор проверяет это, это называется definition checking. В изначальном proposal'е definition checking был (ну, потому что хочется иметь его; почему шаблоны порождают такие длинные сообщения об ошибке? потому что компилятор не знает, где ошибка, и выдаёт все возможные места). Но с concept gcc была проблема: он существенно замедлял компиляцию программы. Это вызывало беспокойство. Авторы утверждали, что это проблема их реализации, а не самой идеи, но прототипа, который работал хорошо, у них не было.\\
        Второй момент~--- давайте попытаемся залогировать то, что приходит в качестве параметра. Но у нас же definition checking, с чего бы наши типы умели выводиться? Сейчас мы бы просто занесли это под какой-нибудь \mintinline{c++}{if constexpr}, но тогда подобного не было.\\
        И в-третих, возникают тонкости со взаимодействием с обычными шаблонами: они же не проверяют ничего. И это ладно, а если вы из концептуального мира вызываете что-то, что делает tag dispatching.
        \item Как концептуализирована стандартная библиотека. Мы для \mintinline{c++}{set} требуем, чтобы типы нуждались в \mintinline{c++}{<}. И когда это концептуализируем, можно требовать либо только \mintinline{c++}{<}, либо все операции. Если требовать все, то сломается куча кода. Поэтому концепты типа \mintinline{c++}{ordered} начали дробиться на более гранулярные: типа нам хватит только сравнения на меньше. Или вот у нас есть \mintinline{c++}{std::advance}: может, нам там не нужен именно итератор, а хватит только инкремента. И тогда теряется смысл у каждого конкретного концепта: если раньше мы знали, что итератор~--- это понятная сущность, то теперь нет. И суммарно для стандартной библиотеки понадобилось 100 концептов.
    \end{enumerate}
    В итоге люди отбросили идею концептов из C++11 и решили разработать что-то, что будет не настолько хорошим, но работающим.\\
    И в итоге уже к C++17 концепты были по сути готовы, но у людей были беспокойства на тему, насколько всё продумано. А ещё в STL никакие концепты не добавлялись, что вызывало у людей озабоченность. А ещё в C++17 есть proposal по \mintinline{c++}{auto}, и он там немножко конфликтует с proposal'ом по концептам (была конструкция, что читалась двояко). И ещё были люди, которые сомневались, что можно будет потом допилить definition checking.\\
    И вот в C++20 всё (кроме definition checking'а) порешали, и теперь концепты у нас есть.
    \paragraph{Синтаксис.}
    Концепты можно писать так:
    \begin{minted}{c++}
        template <typename T>
        concept destructible = std::is_nothrow_destructible_v<T>;
    \end{minted}
    Несложно заметить, что концепты очень похожи на \mintinline{c++}{bool}'евые предикаты от своих параметров, но на самом деле они не то что похожи, их можно даже с такой целью использовать.\\
    Самая общая форма использования концептов выглядит как
    \begin{minted}{c++}
        template <class T>
        requires destructible<T>
        void foo(T&) { /* ... */ }
    \end{minted}
    Ещё есть сокращённая форма
    \begin{minted}{c++}
        template <destructible T>
        void foo(T&) { /* ... */ }
    \end{minted}
    Или даже так:
    \begin{minted}{c++}
        void foo(destructible auto&) { /* ... */ }
    \end{minted}
    С последней формой всё понятно, всё как с \mintinline{c++}{auto}, а вот со вторым уже интереснее. У нас вроде был параметр концепта, а тут мы просто написали \mintinline{c++}{destructible}. Как быть, если у нас, например, несколько параметров у концепта? Ну, вот так:
    \begin{minted}{c++}
        template <class T>
        requires same_as<T, my_type>
        void foo(T&) { /* ... */ }

        template <same_as<my_type> T>
        void foo(T&) { /* ... */ }
    \end{minted}
    Ещё можно писать вот такие вещи:
    \begin{minted}{c++}
        template <class T>
        concept ordered = requires (T x)
        {
            {x < x} -> std::same_as<bool>;
            // В жизни не надо проверять наличие только меньше, проверьте наличие всего.
        };
    \end{minted}
    То есть это говорит нам о том, что сравнение двух \mintinline{c++}{T} работает и возвращает \mintinline{c++}{bool}.\\
    Вообще в \mintinline{c++}{requires} можно писать 4 разных штуки:
    \begin{minted}{c++}
        template <class T>
        concept something = requires (T x)
        {
            // simple
            x.foo(); // В x есть функция foo без параметров.

            // type
            typename T::value_type; // В T есть тип value_type.

            // compound
            {x < x} noexcept -> std::same_as<bool>;
            // Выражение компилируется и результат удовлетворяет концепту. И noexcept ещё.
            // noexcept и результирующий концепт можно не писать, если не надо.

            // nested
            requires destructible<T>; // Выпослнены какие-то ещё концепты.
        }
    \end{minted}
    Компилятор про концепты знает чуть больше, чем про обычные \mintinline{c++}{constexpr bool}-переменные. Он знает, когда один концепт более специализирован, нежели другой. Как это работает?
    \begin{minted}{c++}
        template <typename T>
        concept destructible = std::is_nothrow_destructible_v<T>;
        
        template <typename T>
        concept ordered = destructible<T> && requires (T x)
        {
            {x < x} -> std::same_as<bool>;
        }
    \end{minted}
    Как понять, что одно~--- подмножество другого? На самом деле по произвольному предикату понять, что одно влечёт другое, нельзя. Поэтому в C++ определено нечто более простое. Точно не будет работать такое:
    \begin{minted}{c++}
        template <size_t N>
        requires (N > 5)
        void foo(std::array<int, N>&);

        template <size_t N>
        requires (N > 7)
        void foo(std::array<int, N>&);
    \end{minted}
    Компилятор считает эти штуки одинаковыми.\\
    Компилятор строит нормальную форму: он берёт \mintinline{c++}{&&}, \mintinline{c++}{||} и концепты, раскрывает все их, а всё остальное считает atomic constraint (т.е. их он не сравнивает). И дальше когда компилятору надо сравнить, верно ли, что чисто по атомарным constraint'ам из одного следует другое. Например, \mintinline{c++}{std::random_access_iterator} просто начинается с \mintinline{c++}{std::bidirectional_iterator<T> &&}, и поэтому он более специализирован, нежели \mintinline{c++}{std::bidirectional_iterator}. Что важно понимать~--- \mintinline{c++}{requires}-expression считается атомарным constraint'ом. Не конъюнкцией.\\
    Этот механизм приводи к интересным спецэффектам:
    \begin{minted}{c++}
        template <typename T>
        requires destructible<T>
        void foo(T&) {}

        template <typename T>
        requires destructible<T> && true
        void foo(T&) {}
    \end{minted}
    Нижняя функция более специализирована, нежели верхняя.\\
    И такое~--- ещё половина беды.
    \begin{minted}{c++}
        template <typename T>
        requires destructible<T> && true
        void foo(T&) {}
        
        template <typename T>
        requires ordered<T> && true
        void foo(T&) {}
    \end{minted}
    Не компилируется, потому что \mintinline{c++}{true} здесь~--- два разных atomic constraint'а, которые никак не связаны.\\
    Но вообще концепты очень сильно помогают в жизни. Желающие посмотреть что-нибудь по теме могут посмотреть \href{youtube.com/watch?v=vYzjV0xSqJE}{презентацию Андрея Давыдова}.
    \section{Кодировки.}
    В основном мы, конечно, поговорим про Unicode. Юникод~--- это стандарт, ставящий числу в соответствие символ. Числа при этом называются codepoint'ами, и текст по сути представляется последовательностью codepoint'ов. Сами числа при этом лежат в диапазоне от \mintinline{c++}{0} до \mintinline{c++}{0x10FFFF}. Очень весёлый диапазон.\\
    Рядом с Юникодом лежат кодировки, ассоциированные с ним: \Verb|UTF-8|, \Verb|UTF-16| (+ \Verb|UCS2|) и \Verb|UTF-32|. При этом последние два также могут быть little- или big-endian. \Verb|UTF-8| состоит из 8-битных чисел, \Verb|UTF-16| и \Verb|USC2|~--- 16-битных, \Verb|UTF-32|~--- 32-битных. Эти самые числа называются code unit'ами. Кодировки эти занимаются тем, что определяют, как преобразовать code point в code unit.
    \paragraph{Кодировки.}
    \subparagraph{UTF-32.}
    \Verb|UTF-32| делает всё очень просто: каждый code point является одним code unit'ом. У этого есть существенный недостаток: 4 байта~--- безмерно много. Особенно учитывая тот факт, что символы из расширенных плоскостей (то, что вне \mintinline{c++}{0}--\mintinline{c++}{0xFFFF}) встречается довольно редко.
    \subparagraph{UCS2.}
    \Verb|UCS2| не поддерживает расширенные плоскости. Совсем. Если вы хотите закодировать code point до \mintinline{c++}{0xFFFF}, вы просто записываете code unit с этим числовым значением, а если code point выше, то вы проиграли. Поэтому \Verb|UCS2| не может закодировать всё, не используется, и вместо него применяется \Verb|UTF-16|.
    \subparagraph{UTF-16.}
    В Unicode есть мем. Коды в интервале \mintinline{c++}{0xD800}--\mintinline{c++}{0xDFFF} некорректны. Поэтому эти коды используется для \Verb|UTF-16|. И вот как он работает: если code point помещается в 2 байта, он пишется as is. Если нет, то из него вычитается \mintinline{c++}{0x10000}, и получается 10 бит. Эти самые 10 бит кодируются парой code unit'ов: первый получается сложением \mintinline{c++}{0xD800} и старших 5 бит, второй~--- сложением \mintinline{c++}{DC00} и младших 5 бит. Итого базовая плоскости кодируется 2 байтами, а дополнительные~--- парой из двухбайтовых слов. Такая пара называется \textbf{суррогатной парой}.
    \subparagraph{UTF-8.}
    Традиционно программы использовали 8-битные кодировки. И не хочется жить с \Verb|UTF-16|. А представлять Юникод хочется. и придумали вот что.\\
    Если у вас code point лежит в диапазоне ASCII (\mintinline{c++}{0}--\mintinline{c++}{0x7F}), то его пишут как \Verb|0xxxxxxx|. Если от \mintinline{c++}{0x80} до \mintinline{c++}{0x07FF}, то \Verb|110xxxxx_10xxxxxx|, если от \mintinline{c++}{0x8000} до \mintinline{c++}{0xFFFF}, то \Verb|1110xxxx_10xxxxxx_10xxxxxx|, иначе \Verb|1110xxxx_10xxxxxx_10xxxxxx_10xxxxxx|.\\
    Code unit'ы в UTF-8 называют октетами, и каждый октет, как видно из описания, может быть trailing (\Verb|10xxxxxx|) и leading~--- всё остальное.\\
    Но подождите. Значит ли то, что написано выше, что мы можем закодировать один символ разными способами? Ведь \Verb|11000000_10000000|~--- это вроде как \mintinline{c++}{'\0'}. Так вот нет. Это называется overload sequences, и кодировщики UTF-8 не должны их создавать, а декодировщики должны считать это некорректным.\\
    Кстати, интересный факт. \Verb|UTF-8|-строки можно лексикографически сравнивать пооктетно и получится, что у нас нормально отсортированы строки и с точки зрения code point'ов. В \Verb|UTF-16| это не верно.
    \subparagraph{Byte-order mark.}
    Он же <<неразрывный пробел нулевой ширины>>. Это специальный codepoint, который вставляется в начало файлов для того, чтобы можно было определить, \Verb|UTF-8| у вас, \Verb|UTF-16LE| или \Verb|UTF-16BE|.
    \paragraph{Задачи, которые сложно решать в Unicode'е.}
    \subparagraph{Длина и обращение по индексу.}
    Казалось бы, в \Verb|UTF-32| можно обращаться по индексу за $O(1)$. Но всё было бы хорошо, если бы не сам стандарт Unicode. Посмотрим на вот такую букву: \r{A}. Есть специальная буква: <<LATIN CAPITAL A WITH RING ABOVE>>, \Verb|00C5|. Это один code point, и всё хорошо. Но есть обычная буква A и отдельно символ <<COMBINING RING ABOVE>>. При их совмещении получается тот же самый глиф, но это два code point'а: \Verb|0041_030A|. А ещё есть знак ангстрема, и это тоже отдельный символ с codepoint'ом \Verb|212B|.\\
    А есть ещё корейский алфавит <<Хангыль>>, где буквы пишутся где попало.
    \begin{figure}[H]
        \begin{tikzpicture}[scale=.75]
            \path(0pt,0pt);
            \filldraw[black][nonzero rule]
            (60.75001pt, -314.275pt) .. controls (57.9615pt, -312.9324pt) and (53.21085pt, -311.1768pt) .. (46.29167pt, -309.2145pt)
            -- (46.29167pt, -309.2145pt)
            -- (46.29167pt, -309.2145pt)
            -- (46.29167pt, -309.2145pt) .. controls (42.67701pt, -308.1818pt) and (41.12784pt, -307.0457pt) .. (41.54092pt, -305.9097pt)
            -- (41.54092pt, -305.9097pt)
            -- (41.54092pt, -305.9097pt)
            -- (41.54092pt, -305.9097pt) .. controls (41.7475pt, -304.3605pt) and (44.536pt, -303.1213pt) .. (49.803pt, -302.295pt)
            -- (49.803pt, -302.295pt)
            -- (49.803pt, -302.295pt)
            -- (49.803pt, -302.295pt) .. controls (55.17342pt, -302.295pt) and (60.64717pt, -302.5016pt) .. (66.01717pt, -302.8114pt)
            -- (66.01717pt, -302.8114pt)
            -- (66.01717pt, -302.8114pt)
            -- (66.01717pt, -302.8114pt) .. controls (70.56126pt, -303.1212pt) and (74.27926pt, -303.6376pt) .. (77.068pt, -304.154pt)
            -- (77.068pt, -304.154pt)
            -- (77.068pt, -304.154pt)
            -- (77.068pt, -304.154pt) .. controls (80.063pt, -304.7737pt) and (81.71542pt, -305.9097pt) .. (82.33508pt, -307.2523pt)
            -- (82.33508pt, -307.2523pt)
            -- (82.33508pt, -307.2523pt)
            -- (82.33508pt, -307.2523pt) .. controls (82.8515pt, -308.1818pt) and (82.8515pt, -309.8342pt) .. (82.33508pt, -312.0029pt)
            -- (82.33508pt, -312.0029pt)
            -- (82.12849pt, -315.7208pt)
            -- (82.12849pt, -315.7208pt)
            -- (82.33508pt, -347.53pt)
            -- (82.33508pt, -347.53pt)
            -- (82.33508pt, -347.53pt)
            -- (82.33508pt, -347.53pt) .. controls (82.33508pt, -350.525pt) and (83.36783pt, -352.4872pt) .. (85.22684pt, -353.8298pt)
            -- (85.22684pt, -353.8298pt)
            -- (85.22684pt, -353.8298pt)
            -- (85.22684pt, -353.8298pt) .. controls (87.08575pt, -355.0692pt) and (90.28734pt, -355.7921pt) .. (94.83183pt, -356.1019pt)
            -- (94.83183pt, -356.1019pt)
            -- (141.926pt, -355.5855pt)
            -- (141.926pt, -355.5855pt) .. controls (145.5407pt, -355.2757pt) and (148.639pt, -354.5528pt) .. (151.0143pt, -353.8299pt)
            -- (151.0143pt, -353.8299pt)
            -- (151.0143pt, -353.8299pt)
            -- (151.0143pt, -353.8299pt) .. controls (152.5635pt, -353.5201pt) and (154.2159pt, -352.7971pt) .. (155.765pt, -351.7644pt)
            -- (155.765pt, -351.7644pt)
            -- (155.765pt, -351.7644pt)
            -- (155.765pt, -351.7644pt) .. controls (158.3469pt, -350.2152pt) and (160.619pt, -349.1824pt) .. (162.8911pt, -348.8726pt)
            -- (162.8911pt, -348.8726pt)
            -- (162.8911pt, -348.8726pt)
            -- (162.8911pt, -348.8726pt) .. controls (166.7123pt, -347.9431pt) and (172.7028pt, -347.7366pt) .. (180.6544pt, -348.0464pt)
            -- (180.6544pt, -348.0464pt)
            -- (180.6544pt, -348.0464pt)
            -- (180.6544pt, -348.0464pt) .. controls (184.4756pt, -348.253pt) and (187.7805pt, -349.0792pt) .. (190.2594pt, -350.6284pt)
            -- (190.2594pt, -350.6284pt)
            -- (190.2594pt, -350.6284pt)
            -- (190.2594pt, -350.6284pt) .. controls (192.4282pt, -351.9709pt) and (193.8741pt, -353.7266pt) .. (194.2872pt, -355.6888pt)
            -- (194.2872pt, -355.6888pt)
            -- (194.2872pt, -355.6888pt)
            -- (194.2872pt, -355.6888pt) .. controls (194.597pt, -357.4445pt) and (194.1839pt, -358.8904pt) .. (192.9446pt, -360.1297pt)
            -- (192.9446pt, -360.1297pt)
            -- (192.9446pt, -360.1297pt)
            -- (192.9446pt, -360.1297pt) .. controls (191.602pt, -361.4722pt) and (189.6398pt, -362.1952pt) .. (187.3677pt, -362.2985pt)
            -- (187.3677pt, -362.2985pt)
            -- (187.3677pt, -362.2985pt)
            -- (187.3677pt, -362.2985pt)
            -- (94.20934pt, -362.2985pt)
            -- (94.20934pt, -362.2985pt)
            -- (94.20934pt, -362.2985pt)
            -- (94.20934pt, -362.2985pt) .. controls (84.91434pt, -362.0919pt) and (78.20184pt, -360.7493pt) .. (74.07018pt, -358.2708pt)
            -- (74.07018pt, -358.2708pt)
            -- (74.07018pt, -358.2708pt)
            -- (74.07018pt, -358.2708pt) .. controls (69.31951pt, -355.5856pt) and (66.84084pt, -351.1447pt) .. (66.53101pt, -345.1549pt)
            -- (66.53101pt, -345.1549pt)
            -- (65.60152pt, -319.9557pt)
            -- (65.60152pt, -319.9557pt) .. controls (65.60152pt, -317.8903pt) and (63.9491pt, -315.8248pt) .. (60.7476pt, -314.2756pt) -- cycle
            ;
            \draw[white,line width=1.111111pt]
            (60.75001pt, -314.275pt) .. controls (57.9615pt, -312.9324pt) and (53.21085pt, -311.1768pt) .. (46.29167pt, -309.2145pt)
            -- (46.29167pt, -309.2145pt)
            -- (46.29167pt, -309.2145pt)
            -- (46.29167pt, -309.2145pt) .. controls (42.67701pt, -308.1818pt) and (41.12784pt, -307.0457pt) .. (41.54092pt, -305.9097pt)
            -- (41.54092pt, -305.9097pt)
            -- (41.54092pt, -305.9097pt)
            -- (41.54092pt, -305.9097pt) .. controls (41.7475pt, -304.3605pt) and (44.536pt, -303.1213pt) .. (49.803pt, -302.295pt)
            -- (49.803pt, -302.295pt)
            -- (49.803pt, -302.295pt)
            -- (49.803pt, -302.295pt) .. controls (55.17342pt, -302.295pt) and (60.64717pt, -302.5016pt) .. (66.01717pt, -302.8114pt)
            -- (66.01717pt, -302.8114pt)
            -- (66.01717pt, -302.8114pt)
            -- (66.01717pt, -302.8114pt) .. controls (70.56126pt, -303.1212pt) and (74.27926pt, -303.6376pt) .. (77.068pt, -304.154pt)
            -- (77.068pt, -304.154pt)
            -- (77.068pt, -304.154pt)
            -- (77.068pt, -304.154pt) .. controls (80.063pt, -304.7737pt) and (81.71542pt, -305.9097pt) .. (82.33508pt, -307.2523pt)
            -- (82.33508pt, -307.2523pt)
            -- (82.33508pt, -307.2523pt)
            -- (82.33508pt, -307.2523pt) .. controls (82.8515pt, -308.1818pt) and (82.8515pt, -309.8342pt) .. (82.33508pt, -312.0029pt)
            -- (82.33508pt, -312.0029pt)
            -- (82.12849pt, -315.7208pt)
            -- (82.12849pt, -315.7208pt)
            -- (82.33508pt, -347.53pt)
            -- (82.33508pt, -347.53pt)
            -- (82.33508pt, -347.53pt)
            -- (82.33508pt, -347.53pt) .. controls (82.33508pt, -350.525pt) and (83.36783pt, -352.4872pt) .. (85.22684pt, -353.8298pt)
            -- (85.22684pt, -353.8298pt)
            -- (85.22684pt, -353.8298pt)
            -- (85.22684pt, -353.8298pt) .. controls (87.08575pt, -355.0692pt) and (90.28734pt, -355.7921pt) .. (94.83183pt, -356.1019pt)
            -- (94.83183pt, -356.1019pt)
            -- (141.926pt, -355.5855pt)
            -- (141.926pt, -355.5855pt) .. controls (145.5407pt, -355.2757pt) and (148.639pt, -354.5528pt) .. (151.0143pt, -353.8299pt)
            -- (151.0143pt, -353.8299pt)
            -- (151.0143pt, -353.8299pt)
            -- (151.0143pt, -353.8299pt) .. controls (152.5635pt, -353.5201pt) and (154.2159pt, -352.7971pt) .. (155.765pt, -351.7644pt)
            -- (155.765pt, -351.7644pt)
            -- (155.765pt, -351.7644pt)
            -- (155.765pt, -351.7644pt) .. controls (158.3469pt, -350.2152pt) and (160.619pt, -349.1824pt) .. (162.8911pt, -348.8726pt)
            -- (162.8911pt, -348.8726pt)
            -- (162.8911pt, -348.8726pt)
            -- (162.8911pt, -348.8726pt) .. controls (166.7123pt, -347.9431pt) and (172.7028pt, -347.7366pt) .. (180.6544pt, -348.0464pt)
            -- (180.6544pt, -348.0464pt)
            -- (180.6544pt, -348.0464pt)
            -- (180.6544pt, -348.0464pt) .. controls (184.4756pt, -348.253pt) and (187.7805pt, -349.0792pt) .. (190.2594pt, -350.6284pt)
            -- (190.2594pt, -350.6284pt)
            -- (190.2594pt, -350.6284pt)
            -- (190.2594pt, -350.6284pt) .. controls (192.4282pt, -351.9709pt) and (193.8741pt, -353.7266pt) .. (194.2872pt, -355.6888pt)
            -- (194.2872pt, -355.6888pt)
            -- (194.2872pt, -355.6888pt)
            -- (194.2872pt, -355.6888pt) .. controls (194.597pt, -357.4445pt) and (194.1839pt, -358.8904pt) .. (192.9446pt, -360.1297pt)
            -- (192.9446pt, -360.1297pt)
            -- (192.9446pt, -360.1297pt)
            -- (192.9446pt, -360.1297pt) .. controls (191.602pt, -361.4722pt) and (189.6398pt, -362.1952pt) .. (187.3677pt, -362.2985pt)
            -- (187.3677pt, -362.2985pt)
            -- (187.3677pt, -362.2985pt)
            -- (187.3677pt, -362.2985pt)
            -- (94.20934pt, -362.2985pt)
            -- (94.20934pt, -362.2985pt)
            -- (94.20934pt, -362.2985pt)
            -- (94.20934pt, -362.2985pt) .. controls (84.91434pt, -362.0919pt) and (78.20184pt, -360.7493pt) .. (74.07018pt, -358.2708pt)
            -- (74.07018pt, -358.2708pt)
            -- (74.07018pt, -358.2708pt)
            -- (74.07018pt, -358.2708pt) .. controls (69.31951pt, -355.5856pt) and (66.84084pt, -351.1447pt) .. (66.53101pt, -345.1549pt)
            -- (66.53101pt, -345.1549pt)
            -- (65.60152pt, -319.9557pt)
            -- (65.60152pt, -319.9557pt) .. controls (65.60152pt, -317.8903pt) and (63.9491pt, -315.8248pt) .. (60.7476pt, -314.2756pt) -- cycle
            ;
            \filldraw[black][nonzero rule]
            (314.75pt, -279.1584pt) .. controls (313.7172pt, -279.4682pt) and (312.5812pt, -279.778pt) .. (311.1354pt, -280.1911pt)
            -- (311.1354pt, -280.1911pt)
            -- (311.1354pt, -280.1911pt)
            -- (311.1354pt, -280.1911pt) .. controls (308.3469pt, -281.2239pt) and (306.0748pt, -281.5337pt) .. (304.0093pt, -281.2239pt)
            -- (304.0093pt, -281.2239pt)
            -- (304.0093pt, -281.2239pt)
            -- (304.0093pt, -281.2239pt) .. controls (301.0143pt, -280.7075pt) and (296.2636pt, -278.7452pt) .. (289.3443pt, -275.647pt)
            -- (289.3443pt, -275.647pt)
            -- (289.3443pt, -275.647pt)
            -- (289.3443pt, -275.647pt) .. controls (284.4903pt, -272.8585pt) and (281.9084pt, -270.8963pt) .. (281.8051pt, -269.5536pt)
            -- (281.8051pt, -269.5536pt)
            -- (281.8051pt, -269.5536pt)
            -- (281.8051pt, -269.5536pt) .. controls (281.4953pt, -268.2111pt) and (283.1477pt, -267.798pt) .. (286.5558pt, -268.5209pt)
            -- (286.5558pt, -268.5209pt)
            -- (286.5558pt, -268.5209pt)
            -- (286.5558pt, -268.5209pt) .. controls (298.1225pt, -270.0701pt) and (315.2666pt, -270.6897pt) .. (338.0908pt, -270.5864pt)
            -- (338.0908pt, -270.5864pt)
            -- (338.0908pt, -270.5864pt)
            -- (338.0908pt, -270.5864pt) .. controls (359.2625pt, -270.3798pt) and (379.0916pt, -269.5536pt) .. (397.6808pt, -268.3143pt)
            -- (397.6808pt, -268.3143pt)
            -- (397.6808pt, -268.3143pt)
            -- (397.6808pt, -268.3143pt) .. controls (398.7136pt, -268.1077pt) and (399.7463pt, -267.9012pt) .. (400.7791pt, -267.5914pt)
            -- (400.7791pt, -267.5914pt)
            -- (400.7791pt, -267.5914pt)
            -- (400.7791pt, -267.5914pt) .. controls (401.2955pt, -267.5914pt) and (402.0184pt, -267.3848pt) .. (402.8446pt, -267.075pt)
            -- (402.8446pt, -267.075pt)
            -- (402.8446pt, -267.075pt)
            -- (402.8446pt, -267.075pt) .. controls (403.8773pt, -266.7651pt) and (404.9101pt, -266.5586pt) .. (405.9428pt, -266.2487pt)
            -- (405.9428pt, -266.2487pt)
            -- (405.9428pt, -266.2487pt)
            -- (405.9428pt, -266.2487pt) .. controls (407.492pt, -266.0422pt) and (409.6607pt, -266.1455pt) .. (412.6557pt, -266.4553pt)
            -- (412.6557pt, -266.4553pt)
            -- (412.6557pt, -266.4553pt)
            -- (412.6557pt, -266.4553pt) .. controls (419.3687pt, -266.7651pt) and (423.3965pt, -267.6946pt) .. (424.5324pt, -269.0372pt)
            -- (424.5324pt, -269.0372pt)
            -- (424.5324pt, -269.0372pt)
            -- (424.5324pt, -269.0372pt) .. controls (425.0488pt, -270.07pt) and (424.4291pt, -271.8257pt) .. (422.7767pt, -274.0977pt)
            -- (422.7767pt, -274.0977pt)
            -- (421.021pt, -277.4026pt)
            -- (421.021pt, -277.4026pt)
            -- (412.7589pt, -305.7001pt)
            -- (412.7589pt, -305.7001pt)
            -- (412.7589pt, -305.7001pt)
            -- (412.7589pt, -305.7001pt) .. controls (419.885pt, -306.7328pt) and (423.7065pt, -308.5918pt) .. (424.119pt, -310.9672pt)
            -- (424.119pt, -310.9672pt)
            -- (424.119pt, -310.9672pt)
            -- (424.119pt, -310.9672pt) .. controls (424.4288pt, -313.9622pt) and (421.4338pt, -315.3047pt) .. (415.2373pt, -315.3047pt)
            -- (415.2373pt, -315.3047pt)
            -- (319.5039pt, -316.4407pt)
            -- (319.5039pt, -316.4407pt)
            -- (317.4384pt, -317.7833pt)
            -- (317.4384pt, -317.7833pt)
            -- (317.4384pt, -317.7833pt)
            -- (317.4384pt, -317.7833pt) .. controls (316.8188pt, -318.0931pt) and (316.3024pt, -318.403pt) .. (316.0959pt, -318.8161pt)
            -- (316.0959pt, -318.8161pt)
            -- (316.0959pt, -318.8161pt)
            -- (316.0959pt, -318.8161pt) .. controls (315.786pt, -319.1259pt) and (315.5794pt, -319.6423pt) .. (315.5794pt, -320.1587pt)
            -- (315.5794pt, -320.1587pt)
            -- (315.786pt, -344.4286pt)
            -- (315.786pt, -344.4286pt) .. controls (315.786pt, -346.5975pt) and (316.3023pt, -348.1466pt) .. (317.5417pt, -349.1793pt)
            -- (317.5417pt, -349.1793pt)
            -- (317.5417pt, -349.1793pt)
            -- (317.5417pt, -349.1793pt) .. controls (318.781pt, -350.1088pt) and (320.9498pt, -350.5219pt) .. (324.1514pt, -350.5219pt)
            -- (324.1514pt, -350.5219pt)
            -- (324.1514pt, -350.5219pt)
            -- (324.1514pt, -350.5219pt)
            -- (391.7972pt, -350.5219pt)
            -- (391.7972pt, -350.5219pt)
            -- (391.7972pt, -350.5219pt)
            -- (391.7972pt, -350.5219pt) .. controls (395.2053pt, -350.2121pt) and (397.9938pt, -349.5924pt) .. (400.0593pt, -348.9727pt)
            -- (400.0593pt, -348.9727pt)
            -- (400.0593pt, -348.9727pt)
            -- (400.0593pt, -348.9727pt) .. controls (401.4019pt, -348.6629pt) and (403.0543pt, -347.8367pt) .. (404.81pt, -346.7007pt)
            -- (404.81pt, -346.7007pt)
            -- (404.81pt, -346.7007pt)
            -- (404.81pt, -346.7007pt) .. controls (406.9788pt, -345.4613pt) and (409.1476pt, -344.7384pt) .. (411.1098pt, -344.3253pt)
            -- (411.1098pt, -344.3253pt)
            -- (411.1098pt, -344.3253pt)
            -- (411.1098pt, -344.3253pt) .. controls (414.2081pt, -343.7057pt) and (418.4424pt, -343.3958pt) .. (424.019pt, -343.809pt)
            -- (424.019pt, -343.809pt)
            -- (424.019pt, -343.809pt)
            -- (424.019pt, -343.809pt) .. controls (428.7697pt, -344.1188pt) and (432.4873pt, -345.0483pt) .. (435.379pt, -346.3909pt)
            -- (435.379pt, -346.3909pt)
            -- (435.379pt, -346.3909pt)
            -- (435.379pt, -346.3909pt) .. controls (438.1674pt, -347.7335pt) and (439.6133pt, -349.3859pt) .. (439.9232pt, -350.9351pt)
            -- (439.9232pt, -350.9351pt)
            -- (439.9232pt, -350.9351pt)
            -- (439.9232pt, -350.9351pt) .. controls (440.4395pt, -352.6907pt) and (439.9232pt, -354.0333pt) .. (438.374pt, -354.9628pt)
            -- (438.374pt, -354.9628pt)
            -- (438.374pt, -354.9628pt)
            -- (438.374pt, -354.9628pt) .. controls (436.6183pt, -356.512pt) and (434.5528pt, -357.3381pt) .. (431.7643pt, -357.3381pt)
            -- (431.7643pt, -357.3381pt)
            -- (431.7643pt, -357.3381pt)
            -- (431.7643pt, -357.3381pt)
            -- (321.5726pt, -357.3381pt)
            -- (321.5726pt, -357.3381pt)
            -- (321.5726pt, -357.3381pt)
            -- (321.5726pt, -357.3381pt) .. controls (314.8597pt, -357.3381pt) and (309.4893pt, -356.0988pt) .. (305.5651pt, -353.7234pt)
            -- (305.5651pt, -353.7234pt)
            -- (305.5651pt, -353.7234pt)
            -- (305.5651pt, -353.7234pt) .. controls (301.7439pt, -351.1415pt) and (299.6784pt, -347.5269pt) .. (299.6784pt, -342.7759pt)
            -- (299.6784pt, -342.7759pt)
            -- (299.6784pt, -342.7759pt)
            -- (299.6784pt, -342.7759pt)
            -- (299.6784pt, -319.8484pt)
            -- (299.6784pt, -319.8484pt)
            -- (299.6784pt, -319.8484pt)
            -- (299.6784pt, -319.8484pt) .. controls (299.162pt, -318.2993pt) and (297.0965pt, -316.6469pt) .. (293.7917pt, -315.0978pt)
            -- (293.7917pt, -315.0978pt)
            -- (293.7917pt, -315.0978pt)
            -- (293.7917pt, -315.0978pt) .. controls (291.2097pt, -313.5486pt) and (288.4213pt, -312.3093pt) .. (285.1167pt, -311.4831pt)
            -- (285.1167pt, -311.4831pt)
            -- (285.1167pt, -311.4831pt)
            -- (285.1167pt, -311.4831pt) .. controls (281.8118pt, -310.2438pt) and (280.0561pt, -309.3143pt) .. (279.5397pt, -308.3849pt)
            -- (279.5397pt, -308.3849pt)
            -- (279.5397pt, -308.3849pt)
            -- (279.5397pt, -308.3849pt) .. controls (279.2299pt, -307.1455pt) and (281.7085pt, -306.3193pt) .. (286.8723pt, -305.8029pt)
            -- (286.8723pt, -305.8029pt)
            -- (286.8723pt, -305.8029pt)
            -- (286.8723pt, -305.8029pt) .. controls (294.1017pt, -306.0095pt) and (301.0215pt, -306.7324pt) .. (307.424pt, -307.7652pt)
            -- (307.424pt, -307.7652pt)
            -- (307.424pt, -307.7652pt)
            -- (307.424pt, -307.7652pt) .. controls (313.2075pt, -308.6947pt) and (316.9257pt, -309.5208pt) .. (318.784pt, -310.5536pt)
            -- (318.784pt, -310.5536pt)
            -- (384.1573pt, -309.2111pt)
            -- (384.1573pt, -309.2111pt) .. controls (386.6359pt, -309.0045pt) and (388.5982pt, -308.798pt) .. (390.5604pt, -308.4882pt)
            -- (390.5604pt, -308.4882pt)
            -- (390.5604pt, -308.4882pt)
            -- (390.5604pt, -308.4882pt) .. controls (392.1096pt, -308.2816pt) and (393.9685pt, -307.9718pt) .. (396.1373pt, -307.4554pt)
            -- (396.1373pt, -307.4554pt)
            -- (402.4372pt, -306.4227pt)
            -- (402.4372pt, -306.4227pt)
            -- (403.9864pt, -274.5101pt)
            -- (403.9864pt, -274.5101pt)
            -- (319.303pt, -278.1248pt)
            -- (319.303pt, -278.1248pt)
            -- (319.303pt, -278.1248pt)
            -- (319.303pt, -278.1248pt) .. controls (318.167pt, -278.3314pt) and (316.4113pt, -278.6412pt) .. (314.759pt, -279.1576pt) -- cycle
            ;
            \draw[white,line width=1.111111pt]
            (314.75pt, -279.1584pt) .. controls (313.7172pt, -279.4682pt) and (312.5812pt, -279.778pt) .. (311.1354pt, -280.1911pt)
            -- (311.1354pt, -280.1911pt)
            -- (311.1354pt, -280.1911pt)
            -- (311.1354pt, -280.1911pt) .. controls (308.3469pt, -281.2239pt) and (306.0748pt, -281.5337pt) .. (304.0093pt, -281.2239pt)
            -- (304.0093pt, -281.2239pt)
            -- (304.0093pt, -281.2239pt)
            -- (304.0093pt, -281.2239pt) .. controls (301.0143pt, -280.7075pt) and (296.2636pt, -278.7452pt) .. (289.3443pt, -275.647pt)
            -- (289.3443pt, -275.647pt)
            -- (289.3443pt, -275.647pt)
            -- (289.3443pt, -275.647pt) .. controls (284.4903pt, -272.8585pt) and (281.9084pt, -270.8963pt) .. (281.8051pt, -269.5536pt)
            -- (281.8051pt, -269.5536pt)
            -- (281.8051pt, -269.5536pt)
            -- (281.8051pt, -269.5536pt) .. controls (281.4953pt, -268.2111pt) and (283.1477pt, -267.798pt) .. (286.5558pt, -268.5209pt)
            -- (286.5558pt, -268.5209pt)
            -- (286.5558pt, -268.5209pt)
            -- (286.5558pt, -268.5209pt) .. controls (298.1225pt, -270.0701pt) and (315.2666pt, -270.6897pt) .. (338.0908pt, -270.5864pt)
            -- (338.0908pt, -270.5864pt)
            -- (338.0908pt, -270.5864pt)
            -- (338.0908pt, -270.5864pt) .. controls (359.2625pt, -270.3798pt) and (379.0916pt, -269.5536pt) .. (397.6808pt, -268.3143pt)
            -- (397.6808pt, -268.3143pt)
            -- (397.6808pt, -268.3143pt)
            -- (397.6808pt, -268.3143pt) .. controls (398.7136pt, -268.1077pt) and (399.7463pt, -267.9012pt) .. (400.7791pt, -267.5914pt)
            -- (400.7791pt, -267.5914pt)
            -- (400.7791pt, -267.5914pt)
            -- (400.7791pt, -267.5914pt) .. controls (401.2955pt, -267.5914pt) and (402.0184pt, -267.3848pt) .. (402.8446pt, -267.075pt)
            -- (402.8446pt, -267.075pt)
            -- (402.8446pt, -267.075pt)
            -- (402.8446pt, -267.075pt) .. controls (403.8773pt, -266.7651pt) and (404.9101pt, -266.5586pt) .. (405.9428pt, -266.2487pt)
            -- (405.9428pt, -266.2487pt)
            -- (405.9428pt, -266.2487pt)
            -- (405.9428pt, -266.2487pt) .. controls (407.492pt, -266.0422pt) and (409.6607pt, -266.1455pt) .. (412.6557pt, -266.4553pt)
            -- (412.6557pt, -266.4553pt)
            -- (412.6557pt, -266.4553pt)
            -- (412.6557pt, -266.4553pt) .. controls (419.3687pt, -266.7651pt) and (423.3965pt, -267.6946pt) .. (424.5324pt, -269.0372pt)
            -- (424.5324pt, -269.0372pt)
            -- (424.5324pt, -269.0372pt)
            -- (424.5324pt, -269.0372pt) .. controls (425.0488pt, -270.07pt) and (424.4291pt, -271.8257pt) .. (422.7767pt, -274.0977pt)
            -- (422.7767pt, -274.0977pt)
            -- (421.021pt, -277.4026pt)
            -- (421.021pt, -277.4026pt)
            -- (412.7589pt, -305.7001pt)
            -- (412.7589pt, -305.7001pt)
            -- (412.7589pt, -305.7001pt)
            -- (412.7589pt, -305.7001pt) .. controls (419.885pt, -306.7328pt) and (423.7065pt, -308.5918pt) .. (424.119pt, -310.9672pt)
            -- (424.119pt, -310.9672pt)
            -- (424.119pt, -310.9672pt)
            -- (424.119pt, -310.9672pt) .. controls (424.4288pt, -313.9622pt) and (421.4338pt, -315.3047pt) .. (415.2373pt, -315.3047pt)
            -- (415.2373pt, -315.3047pt)
            -- (319.5039pt, -316.4407pt)
            -- (319.5039pt, -316.4407pt)
            -- (317.4384pt, -317.7833pt)
            -- (317.4384pt, -317.7833pt)
            -- (317.4384pt, -317.7833pt)
            -- (317.4384pt, -317.7833pt) .. controls (316.8188pt, -318.0931pt) and (316.3024pt, -318.403pt) .. (316.0959pt, -318.8161pt)
            -- (316.0959pt, -318.8161pt)
            -- (316.0959pt, -318.8161pt)
            -- (316.0959pt, -318.8161pt) .. controls (315.786pt, -319.1259pt) and (315.5794pt, -319.6423pt) .. (315.5794pt, -320.1587pt)
            -- (315.5794pt, -320.1587pt)
            -- (315.786pt, -344.4286pt)
            -- (315.786pt, -344.4286pt) .. controls (315.786pt, -346.5975pt) and (316.3023pt, -348.1466pt) .. (317.5417pt, -349.1793pt)
            -- (317.5417pt, -349.1793pt)
            -- (317.5417pt, -349.1793pt)
            -- (317.5417pt, -349.1793pt) .. controls (318.781pt, -350.1088pt) and (320.9498pt, -350.5219pt) .. (324.1514pt, -350.5219pt)
            -- (324.1514pt, -350.5219pt)
            -- (324.1514pt, -350.5219pt)
            -- (324.1514pt, -350.5219pt)
            -- (391.7972pt, -350.5219pt)
            -- (391.7972pt, -350.5219pt)
            -- (391.7972pt, -350.5219pt)
            -- (391.7972pt, -350.5219pt) .. controls (395.2053pt, -350.2121pt) and (397.9938pt, -349.5924pt) .. (400.0593pt, -348.9727pt)
            -- (400.0593pt, -348.9727pt)
            -- (400.0593pt, -348.9727pt)
            -- (400.0593pt, -348.9727pt) .. controls (401.4019pt, -348.6629pt) and (403.0543pt, -347.8367pt) .. (404.81pt, -346.7007pt)
            -- (404.81pt, -346.7007pt)
            -- (404.81pt, -346.7007pt)
            -- (404.81pt, -346.7007pt) .. controls (406.9788pt, -345.4613pt) and (409.1476pt, -344.7384pt) .. (411.1098pt, -344.3253pt)
            -- (411.1098pt, -344.3253pt)
            -- (411.1098pt, -344.3253pt)
            -- (411.1098pt, -344.3253pt) .. controls (414.2081pt, -343.7057pt) and (418.4424pt, -343.3958pt) .. (424.019pt, -343.809pt)
            -- (424.019pt, -343.809pt)
            -- (424.019pt, -343.809pt)
            -- (424.019pt, -343.809pt) .. controls (428.7697pt, -344.1188pt) and (432.4873pt, -345.0483pt) .. (435.379pt, -346.3909pt)
            -- (435.379pt, -346.3909pt)
            -- (435.379pt, -346.3909pt)
            -- (435.379pt, -346.3909pt) .. controls (438.1674pt, -347.7335pt) and (439.6133pt, -349.3859pt) .. (439.9232pt, -350.9351pt)
            -- (439.9232pt, -350.9351pt)
            -- (439.9232pt, -350.9351pt)
            -- (439.9232pt, -350.9351pt) .. controls (440.4395pt, -352.6907pt) and (439.9232pt, -354.0333pt) .. (438.374pt, -354.9628pt)
            -- (438.374pt, -354.9628pt)
            -- (438.374pt, -354.9628pt)
            -- (438.374pt, -354.9628pt) .. controls (436.6183pt, -356.512pt) and (434.5528pt, -357.3381pt) .. (431.7643pt, -357.3381pt)
            -- (431.7643pt, -357.3381pt)
            -- (431.7643pt, -357.3381pt)
            -- (431.7643pt, -357.3381pt)
            -- (321.5726pt, -357.3381pt)
            -- (321.5726pt, -357.3381pt)
            -- (321.5726pt, -357.3381pt)
            -- (321.5726pt, -357.3381pt) .. controls (314.8597pt, -357.3381pt) and (309.4893pt, -356.0988pt) .. (305.5651pt, -353.7234pt)
            -- (305.5651pt, -353.7234pt)
            -- (305.5651pt, -353.7234pt)
            -- (305.5651pt, -353.7234pt) .. controls (301.7439pt, -351.1415pt) and (299.6784pt, -347.5269pt) .. (299.6784pt, -342.7759pt)
            -- (299.6784pt, -342.7759pt)
            -- (299.6784pt, -342.7759pt)
            -- (299.6784pt, -342.7759pt)
            -- (299.6784pt, -319.8484pt)
            -- (299.6784pt, -319.8484pt)
            -- (299.6784pt, -319.8484pt)
            -- (299.6784pt, -319.8484pt) .. controls (299.162pt, -318.2993pt) and (297.0965pt, -316.6469pt) .. (293.7917pt, -315.0978pt)
            -- (293.7917pt, -315.0978pt)
            -- (293.7917pt, -315.0978pt)
            -- (293.7917pt, -315.0978pt) .. controls (291.2097pt, -313.5486pt) and (288.4213pt, -312.3093pt) .. (285.1167pt, -311.4831pt)
            -- (285.1167pt, -311.4831pt)
            -- (285.1167pt, -311.4831pt)
            -- (285.1167pt, -311.4831pt) .. controls (281.8118pt, -310.2438pt) and (280.0561pt, -309.3143pt) .. (279.5397pt, -308.3849pt)
            -- (279.5397pt, -308.3849pt)
            -- (279.5397pt, -308.3849pt)
            -- (279.5397pt, -308.3849pt) .. controls (279.2299pt, -307.1455pt) and (281.7085pt, -306.3193pt) .. (286.8723pt, -305.8029pt)
            -- (286.8723pt, -305.8029pt)
            -- (286.8723pt, -305.8029pt)
            -- (286.8723pt, -305.8029pt) .. controls (294.1017pt, -306.0095pt) and (301.0215pt, -306.7324pt) .. (307.424pt, -307.7652pt)
            -- (307.424pt, -307.7652pt)
            -- (307.424pt, -307.7652pt)
            -- (307.424pt, -307.7652pt) .. controls (313.2075pt, -308.6947pt) and (316.9257pt, -309.5208pt) .. (318.784pt, -310.5536pt)
            -- (318.784pt, -310.5536pt)
            -- (384.1573pt, -309.2111pt)
            -- (384.1573pt, -309.2111pt) .. controls (386.6359pt, -309.0045pt) and (388.5982pt, -308.798pt) .. (390.5604pt, -308.4882pt)
            -- (390.5604pt, -308.4882pt)
            -- (390.5604pt, -308.4882pt)
            -- (390.5604pt, -308.4882pt) .. controls (392.1096pt, -308.2816pt) and (393.9685pt, -307.9718pt) .. (396.1373pt, -307.4554pt)
            -- (396.1373pt, -307.4554pt)
            -- (402.4372pt, -306.4227pt)
            -- (402.4372pt, -306.4227pt)
            -- (403.9864pt, -274.5101pt)
            -- (403.9864pt, -274.5101pt)
            -- (319.303pt, -278.1248pt)
            -- (319.303pt, -278.1248pt)
            -- (319.303pt, -278.1248pt)
            -- (319.303pt, -278.1248pt) .. controls (318.167pt, -278.3314pt) and (316.4113pt, -278.6412pt) .. (314.759pt, -279.1576pt) -- cycle
            ;
            \filldraw[red][nonzero rule]
            (362.5834pt, -160.4917pt) .. controls (345.0267pt, -161.3179pt) and (330.9809pt, -161.9375pt) .. (320.1367pt, -162.5572pt)
            -- (320.1367pt, -162.5572pt)
            -- (320.1367pt, -162.5572pt)
            -- (320.1367pt, -162.5572pt) .. controls (317.658pt, -162.7637pt) and (315.6958pt, -163.0736pt) .. (313.8369pt, -163.8998pt)
            -- (313.8369pt, -163.8998pt)
            -- (313.8369pt, -163.8998pt)
            -- (313.8369pt, -163.8998pt) .. controls (312.8041pt, -164.2096pt) and (311.5648pt, -164.8293pt) .. (310.1189pt, -165.4489pt)
            -- (310.1189pt, -165.4489pt)
            -- (310.1189pt, -165.4489pt)
            -- (310.1189pt, -165.4489pt) .. controls (307.3304pt, -166.7915pt) and (304.9551pt, -167.2046pt) .. (302.5798pt, -166.7915pt)
            -- (302.5798pt, -166.7915pt)
            -- (302.5798pt, -166.7915pt)
            -- (302.5798pt, -166.7915pt) .. controls (299.1716pt, -165.862pt) and (292.8715pt, -163.1768pt) .. (283.6797pt, -158.6327pt)
            -- (283.6797pt, -158.6327pt)
            -- (283.6797pt, -158.6327pt)
            -- (283.6797pt, -158.6327pt) .. controls (279.4455pt, -156.154pt) and (277.2767pt, -154.3983pt) .. (277.2767pt, -153.0558pt)
            -- (277.2767pt, -153.0558pt)
            -- (277.2767pt, -153.0558pt)
            -- (277.2767pt, -153.0558pt) .. controls (277.2767pt, -151.5066pt) and (279.8586pt, -151.3001pt) .. (284.8158pt, -152.5394pt)
            -- (284.8158pt, -152.5394pt)
            -- (284.8158pt, -152.5394pt)
            -- (284.8158pt, -152.5394pt) .. controls (296.0725pt, -154.0886pt) and (313.1133pt, -155.0181pt) .. (335.9375pt, -155.0181pt)
            -- (335.9375pt, -155.0181pt)
            -- (335.9375pt, -155.0181pt)
            -- (335.9375pt, -155.0181pt) .. controls (351.6358pt, -154.8115pt) and (374.5625pt, -154.0886pt) .. (404.7191pt, -153.0558pt)
            -- (404.7191pt, -153.0558pt)
            -- (404.7191pt, -153.0558pt)
            -- (404.7191pt, -153.0558pt) .. controls (406.2683pt, -152.8493pt) and (407.7141pt, -152.5394pt) .. (408.7469pt, -152.0231pt)
            -- (408.7469pt, -152.0231pt)
            -- (408.7469pt, -152.0231pt)
            -- (408.7469pt, -152.0231pt) .. controls (409.3665pt, -151.8165pt) and (410.5026pt, -151.5067pt) .. (411.8452pt, -150.9903pt)
            -- (411.8452pt, -150.9903pt)
            -- (411.8452pt, -150.9903pt)
            -- (411.8452pt, -150.9903pt) .. controls (413.6008pt, -150.3707pt) and (415.15pt, -149.8543pt) .. (416.5958pt, -149.6477pt)
            -- (416.5958pt, -149.6477pt)
            -- (416.5958pt, -149.6477pt)
            -- (416.5958pt, -149.6477pt) .. controls (419.1777pt, -149.4412pt) and (422.7924pt, -149.751pt) .. (427.6466pt, -150.3707pt)
            -- (427.6466pt, -150.3707pt)
            -- (427.6466pt, -150.3707pt)
            -- (427.6466pt, -150.3707pt) .. controls (433.4301pt, -151.3002pt) and (436.735pt, -152.4362pt) .. (437.5608pt, -153.9853pt)
            -- (437.5608pt, -153.9853pt)
            -- (437.5608pt, -153.9853pt)
            -- (437.5608pt, -153.9853pt) .. controls (437.8706pt, -155.0181pt) and (437.1477pt, -156.7738pt) .. (435.1855pt, -158.9426pt)
            -- (435.1855pt, -158.9426pt)
            -- (435.1855pt, -158.9426pt)
            -- (435.1855pt, -158.9426pt) .. controls (434.256pt, -159.9753pt) and (433.7397pt, -160.6982pt) .. (433.4298pt, -161.2147pt)
            -- (433.4298pt, -161.2147pt)
            -- (433.4298pt, -161.2147pt)
            -- (433.4298pt, -161.2147pt) .. controls (432.9134pt, -161.8343pt) and (432.5003pt, -162.6605pt) .. (432.3971pt, -163.4868pt)
            -- (432.3971pt, -163.4868pt)
            -- (432.3971pt, -163.4868pt)
            -- (432.3971pt, -163.4868pt) .. controls (430.2282pt, -172.4717pt) and (426.6136pt, -183.5226pt) .. (421.6562pt, -196.7418pt)
            -- (421.6562pt, -196.7418pt)
            -- (421.6562pt, -196.7418pt)
            -- (421.6562pt, -196.7418pt) .. controls (417.4219pt, -207.7926pt) and (412.8779pt, -218.7393pt) .. (408.2304pt, -229.6867pt)
            -- (408.2304pt, -229.6867pt)
            -- (400.3814pt, -230.6162pt)
            -- (400.3814pt, -230.6162pt) .. controls (403.6863pt, -220.8054pt) and (406.6813pt, -209.4446pt) .. (409.4698pt, -196.5354pt)
            -- (409.4698pt, -196.5354pt)
            -- (409.4698pt, -196.5354pt)
            -- (409.4698pt, -196.5354pt) .. controls (412.568pt, -183.9354pt) and (414.427pt, -173.8146pt) .. (415.3565pt, -166.3788pt)
            -- (415.3565pt, -166.3788pt)
            -- (416.8023pt, -159.5625pt)
            -- (416.8023pt, -159.5625pt) .. controls (402.1373pt, -159.356pt) and (383.9607pt, -159.769pt) .. (362.5823pt, -160.492pt) -- cycle
            ;
            \draw[white,line width=1.111111pt]
            (362.5834pt, -160.4917pt) .. controls (345.0267pt, -161.3179pt) and (330.9809pt, -161.9375pt) .. (320.1367pt, -162.5572pt)
            -- (320.1367pt, -162.5572pt)
            -- (320.1367pt, -162.5572pt)
            -- (320.1367pt, -162.5572pt) .. controls (317.658pt, -162.7637pt) and (315.6958pt, -163.0736pt) .. (313.8369pt, -163.8998pt)
            -- (313.8369pt, -163.8998pt)
            -- (313.8369pt, -163.8998pt)
            -- (313.8369pt, -163.8998pt) .. controls (312.8041pt, -164.2096pt) and (311.5648pt, -164.8293pt) .. (310.1189pt, -165.4489pt)
            -- (310.1189pt, -165.4489pt)
            -- (310.1189pt, -165.4489pt)
            -- (310.1189pt, -165.4489pt) .. controls (307.3304pt, -166.7915pt) and (304.9551pt, -167.2046pt) .. (302.5798pt, -166.7915pt)
            -- (302.5798pt, -166.7915pt)
            -- (302.5798pt, -166.7915pt)
            -- (302.5798pt, -166.7915pt) .. controls (299.1716pt, -165.862pt) and (292.8715pt, -163.1768pt) .. (283.6797pt, -158.6327pt)
            -- (283.6797pt, -158.6327pt)
            -- (283.6797pt, -158.6327pt)
            -- (283.6797pt, -158.6327pt) .. controls (279.4455pt, -156.154pt) and (277.2767pt, -154.3983pt) .. (277.2767pt, -153.0558pt)
            -- (277.2767pt, -153.0558pt)
            -- (277.2767pt, -153.0558pt)
            -- (277.2767pt, -153.0558pt) .. controls (277.2767pt, -151.5066pt) and (279.8586pt, -151.3001pt) .. (284.8158pt, -152.5394pt)
            -- (284.8158pt, -152.5394pt)
            -- (284.8158pt, -152.5394pt)
            -- (284.8158pt, -152.5394pt) .. controls (296.0725pt, -154.0886pt) and (313.1133pt, -155.0181pt) .. (335.9375pt, -155.0181pt)
            -- (335.9375pt, -155.0181pt)
            -- (335.9375pt, -155.0181pt)
            -- (335.9375pt, -155.0181pt) .. controls (351.6358pt, -154.8115pt) and (374.5625pt, -154.0886pt) .. (404.7191pt, -153.0558pt)
            -- (404.7191pt, -153.0558pt)
            -- (404.7191pt, -153.0558pt)
            -- (404.7191pt, -153.0558pt) .. controls (406.2683pt, -152.8493pt) and (407.7141pt, -152.5394pt) .. (408.7469pt, -152.0231pt)
            -- (408.7469pt, -152.0231pt)
            -- (408.7469pt, -152.0231pt)
            -- (408.7469pt, -152.0231pt) .. controls (409.3665pt, -151.8165pt) and (410.5026pt, -151.5067pt) .. (411.8452pt, -150.9903pt)
            -- (411.8452pt, -150.9903pt)
            -- (411.8452pt, -150.9903pt)
            -- (411.8452pt, -150.9903pt) .. controls (413.6008pt, -150.3707pt) and (415.15pt, -149.8543pt) .. (416.5958pt, -149.6477pt)
            -- (416.5958pt, -149.6477pt)
            -- (416.5958pt, -149.6477pt)
            -- (416.5958pt, -149.6477pt) .. controls (419.1777pt, -149.4412pt) and (422.7924pt, -149.751pt) .. (427.6466pt, -150.3707pt)
            -- (427.6466pt, -150.3707pt)
            -- (427.6466pt, -150.3707pt)
            -- (427.6466pt, -150.3707pt) .. controls (433.4301pt, -151.3002pt) and (436.735pt, -152.4362pt) .. (437.5608pt, -153.9853pt)
            -- (437.5608pt, -153.9853pt)
            -- (437.5608pt, -153.9853pt)
            -- (437.5608pt, -153.9853pt) .. controls (437.8706pt, -155.0181pt) and (437.1477pt, -156.7738pt) .. (435.1855pt, -158.9426pt)
            -- (435.1855pt, -158.9426pt)
            -- (435.1855pt, -158.9426pt)
            -- (435.1855pt, -158.9426pt) .. controls (434.256pt, -159.9753pt) and (433.7397pt, -160.6982pt) .. (433.4298pt, -161.2147pt)
            -- (433.4298pt, -161.2147pt)
            -- (433.4298pt, -161.2147pt)
            -- (433.4298pt, -161.2147pt) .. controls (432.9134pt, -161.8343pt) and (432.5003pt, -162.6605pt) .. (432.3971pt, -163.4868pt)
            -- (432.3971pt, -163.4868pt)
            -- (432.3971pt, -163.4868pt)
            -- (432.3971pt, -163.4868pt) .. controls (430.2282pt, -172.4717pt) and (426.6136pt, -183.5226pt) .. (421.6562pt, -196.7418pt)
            -- (421.6562pt, -196.7418pt)
            -- (421.6562pt, -196.7418pt)
            -- (421.6562pt, -196.7418pt) .. controls (417.4219pt, -207.7926pt) and (412.8779pt, -218.7393pt) .. (408.2304pt, -229.6867pt)
            -- (408.2304pt, -229.6867pt)
            -- (400.3814pt, -230.6162pt)
            -- (400.3814pt, -230.6162pt) .. controls (403.6863pt, -220.8054pt) and (406.6813pt, -209.4446pt) .. (409.4698pt, -196.5354pt)
            -- (409.4698pt, -196.5354pt)
            -- (409.4698pt, -196.5354pt)
            -- (409.4698pt, -196.5354pt) .. controls (412.568pt, -183.9354pt) and (414.427pt, -173.8146pt) .. (415.3565pt, -166.3788pt)
            -- (415.3565pt, -166.3788pt)
            -- (416.8023pt, -159.5625pt)
            -- (416.8023pt, -159.5625pt) .. controls (402.1373pt, -159.356pt) and (383.9607pt, -159.769pt) .. (362.5823pt, -160.492pt) -- cycle
            ;
            \filldraw[red][nonzero rule]
            (43.5pt, -165.7584pt) .. controls (40.40175pt, -163.8994pt) and (37.09692pt, -161.524pt) .. (33.68917pt, -158.529pt)
            -- (33.68917pt, -158.529pt)
            -- (33.68917pt, -158.529pt)
            -- (33.68917pt, -158.529pt) .. controls (31.2105pt, -156.3602pt) and (30.281pt, -154.9144pt) .. (30.59083pt, -153.9849pt)
            -- (30.59083pt, -153.9849pt)
            -- (30.59083pt, -153.9849pt)
            -- (30.59083pt, -153.9849pt) .. controls (30.90067pt, -152.9521pt) and (33.79241pt, -152.9521pt) .. (38.85291pt, -154.1914pt)
            -- (38.85291pt, -154.1914pt)
            -- (38.85291pt, -154.1914pt)
            -- (38.85291pt, -154.1914pt) .. controls (44.22333pt, -154.8111pt) and (49.49042pt, -155.3274pt) .. (54.34458pt, -155.534pt)
            -- (54.34458pt, -155.534pt)
            -- (54.34458pt, -155.534pt)
            -- (54.34458pt, -155.534pt) .. controls (61.26408pt, -155.8438pt) and (71.79791pt, -155.9471pt) .. (85.74041pt, -155.7405pt)
            -- (85.74041pt, -155.7405pt)
            -- (85.74041pt, -155.7405pt)
            -- (85.74041pt, -155.7405pt) .. controls (89.35507pt, -155.9471pt) and (92.14358pt, -156.7733pt) .. (94.00249pt, -158.0126pt)
            -- (94.00249pt, -158.0126pt)
            -- (94.00249pt, -158.0126pt)
            -- (94.00249pt, -158.0126pt) .. controls (95.8615pt, -159.252pt) and (96.791pt, -160.6978pt) .. (96.58441pt, -162.3502pt)
            -- (96.58441pt, -162.3502pt)
            -- (96.58441pt, -162.3502pt)
            -- (96.58441pt, -162.3502pt) .. controls (96.37782pt, -163.8994pt) and (95.13858pt, -165.3452pt) .. (92.86649pt, -166.378pt)
            -- (92.86649pt, -166.378pt)
            -- (92.86649pt, -166.378pt)
            -- (92.86649pt, -166.378pt) .. controls (90.28458pt, -167.6173pt) and (86.8765pt, -168.237pt) .. (82.43566pt, -168.4435pt)
            -- (82.43566pt, -168.4435pt)
            -- (52.17566pt, -169.2697pt)
            -- (52.17566pt, -169.2697pt) .. controls (49.80025pt, -169.0631pt) and (47.01183pt, -167.8239pt) .. (43.50066pt, -165.7583pt) -- cycle
            ;
            \draw[white,line width=1.111111pt]
            (43.5pt, -165.7584pt) .. controls (40.40175pt, -163.8994pt) and (37.09692pt, -161.524pt) .. (33.68917pt, -158.529pt)
            -- (33.68917pt, -158.529pt)
            -- (33.68917pt, -158.529pt)
            -- (33.68917pt, -158.529pt) .. controls (31.2105pt, -156.3602pt) and (30.281pt, -154.9144pt) .. (30.59083pt, -153.9849pt)
            -- (30.59083pt, -153.9849pt)
            -- (30.59083pt, -153.9849pt)
            -- (30.59083pt, -153.9849pt) .. controls (30.90067pt, -152.9521pt) and (33.79241pt, -152.9521pt) .. (38.85291pt, -154.1914pt)
            -- (38.85291pt, -154.1914pt)
            -- (38.85291pt, -154.1914pt)
            -- (38.85291pt, -154.1914pt) .. controls (44.22333pt, -154.8111pt) and (49.49042pt, -155.3274pt) .. (54.34458pt, -155.534pt)
            -- (54.34458pt, -155.534pt)
            -- (54.34458pt, -155.534pt)
            -- (54.34458pt, -155.534pt) .. controls (61.26408pt, -155.8438pt) and (71.79791pt, -155.9471pt) .. (85.74041pt, -155.7405pt)
            -- (85.74041pt, -155.7405pt)
            -- (85.74041pt, -155.7405pt)
            -- (85.74041pt, -155.7405pt) .. controls (89.35507pt, -155.9471pt) and (92.14358pt, -156.7733pt) .. (94.00249pt, -158.0126pt)
            -- (94.00249pt, -158.0126pt)
            -- (94.00249pt, -158.0126pt)
            -- (94.00249pt, -158.0126pt) .. controls (95.8615pt, -159.252pt) and (96.791pt, -160.6978pt) .. (96.58441pt, -162.3502pt)
            -- (96.58441pt, -162.3502pt)
            -- (96.58441pt, -162.3502pt)
            -- (96.58441pt, -162.3502pt) .. controls (96.37782pt, -163.8994pt) and (95.13858pt, -165.3452pt) .. (92.86649pt, -166.378pt)
            -- (92.86649pt, -166.378pt)
            -- (92.86649pt, -166.378pt)
            -- (92.86649pt, -166.378pt) .. controls (90.28458pt, -167.6173pt) and (86.8765pt, -168.237pt) .. (82.43566pt, -168.4435pt)
            -- (82.43566pt, -168.4435pt)
            -- (52.17566pt, -169.2697pt)
            -- (52.17566pt, -169.2697pt) .. controls (49.80025pt, -169.0631pt) and (47.01183pt, -167.8239pt) .. (43.50066pt, -165.7583pt) -- cycle
            ;
            \filldraw[red][nonzero rule]
            (41.87001pt, -229.2809pt) .. controls (36.29317pt, -234.4447pt) and (33.505pt, -241.0542pt) .. (33.505pt, -248.6967pt)
            -- (33.505pt, -248.6967pt)
            -- (33.505pt, -248.6967pt)
            -- (33.505pt, -248.6967pt) .. controls (33.505pt, -256.3391pt) and (36.39676pt, -262.7425pt) .. (41.87001pt, -268.1125pt)
            -- (41.87001pt, -268.1125pt)
            -- (41.87001pt, -268.1125pt)
            -- (41.87001pt, -268.1125pt) .. controls (47.96334pt, -274.1025pt) and (56.32834pt, -277.0975pt) .. (67.06918pt, -277.0975pt)
            -- (67.06918pt, -277.0975pt)
            -- (67.06918pt, -277.0975pt)
            -- (67.06918pt, -277.0975pt) .. controls (77.60334pt, -277.0975pt) and (85.86584pt, -274.1025pt) .. (92.26834pt, -268.1125pt)
            -- (92.26834pt, -268.1125pt)
            -- (92.26834pt, -268.1125pt)
            -- (92.26834pt, -268.1125pt) .. controls (97.84526pt, -262.7422pt) and (100.6333pt, -256.2359pt) .. (100.6333pt, -248.6967pt)
            -- (100.6333pt, -248.6967pt)
            -- (100.6333pt, -248.6967pt)
            -- (100.6333pt, -248.6967pt) .. controls (100.6333pt, -240.8477pt) and (97.74168pt, -234.4442pt) .. (92.26834pt, -229.2809pt)
            -- (92.26834pt, -229.2809pt)
            -- (92.26834pt, -229.2809pt)
            -- (92.26834pt, -229.2809pt) .. controls (85.96851pt, -223.2909pt) and (77.70667pt, -220.2959pt) .. (67.06918pt, -220.2959pt)
            -- (67.06918pt, -220.2959pt)
            -- (67.06918pt, -220.2959pt)
            -- (67.06918pt, -220.2959pt) .. controls (56.22501pt, -220.2959pt) and (47.96334pt, -223.1876pt) .. (41.87pt, -229.2809pt) -- cycle
            (101.6667pt, -188.9pt) .. controls (102.6995pt, -188.3837pt) and (103.9388pt, -187.6607pt) .. (105.3847pt, -186.8345pt)
            -- (105.3847pt, -186.8345pt)
            -- (105.3847pt, -186.8345pt)
            -- (105.3847pt, -186.8345pt) .. controls (107.2436pt, -185.5952pt) and (108.9993pt, -184.769pt) .. (110.9616pt, -184.2526pt)
            -- (110.9616pt, -184.2526pt)
            -- (110.9616pt, -184.2526pt)
            -- (110.9616pt, -184.2526pt) .. controls (113.9566pt, -183.633pt) and (118.1908pt, -183.2198pt) .. (123.8708pt, -183.2198pt)
            -- (123.8708pt, -183.2198pt)
            -- (123.8708pt, -183.2198pt)
            -- (123.8708pt, -183.2198pt) .. controls (127.8985pt, -183.2198pt) and (131.2033pt, -184.0461pt) .. (133.6816pt, -185.4919pt)
            -- (133.6816pt, -185.4919pt)
            -- (133.6816pt, -185.4919pt)
            -- (133.6816pt, -185.4919pt) .. controls (135.7472pt, -186.7313pt) and (136.8832pt, -188.2805pt) .. (136.9864pt, -190.0361pt)
            -- (136.9864pt, -190.0361pt)
            -- (136.9864pt, -190.0361pt)
            -- (136.9864pt, -190.0361pt) .. controls (137.193pt, -191.7918pt) and (136.3668pt, -193.2377pt) .. (134.4046pt, -194.477pt)
            -- (134.4046pt, -194.477pt)
            -- (134.4046pt, -194.477pt)
            -- (134.4046pt, -194.477pt) .. controls (132.339pt, -195.8195pt) and (129.6538pt, -196.4392pt) .. (126.349pt, -196.4392pt)
            -- (126.349pt, -196.4392pt)
            -- (126.349pt, -196.4392pt)
            -- (126.349pt, -196.4392pt) .. controls (112.3032pt, -196.6458pt) and (101.769pt, -196.8523pt) .. (94.84982pt, -197.1621pt)
            -- (94.84982pt, -197.1621pt)
            -- (94.84982pt, -197.1621pt)
            -- (94.84982pt, -197.1621pt) .. controls (84.10899pt, -197.472pt) and (75.95066pt, -198.0916pt) .. (69.65066pt, -198.7113pt)
            -- (69.65066pt, -198.7113pt)
            -- (69.65066pt, -198.7113pt)
            -- (69.65066pt, -198.7113pt) .. controls (72.64574pt, -202.1194pt) and (74.19482pt, -204.5981pt) .. (74.71124pt, -206.1472pt)
            -- (74.71124pt, -206.1472pt)
            -- (74.71124pt, -206.1472pt)
            -- (74.71124pt, -206.1472pt) .. controls (75.22757pt, -207.1799pt) and (75.12432pt, -208.316pt) .. (74.50465pt, -209.7618pt)
            -- (74.50465pt, -209.7618pt)
            -- (73.98832pt, -212.6536pt)
            -- (73.98832pt, -212.6536pt) .. controls (88.34332pt, -214.5126pt) and (99.29082pt, -219.4698pt) .. (106.9333pt, -227.6285pt)
            -- (106.9333pt, -227.6285pt)
            -- (106.9333pt, -227.6285pt)
            -- (106.9333pt, -227.6285pt) .. controls (113.6463pt, -235.1677pt) and (116.5383pt, -243.6361pt) .. (115.7117pt, -253.1377pt)
            -- (115.7117pt, -253.1377pt)
            -- (115.7117pt, -253.1377pt)
            -- (115.7117pt, -253.1377pt) .. controls (114.6789pt, -262.6394pt) and (110.0315pt, -270.6944pt) .. (101.7692pt, -277.0977pt)
            -- (101.7692pt, -277.0977pt)
            -- (101.7692pt, -277.0977pt)
            -- (101.7692pt, -277.0977pt) .. controls (92.78416pt, -284.2237pt) and (81.62999pt, -287.8386pt) .. (67.89416pt, -287.8386pt)
            -- (67.89416pt, -287.8386pt)
            -- (67.89416pt, -287.8386pt)
            -- (67.89416pt, -287.8386pt) .. controls (53.74499pt, -287.8386pt) and (41.97165pt, -284.2239pt) .. (32.88332pt, -277.0977pt)
            -- (32.88332pt, -277.0977pt)
            -- (32.88332pt, -277.0977pt)
            -- (32.88332pt, -277.0977pt) .. controls (24.62123pt, -270.6946pt) and (19.97415pt, -262.6394pt) .. (18.73415pt, -253.1377pt)
            -- (18.73415pt, -253.1377pt)
            -- (18.73415pt, -253.1377pt)
            -- (18.73415pt, -253.1377pt) .. controls (17.4949pt, -243.6361pt) and (20.4899pt, -235.0644pt) .. (27.40915pt, -227.9385pt)
            -- (27.40915pt, -227.9385pt)
            -- (27.40915pt, -227.9385pt)
            -- (27.40915pt, -227.9385pt) .. controls (35.15482pt, -219.6765pt) and (46.30832pt, -214.6161pt) .. (61.38666pt, -212.6536pt)
            -- (61.38666pt, -212.6536pt)
            -- (61.38666pt, -212.6536pt)
            -- (61.38666pt, -212.6536pt) .. controls (63.45224pt, -210.8979pt) and (64.38174pt, -208.9356pt) .. (63.96857pt, -206.3537pt)
            -- (63.96857pt, -206.3537pt)
            -- (63.96857pt, -206.3537pt)
            -- (63.96857pt, -206.3537pt) .. controls (63.65874pt, -203.8751pt) and (62.31615pt, -201.7063pt) .. (60.25066pt, -199.5375pt)
            -- (60.25066pt, -199.5375pt)
            -- (60.25066pt, -199.5375pt)
            -- (60.25066pt, -199.5375pt) .. controls (55.70648pt, -199.5375pt) and (50.74899pt, -199.744pt) .. (45.68899pt, -200.3637pt)
            -- (45.68899pt, -200.3637pt)
            -- (45.68899pt, -200.3637pt)
            -- (45.68899pt, -200.3637pt) .. controls (40.52515pt, -200.6735pt) and (34.63816pt, -201.3964pt) .. (28.02899pt, -202.1194pt)
            -- (28.02899pt, -202.1194pt)
            -- (28.02899pt, -202.1194pt)
            -- (28.02899pt, -202.1194pt) .. controls (26.68632pt, -202.3259pt) and (25.44707pt, -202.5324pt) .. (24.41432pt, -202.8423pt)
            -- (24.41432pt, -202.8423pt)
            -- (24.41432pt, -202.8423pt)
            -- (24.41432pt, -202.8423pt) .. controls (23.79465pt, -203.1521pt) and (22.9684pt, -203.6685pt) .. (22.14224pt, -204.1849pt)
            -- (22.14224pt, -204.1849pt)
            -- (22.14224pt, -204.1849pt)
            -- (22.14224pt, -204.1849pt) .. controls (19.9734pt, -205.2176pt) and (17.80465pt, -205.5275pt) .. (15.84241pt, -204.9078pt)
            -- (15.84241pt, -204.9078pt)
            -- (15.84241pt, -204.9078pt)
            -- (15.84241pt, -204.9078pt) .. controls (12.84741pt, -203.9783pt) and (7.580322pt, -201.2932pt) .. (-0.681762pt, -196.749pt)
            -- (-0.681762pt, -196.749pt)
            -- (-0.681762pt, -196.749pt)
            -- (-0.681762pt, -196.749pt) .. controls (-5.122679pt, -194.1671pt) and (-7.084929pt, -192.3081pt) .. (-6.568512pt, -191.1721pt)
            -- (-6.568512pt, -191.1721pt)
            -- (-6.568512pt, -191.1721pt)
            -- (-6.568512pt, -191.1721pt) .. controls (-6.052179pt, -189.9327pt) and (-3.057178pt, -189.8295pt) .. (2.313154pt, -190.9655pt)
            -- (2.313154pt, -190.9655pt)
            -- (2.313154pt, -190.9655pt)
            -- (2.313154pt, -190.9655pt) .. controls (13.15732pt, -192.7212pt) and (25.03399pt, -193.6507pt) .. (38.14982pt, -193.6507pt)
            -- (38.14982pt, -193.6507pt)
            -- (38.14982pt, -193.6507pt)
            -- (38.14982pt, -193.6507pt) .. controls (50.64649pt, -193.6507pt) and (69.54565pt, -192.7212pt) .. (94.84816pt, -190.9655pt)
            -- (94.84816pt, -190.9655pt)
            -- (94.84816pt, -190.9655pt)
            -- (94.84816pt, -190.9655pt) .. controls (97.63658pt, -190.1393pt) and (99.80541pt, -189.6229pt) .. (101.6643pt, -188.9pt) -- cycle
            ;
            \draw[white,line width=1.111111pt]
            (41.87001pt, -229.2809pt) .. controls (36.29317pt, -234.4447pt) and (33.505pt, -241.0542pt) .. (33.505pt, -248.6967pt)
            -- (33.505pt, -248.6967pt)
            -- (33.505pt, -248.6967pt)
            -- (33.505pt, -248.6967pt) .. controls (33.505pt, -256.3391pt) and (36.39676pt, -262.7425pt) .. (41.87001pt, -268.1125pt)
            -- (41.87001pt, -268.1125pt)
            -- (41.87001pt, -268.1125pt)
            -- (41.87001pt, -268.1125pt) .. controls (47.96334pt, -274.1025pt) and (56.32834pt, -277.0975pt) .. (67.06918pt, -277.0975pt)
            -- (67.06918pt, -277.0975pt)
            -- (67.06918pt, -277.0975pt)
            -- (67.06918pt, -277.0975pt) .. controls (77.60334pt, -277.0975pt) and (85.86584pt, -274.1025pt) .. (92.26834pt, -268.1125pt)
            -- (92.26834pt, -268.1125pt)
            -- (92.26834pt, -268.1125pt)
            -- (92.26834pt, -268.1125pt) .. controls (97.84526pt, -262.7422pt) and (100.6333pt, -256.2359pt) .. (100.6333pt, -248.6967pt)
            -- (100.6333pt, -248.6967pt)
            -- (100.6333pt, -248.6967pt)
            -- (100.6333pt, -248.6967pt) .. controls (100.6333pt, -240.8477pt) and (97.74168pt, -234.4442pt) .. (92.26834pt, -229.2809pt)
            -- (92.26834pt, -229.2809pt)
            -- (92.26834pt, -229.2809pt)
            -- (92.26834pt, -229.2809pt) .. controls (85.96851pt, -223.2909pt) and (77.70667pt, -220.2959pt) .. (67.06918pt, -220.2959pt)
            -- (67.06918pt, -220.2959pt)
            -- (67.06918pt, -220.2959pt)
            -- (67.06918pt, -220.2959pt) .. controls (56.22501pt, -220.2959pt) and (47.96334pt, -223.1876pt) .. (41.87pt, -229.2809pt) -- cycle
            (101.6667pt, -188.9pt) .. controls (102.6995pt, -188.3837pt) and (103.9388pt, -187.6607pt) .. (105.3847pt, -186.8345pt)
            -- (105.3847pt, -186.8345pt)
            -- (105.3847pt, -186.8345pt)
            -- (105.3847pt, -186.8345pt) .. controls (107.2436pt, -185.5952pt) and (108.9993pt, -184.769pt) .. (110.9616pt, -184.2526pt)
            -- (110.9616pt, -184.2526pt)
            -- (110.9616pt, -184.2526pt)
            -- (110.9616pt, -184.2526pt) .. controls (113.9566pt, -183.633pt) and (118.1908pt, -183.2198pt) .. (123.8708pt, -183.2198pt)
            -- (123.8708pt, -183.2198pt)
            -- (123.8708pt, -183.2198pt)
            -- (123.8708pt, -183.2198pt) .. controls (127.8985pt, -183.2198pt) and (131.2033pt, -184.0461pt) .. (133.6816pt, -185.4919pt)
            -- (133.6816pt, -185.4919pt)
            -- (133.6816pt, -185.4919pt)
            -- (133.6816pt, -185.4919pt) .. controls (135.7472pt, -186.7313pt) and (136.8832pt, -188.2805pt) .. (136.9864pt, -190.0361pt)
            -- (136.9864pt, -190.0361pt)
            -- (136.9864pt, -190.0361pt)
            -- (136.9864pt, -190.0361pt) .. controls (137.193pt, -191.7918pt) and (136.3668pt, -193.2377pt) .. (134.4046pt, -194.477pt)
            -- (134.4046pt, -194.477pt)
            -- (134.4046pt, -194.477pt)
            -- (134.4046pt, -194.477pt) .. controls (132.339pt, -195.8195pt) and (129.6538pt, -196.4392pt) .. (126.349pt, -196.4392pt)
            -- (126.349pt, -196.4392pt)
            -- (126.349pt, -196.4392pt)
            -- (126.349pt, -196.4392pt) .. controls (112.3032pt, -196.6458pt) and (101.769pt, -196.8523pt) .. (94.84982pt, -197.1621pt)
            -- (94.84982pt, -197.1621pt)
            -- (94.84982pt, -197.1621pt)
            -- (94.84982pt, -197.1621pt) .. controls (84.10899pt, -197.472pt) and (75.95066pt, -198.0916pt) .. (69.65066pt, -198.7113pt)
            -- (69.65066pt, -198.7113pt)
            -- (69.65066pt, -198.7113pt)
            -- (69.65066pt, -198.7113pt) .. controls (72.64574pt, -202.1194pt) and (74.19482pt, -204.5981pt) .. (74.71124pt, -206.1472pt)
            -- (74.71124pt, -206.1472pt)
            -- (74.71124pt, -206.1472pt)
            -- (74.71124pt, -206.1472pt) .. controls (75.22757pt, -207.1799pt) and (75.12432pt, -208.316pt) .. (74.50465pt, -209.7618pt)
            -- (74.50465pt, -209.7618pt)
            -- (73.98832pt, -212.6536pt)
            -- (73.98832pt, -212.6536pt) .. controls (88.34332pt, -214.5126pt) and (99.29082pt, -219.4698pt) .. (106.9333pt, -227.6285pt)
            -- (106.9333pt, -227.6285pt)
            -- (106.9333pt, -227.6285pt)
            -- (106.9333pt, -227.6285pt) .. controls (113.6463pt, -235.1677pt) and (116.5383pt, -243.6361pt) .. (115.7117pt, -253.1377pt)
            -- (115.7117pt, -253.1377pt)
            -- (115.7117pt, -253.1377pt)
            -- (115.7117pt, -253.1377pt) .. controls (114.6789pt, -262.6394pt) and (110.0315pt, -270.6944pt) .. (101.7692pt, -277.0977pt)
            -- (101.7692pt, -277.0977pt)
            -- (101.7692pt, -277.0977pt)
            -- (101.7692pt, -277.0977pt) .. controls (92.78416pt, -284.2237pt) and (81.62999pt, -287.8386pt) .. (67.89416pt, -287.8386pt)
            -- (67.89416pt, -287.8386pt)
            -- (67.89416pt, -287.8386pt)
            -- (67.89416pt, -287.8386pt) .. controls (53.74499pt, -287.8386pt) and (41.97165pt, -284.2239pt) .. (32.88332pt, -277.0977pt)
            -- (32.88332pt, -277.0977pt)
            -- (32.88332pt, -277.0977pt)
            -- (32.88332pt, -277.0977pt) .. controls (24.62123pt, -270.6946pt) and (19.97415pt, -262.6394pt) .. (18.73415pt, -253.1377pt)
            -- (18.73415pt, -253.1377pt)
            -- (18.73415pt, -253.1377pt)
            -- (18.73415pt, -253.1377pt) .. controls (17.4949pt, -243.6361pt) and (20.4899pt, -235.0644pt) .. (27.40915pt, -227.9385pt)
            -- (27.40915pt, -227.9385pt)
            -- (27.40915pt, -227.9385pt)
            -- (27.40915pt, -227.9385pt) .. controls (35.15482pt, -219.6765pt) and (46.30832pt, -214.6161pt) .. (61.38666pt, -212.6536pt)
            -- (61.38666pt, -212.6536pt)
            -- (61.38666pt, -212.6536pt)
            -- (61.38666pt, -212.6536pt) .. controls (63.45224pt, -210.8979pt) and (64.38174pt, -208.9356pt) .. (63.96857pt, -206.3537pt)
            -- (63.96857pt, -206.3537pt)
            -- (63.96857pt, -206.3537pt)
            -- (63.96857pt, -206.3537pt) .. controls (63.65874pt, -203.8751pt) and (62.31615pt, -201.7063pt) .. (60.25066pt, -199.5375pt)
            -- (60.25066pt, -199.5375pt)
            -- (60.25066pt, -199.5375pt)
            -- (60.25066pt, -199.5375pt) .. controls (55.70648pt, -199.5375pt) and (50.74899pt, -199.744pt) .. (45.68899pt, -200.3637pt)
            -- (45.68899pt, -200.3637pt)
            -- (45.68899pt, -200.3637pt)
            -- (45.68899pt, -200.3637pt) .. controls (40.52515pt, -200.6735pt) and (34.63816pt, -201.3964pt) .. (28.02899pt, -202.1194pt)
            -- (28.02899pt, -202.1194pt)
            -- (28.02899pt, -202.1194pt)
            -- (28.02899pt, -202.1194pt) .. controls (26.68632pt, -202.3259pt) and (25.44707pt, -202.5324pt) .. (24.41432pt, -202.8423pt)
            -- (24.41432pt, -202.8423pt)
            -- (24.41432pt, -202.8423pt)
            -- (24.41432pt, -202.8423pt) .. controls (23.79465pt, -203.1521pt) and (22.9684pt, -203.6685pt) .. (22.14224pt, -204.1849pt)
            -- (22.14224pt, -204.1849pt)
            -- (22.14224pt, -204.1849pt)
            -- (22.14224pt, -204.1849pt) .. controls (19.9734pt, -205.2176pt) and (17.80465pt, -205.5275pt) .. (15.84241pt, -204.9078pt)
            -- (15.84241pt, -204.9078pt)
            -- (15.84241pt, -204.9078pt)
            -- (15.84241pt, -204.9078pt) .. controls (12.84741pt, -203.9783pt) and (7.580322pt, -201.2932pt) .. (-0.681762pt, -196.749pt)
            -- (-0.681762pt, -196.749pt)
            -- (-0.681762pt, -196.749pt)
            -- (-0.681762pt, -196.749pt) .. controls (-5.122679pt, -194.1671pt) and (-7.084929pt, -192.3081pt) .. (-6.568512pt, -191.1721pt)
            -- (-6.568512pt, -191.1721pt)
            -- (-6.568512pt, -191.1721pt)
            -- (-6.568512pt, -191.1721pt) .. controls (-6.052179pt, -189.9327pt) and (-3.057178pt, -189.8295pt) .. (2.313154pt, -190.9655pt)
            -- (2.313154pt, -190.9655pt)
            -- (2.313154pt, -190.9655pt)
            -- (2.313154pt, -190.9655pt) .. controls (13.15732pt, -192.7212pt) and (25.03399pt, -193.6507pt) .. (38.14982pt, -193.6507pt)
            -- (38.14982pt, -193.6507pt)
            -- (38.14982pt, -193.6507pt)
            -- (38.14982pt, -193.6507pt) .. controls (50.64649pt, -193.6507pt) and (69.54565pt, -192.7212pt) .. (94.84816pt, -190.9655pt)
            -- (94.84816pt, -190.9655pt)
            -- (94.84816pt, -190.9655pt)
            -- (94.84816pt, -190.9655pt) .. controls (97.63658pt, -190.1393pt) and (99.80541pt, -189.6229pt) .. (101.6643pt, -188.9pt) -- cycle
            ;
            \filldraw[blue][nonzero rule]
            (147.6667pt, -147.3834pt) .. controls (143.9487pt, -144.5949pt) and (138.5783pt, -141.8064pt) .. (131.4525pt, -139.1213pt)
            -- (131.4525pt, -139.1213pt)
            -- (131.4525pt, -139.1213pt)
            -- (131.4525pt, -139.1213pt) .. controls (126.9084pt, -137.3656pt) and (124.8428pt, -135.8164pt) .. (125.3593pt, -134.5771pt)
            -- (125.3593pt, -134.5771pt)
            -- (125.3593pt, -134.5771pt)
            -- (125.3593pt, -134.5771pt) .. controls (125.6691pt, -133.0279pt) and (128.8707pt, -132.0984pt) .. (134.7576pt, -131.9952pt)
            -- (134.7576pt, -131.9952pt)
            -- (134.7576pt, -131.9952pt)
            -- (134.7576pt, -131.9952pt) .. controls (139.5083pt, -132.2018pt) and (144.4659pt, -133.028pt) .. (149.7326pt, -134.2673pt)
            -- (149.7326pt, -134.2673pt)
            -- (149.7326pt, -134.2673pt)
            -- (149.7326pt, -134.2673pt) .. controls (152.8308pt, -135.1968pt) and (157.2718pt, -136.4361pt) .. (163.1584pt, -138.295pt)
            -- (163.1584pt, -138.295pt)
            -- (163.6748pt, -138.5016pt)
            -- (163.6748pt, -138.5016pt) .. controls (167.0829pt, -139.5343pt) and (169.2518pt, -140.7737pt) .. (170.0779pt, -142.2195pt)
            -- (170.0779pt, -142.2195pt)
            -- (170.0779pt, -142.2195pt)
            -- (170.0779pt, -142.2195pt) .. controls (170.5943pt, -143.149pt) and (170.5943pt, -144.8014pt) .. (170.0779pt, -147.28pt)
            -- (170.0779pt, -147.28pt)
            -- (169.8714pt, -151.8242pt)
            -- (169.8714pt, -151.8242pt)
            -- (169.6648pt, -242.9158pt)
            -- (169.6648pt, -242.9158pt)
            -- (183.0907pt, -242.0896pt)
            -- (183.0907pt, -242.0896pt)
            -- (183.0907pt, -242.0896pt)
            -- (183.0907pt, -242.0896pt) .. controls (185.1562pt, -241.7798pt) and (186.8086pt, -241.1601pt) .. (188.1512pt, -240.5405pt)
            -- (188.1512pt, -240.5405pt)
            -- (188.1512pt, -240.5405pt)
            -- (188.1512pt, -240.5405pt) .. controls (189.0807pt, -240.2306pt) and (190.1134pt, -239.5077pt) .. (191.456pt, -238.475pt)
            -- (191.456pt, -238.475pt)
            -- (191.456pt, -238.475pt)
            -- (191.456pt, -238.475pt) .. controls (193.315pt, -237.2356pt) and (195.1739pt, -236.4095pt) .. (197.0329pt, -235.893pt)
            -- (197.0329pt, -235.893pt)
            -- (197.0329pt, -235.893pt)
            -- (197.0329pt, -235.893pt) .. controls (200.3377pt, -234.9635pt) and (204.7787pt, -234.757pt) .. (210.7687pt, -235.1701pt)
            -- (210.7687pt, -235.1701pt)
            -- (210.7687pt, -235.1701pt)
            -- (210.7687pt, -235.1701pt) .. controls (214.0736pt, -235.3767pt) and (216.6554pt, -236.2029pt) .. (218.6176pt, -237.4422pt)
            -- (218.6176pt, -237.4422pt)
            -- (218.6176pt, -237.4422pt)
            -- (218.6176pt, -237.4422pt) .. controls (220.4766pt, -238.6815pt) and (221.6126pt, -240.1273pt) .. (221.716pt, -241.7798pt)
            -- (221.716pt, -241.7798pt)
            -- (221.716pt, -241.7798pt)
            -- (221.716pt, -241.7798pt) .. controls (221.9225pt, -243.5354pt) and (221.3029pt, -244.9814pt) .. (219.9602pt, -246.1174pt)
            -- (219.9602pt, -246.1174pt)
            -- (219.9602pt, -246.1174pt)
            -- (219.9602pt, -246.1174pt) .. controls (218.4111pt, -247.6665pt) and (216.3457pt, -248.6993pt) .. (213.867pt, -249.0091pt)
            -- (213.867pt, -249.0091pt)
            -- (169.6645pt, -249.732pt)
            -- (169.6645pt, -249.732pt) .. controls (169.458pt, -266.3595pt) and (169.0448pt, -278.8562pt) .. (168.1153pt, -287.3245pt)
            -- (168.1153pt, -287.3245pt)
            -- (168.1153pt, -287.3245pt)
            -- (168.1153pt, -287.3245pt) .. controls (167.4957pt, -294.244pt) and (166.3596pt, -299.8212pt) .. (165.0171pt, -304.1587pt)
            -- (165.0171pt, -304.1587pt)
            -- (165.0171pt, -304.1587pt)
            -- (165.0171pt, -304.1587pt) .. controls (162.4351pt, -309.7356pt) and (160.1631pt, -312.627pt) .. (157.8911pt, -313.0404pt)
            -- (157.8911pt, -313.0404pt)
            -- (157.8911pt, -313.0404pt)
            -- (157.8911pt, -313.0404pt) .. controls (155.1026pt, -313.3502pt) and (153.8632pt, -309.4257pt) .. (153.8632pt, -301.4737pt)
            -- (153.8632pt, -301.4737pt)
            -- (153.8632pt, -301.4737pt)
            -- (153.8632pt, -301.4737pt)
            -- (153.8632pt, -155.132pt)
            -- (153.8632pt, -155.132pt)
            -- (153.8632pt, -155.132pt)
            -- (153.8632pt, -155.132pt) .. controls (153.4501pt, -152.7567pt) and (151.3846pt, -149.9682pt) .. (147.6667pt, -147.3864pt) -- cycle
            ;
            \draw[white,line width=1.111111pt]
            (147.6667pt, -147.3834pt) .. controls (143.9487pt, -144.5949pt) and (138.5783pt, -141.8064pt) .. (131.4525pt, -139.1213pt)
            -- (131.4525pt, -139.1213pt)
            -- (131.4525pt, -139.1213pt)
            -- (131.4525pt, -139.1213pt) .. controls (126.9084pt, -137.3656pt) and (124.8428pt, -135.8164pt) .. (125.3593pt, -134.5771pt)
            -- (125.3593pt, -134.5771pt)
            -- (125.3593pt, -134.5771pt)
            -- (125.3593pt, -134.5771pt) .. controls (125.6691pt, -133.0279pt) and (128.8707pt, -132.0984pt) .. (134.7576pt, -131.9952pt)
            -- (134.7576pt, -131.9952pt)
            -- (134.7576pt, -131.9952pt)
            -- (134.7576pt, -131.9952pt) .. controls (139.5083pt, -132.2018pt) and (144.4659pt, -133.028pt) .. (149.7326pt, -134.2673pt)
            -- (149.7326pt, -134.2673pt)
            -- (149.7326pt, -134.2673pt)
            -- (149.7326pt, -134.2673pt) .. controls (152.8308pt, -135.1968pt) and (157.2718pt, -136.4361pt) .. (163.1584pt, -138.295pt)
            -- (163.1584pt, -138.295pt)
            -- (163.6748pt, -138.5016pt)
            -- (163.6748pt, -138.5016pt) .. controls (167.0829pt, -139.5343pt) and (169.2518pt, -140.7737pt) .. (170.0779pt, -142.2195pt)
            -- (170.0779pt, -142.2195pt)
            -- (170.0779pt, -142.2195pt)
            -- (170.0779pt, -142.2195pt) .. controls (170.5943pt, -143.149pt) and (170.5943pt, -144.8014pt) .. (170.0779pt, -147.28pt)
            -- (170.0779pt, -147.28pt)
            -- (169.8714pt, -151.8242pt)
            -- (169.8714pt, -151.8242pt)
            -- (169.6648pt, -242.9158pt)
            -- (169.6648pt, -242.9158pt)
            -- (183.0907pt, -242.0896pt)
            -- (183.0907pt, -242.0896pt)
            -- (183.0907pt, -242.0896pt)
            -- (183.0907pt, -242.0896pt) .. controls (185.1562pt, -241.7798pt) and (186.8086pt, -241.1601pt) .. (188.1512pt, -240.5405pt)
            -- (188.1512pt, -240.5405pt)
            -- (188.1512pt, -240.5405pt)
            -- (188.1512pt, -240.5405pt) .. controls (189.0807pt, -240.2306pt) and (190.1134pt, -239.5077pt) .. (191.456pt, -238.475pt)
            -- (191.456pt, -238.475pt)
            -- (191.456pt, -238.475pt)
            -- (191.456pt, -238.475pt) .. controls (193.315pt, -237.2356pt) and (195.1739pt, -236.4095pt) .. (197.0329pt, -235.893pt)
            -- (197.0329pt, -235.893pt)
            -- (197.0329pt, -235.893pt)
            -- (197.0329pt, -235.893pt) .. controls (200.3377pt, -234.9635pt) and (204.7787pt, -234.757pt) .. (210.7687pt, -235.1701pt)
            -- (210.7687pt, -235.1701pt)
            -- (210.7687pt, -235.1701pt)
            -- (210.7687pt, -235.1701pt) .. controls (214.0736pt, -235.3767pt) and (216.6554pt, -236.2029pt) .. (218.6176pt, -237.4422pt)
            -- (218.6176pt, -237.4422pt)
            -- (218.6176pt, -237.4422pt)
            -- (218.6176pt, -237.4422pt) .. controls (220.4766pt, -238.6815pt) and (221.6126pt, -240.1273pt) .. (221.716pt, -241.7798pt)
            -- (221.716pt, -241.7798pt)
            -- (221.716pt, -241.7798pt)
            -- (221.716pt, -241.7798pt) .. controls (221.9225pt, -243.5354pt) and (221.3029pt, -244.9814pt) .. (219.9602pt, -246.1174pt)
            -- (219.9602pt, -246.1174pt)
            -- (219.9602pt, -246.1174pt)
            -- (219.9602pt, -246.1174pt) .. controls (218.4111pt, -247.6665pt) and (216.3457pt, -248.6993pt) .. (213.867pt, -249.0091pt)
            -- (213.867pt, -249.0091pt)
            -- (169.6645pt, -249.732pt)
            -- (169.6645pt, -249.732pt) .. controls (169.458pt, -266.3595pt) and (169.0448pt, -278.8562pt) .. (168.1153pt, -287.3245pt)
            -- (168.1153pt, -287.3245pt)
            -- (168.1153pt, -287.3245pt)
            -- (168.1153pt, -287.3245pt) .. controls (167.4957pt, -294.244pt) and (166.3596pt, -299.8212pt) .. (165.0171pt, -304.1587pt)
            -- (165.0171pt, -304.1587pt)
            -- (165.0171pt, -304.1587pt)
            -- (165.0171pt, -304.1587pt) .. controls (162.4351pt, -309.7356pt) and (160.1631pt, -312.627pt) .. (157.8911pt, -313.0404pt)
            -- (157.8911pt, -313.0404pt)
            -- (157.8911pt, -313.0404pt)
            -- (157.8911pt, -313.0404pt) .. controls (155.1026pt, -313.3502pt) and (153.8632pt, -309.4257pt) .. (153.8632pt, -301.4737pt)
            -- (153.8632pt, -301.4737pt)
            -- (153.8632pt, -301.4737pt)
            -- (153.8632pt, -301.4737pt)
            -- (153.8632pt, -155.132pt)
            -- (153.8632pt, -155.132pt)
            -- (153.8632pt, -155.132pt)
            -- (153.8632pt, -155.132pt) .. controls (153.4501pt, -152.7567pt) and (151.3846pt, -149.9682pt) .. (147.6667pt, -147.3864pt) -- cycle
            ;
            \filldraw[blue][nonzero rule]
            (434.5334pt, -222.975pt) .. controls (436.0826pt, -222.4586pt) and (438.148pt, -221.6324pt) .. (440.6266pt, -220.7029pt)
            -- (440.6266pt, -220.7029pt)
            -- (440.6266pt, -220.7029pt)
            -- (440.6266pt, -220.7029pt) .. controls (443.2085pt, -219.3604pt) and (445.5839pt, -218.5341pt) .. (447.9592pt, -218.121pt)
            -- (447.9592pt, -218.121pt)
            -- (447.9592pt, -218.121pt)
            -- (447.9592pt, -218.121pt) .. controls (451.3673pt, -217.5014pt) and (456.2213pt, -217.6046pt) .. (462.6242pt, -218.3276pt)
            -- (462.6242pt, -218.3276pt)
            -- (462.6242pt, -218.3276pt)
            -- (462.6242pt, -218.3276pt) .. controls (466.8586pt, -218.6374pt) and (470.2666pt, -219.6702pt) .. (473.055pt, -221.4258pt)
            -- (473.055pt, -221.4258pt)
            -- (473.055pt, -221.4258pt)
            -- (473.055pt, -221.4258pt) .. controls (475.2239pt, -222.7684pt) and (476.4631pt, -224.4208pt) .. (476.6697pt, -226.1765pt)
            -- (476.6697pt, -226.1765pt)
            -- (476.6697pt, -226.1765pt)
            -- (476.6697pt, -226.1765pt) .. controls (476.8763pt, -228.242pt) and (475.7402pt, -229.7912pt) .. (473.5715pt, -230.7207pt)
            -- (473.5715pt, -230.7207pt)
            -- (473.5715pt, -230.7207pt)
            -- (473.5715pt, -230.7207pt) .. controls (470.9895pt, -231.96pt) and (467.6847pt, -232.3731pt) .. (463.7607pt, -232.0633pt)
            -- (463.7607pt, -232.0633pt)
            -- (463.7607pt, -232.0633pt)
            -- (463.7607pt, -232.0633pt) .. controls (446.204pt, -231.7534pt) and (415.2206pt, -232.0633pt) .. (370.8106pt, -233.096pt)
            -- (370.8106pt, -233.096pt)
            -- (370.8106pt, -233.096pt)
            -- (370.8106pt, -233.096pt) .. controls (325.5757pt, -234.0255pt) and (300.0665pt, -234.955pt) .. (293.5598pt, -236.1942pt)
            -- (293.5598pt, -236.1942pt)
            -- (293.5598pt, -236.1942pt)
            -- (293.5598pt, -236.1942pt) .. controls (292.0107pt, -236.4008pt) and (290.4615pt, -236.7106pt) .. (289.0157pt, -237.227pt)
            -- (289.0157pt, -237.227pt)
            -- (289.0157pt, -237.227pt)
            -- (289.0157pt, -237.227pt) .. controls (288.0862pt, -237.5368pt) and (287.1567pt, -237.9499pt) .. (285.9174pt, -238.5696pt)
            -- (285.9174pt, -238.5696pt)
            -- (285.9174pt, -238.5696pt)
            -- (285.9174pt, -238.5696pt) .. controls (282.8191pt, -239.9122pt) and (279.7209pt, -240.3253pt) .. (276.519pt, -239.6023pt)
            -- (276.519pt, -239.6023pt)
            -- (276.519pt, -239.6023pt)
            -- (276.519pt, -239.6023pt) .. controls (272.4913pt, -238.6728pt) and (264.229pt, -235.5746pt) .. (251.7324pt, -229.9973pt)
            -- (251.7324pt, -229.9973pt)
            -- (251.7324pt, -229.9973pt)
            -- (251.7324pt, -229.9973pt) .. controls (246.8784pt, -227.2088pt) and (244.9161pt, -225.3499pt) .. (245.7424pt, -224.1106pt)
            -- (245.7424pt, -224.1106pt)
            -- (245.7424pt, -224.1106pt)
            -- (245.7424pt, -224.1106pt) .. controls (246.6718pt, -222.8712pt) and (248.9439pt, -222.768pt) .. (252.5585pt, -223.5942pt)
            -- (252.5585pt, -223.5942pt)
            -- (252.5585pt, -223.5942pt)
            -- (252.5585pt, -223.5942pt) .. controls (270.4252pt, -226.1761pt) and (294.3852pt, -227.3121pt) .. (324.5419pt, -227.3121pt)
            -- (324.5419pt, -227.3121pt)
            -- (324.5419pt, -227.3121pt)
            -- (324.5419pt, -227.3121pt) .. controls (344.5777pt, -227.1056pt) and (377.9352pt, -226.1761pt) .. (424.3086pt, -224.4204pt)
            -- (424.3086pt, -224.4204pt)
            -- (424.3086pt, -224.4204pt)
            -- (424.3086pt, -224.4204pt) .. controls (428.4395pt, -224.3171pt) and (431.7444pt, -223.8007pt) .. (434.5327pt, -222.9745pt) -- cycle
            ;
            \draw[white,line width=1.111111pt]
            (434.5334pt, -222.975pt) .. controls (436.0826pt, -222.4586pt) and (438.148pt, -221.6324pt) .. (440.6266pt, -220.7029pt)
            -- (440.6266pt, -220.7029pt)
            -- (440.6266pt, -220.7029pt)
            -- (440.6266pt, -220.7029pt) .. controls (443.2085pt, -219.3604pt) and (445.5839pt, -218.5341pt) .. (447.9592pt, -218.121pt)
            -- (447.9592pt, -218.121pt)
            -- (447.9592pt, -218.121pt)
            -- (447.9592pt, -218.121pt) .. controls (451.3673pt, -217.5014pt) and (456.2213pt, -217.6046pt) .. (462.6242pt, -218.3276pt)
            -- (462.6242pt, -218.3276pt)
            -- (462.6242pt, -218.3276pt)
            -- (462.6242pt, -218.3276pt) .. controls (466.8586pt, -218.6374pt) and (470.2666pt, -219.6702pt) .. (473.055pt, -221.4258pt)
            -- (473.055pt, -221.4258pt)
            -- (473.055pt, -221.4258pt)
            -- (473.055pt, -221.4258pt) .. controls (475.2239pt, -222.7684pt) and (476.4631pt, -224.4208pt) .. (476.6697pt, -226.1765pt)
            -- (476.6697pt, -226.1765pt)
            -- (476.6697pt, -226.1765pt)
            -- (476.6697pt, -226.1765pt) .. controls (476.8763pt, -228.242pt) and (475.7402pt, -229.7912pt) .. (473.5715pt, -230.7207pt)
            -- (473.5715pt, -230.7207pt)
            -- (473.5715pt, -230.7207pt)
            -- (473.5715pt, -230.7207pt) .. controls (470.9895pt, -231.96pt) and (467.6847pt, -232.3731pt) .. (463.7607pt, -232.0633pt)
            -- (463.7607pt, -232.0633pt)
            -- (463.7607pt, -232.0633pt)
            -- (463.7607pt, -232.0633pt) .. controls (446.204pt, -231.7534pt) and (415.2206pt, -232.0633pt) .. (370.8106pt, -233.096pt)
            -- (370.8106pt, -233.096pt)
            -- (370.8106pt, -233.096pt)
            -- (370.8106pt, -233.096pt) .. controls (325.5757pt, -234.0255pt) and (300.0665pt, -234.955pt) .. (293.5598pt, -236.1942pt)
            -- (293.5598pt, -236.1942pt)
            -- (293.5598pt, -236.1942pt)
            -- (293.5598pt, -236.1942pt) .. controls (292.0107pt, -236.4008pt) and (290.4615pt, -236.7106pt) .. (289.0157pt, -237.227pt)
            -- (289.0157pt, -237.227pt)
            -- (289.0157pt, -237.227pt)
            -- (289.0157pt, -237.227pt) .. controls (288.0862pt, -237.5368pt) and (287.1567pt, -237.9499pt) .. (285.9174pt, -238.5696pt)
            -- (285.9174pt, -238.5696pt)
            -- (285.9174pt, -238.5696pt)
            -- (285.9174pt, -238.5696pt) .. controls (282.8191pt, -239.9122pt) and (279.7209pt, -240.3253pt) .. (276.519pt, -239.6023pt)
            -- (276.519pt, -239.6023pt)
            -- (276.519pt, -239.6023pt)
            -- (276.519pt, -239.6023pt) .. controls (272.4913pt, -238.6728pt) and (264.229pt, -235.5746pt) .. (251.7324pt, -229.9973pt)
            -- (251.7324pt, -229.9973pt)
            -- (251.7324pt, -229.9973pt)
            -- (251.7324pt, -229.9973pt) .. controls (246.8784pt, -227.2088pt) and (244.9161pt, -225.3499pt) .. (245.7424pt, -224.1106pt)
            -- (245.7424pt, -224.1106pt)
            -- (245.7424pt, -224.1106pt)
            -- (245.7424pt, -224.1106pt) .. controls (246.6718pt, -222.8712pt) and (248.9439pt, -222.768pt) .. (252.5585pt, -223.5942pt)
            -- (252.5585pt, -223.5942pt)
            -- (252.5585pt, -223.5942pt)
            -- (252.5585pt, -223.5942pt) .. controls (270.4252pt, -226.1761pt) and (294.3852pt, -227.3121pt) .. (324.5419pt, -227.3121pt)
            -- (324.5419pt, -227.3121pt)
            -- (324.5419pt, -227.3121pt)
            -- (324.5419pt, -227.3121pt) .. controls (344.5777pt, -227.1056pt) and (377.9352pt, -226.1761pt) .. (424.3086pt, -224.4204pt)
            -- (424.3086pt, -224.4204pt)
            -- (424.3086pt, -224.4204pt)
            -- (424.3086pt, -224.4204pt) .. controls (428.4395pt, -224.3171pt) and (431.7444pt, -223.8007pt) .. (434.5327pt, -222.9745pt) -- cycle
            ;
            \node at (65.8077pt,-149.1877pt) {\Large x};
            \node at (161.641pt,-129.1877pt) {\Large а};
            \node at (119.141pt,-349.1877pt) {\Large н};
            \node at (357.4231pt,-145.021pt) {\Large г/к};
            \node at (353.3077pt,-221.6877pt) {\Large ы};
            \node at (360.7308pt,-345.021pt) {\Large р/ль};
        \end{tikzpicture}
    \end{figure}\noindent
    И вот что вы хотите получить, когда просите длину строки для корейского текста?\\
    Ну, хорошо, а как жить-то с этим? А на самом деле вам не бывает так часто нужно брать длину и обращаться по индексу. Вам бывает нужна конкатенация или поиск по строке. И это работает очень хорошо (поскольку \Verb|UTF-8|, например, специально помечает trailing-октеты особым началом). Но иногда, когда вы пишете растеризацию, например, то да, вам придётся страдать, увы и ах.
    \subparagraph{Поиск подстроки.}
    Кстати. По поводу поиска подстрок. Когда нам дали \r{A}, мы должны её сопоставлять только с конкретным символом или с любой фигнёй? Вообще если с любым возможным A с кружком, то тут нужна \href{https://en.wikipedia.org/wiki/Unicode_equivalence#Normalization}{нормализация}, но на самом деле, возможно, вы хотите делать соответствие ещё и <<ё>> и <<е>>. Короче, если вы делаете user-friendly, то у вас всё грустно.
    \subparagraph{Приведение к верхнему/нижнему регистру.}
    Ещё у любого Юникода есть проблемы с приведением в нижний и верхний регистр. Например, вот у буквы <<\Verb|i|>> какая заглавная? <<\Verb|I|>>? Ну, в английском да. А в турецком есть строчная \Verb|ı| (<<\Verb|i| без точки>>) и заглавная <<\Verb|İ|>> (<<\Verb|I| с точкой>>).\\
    Есть греческая буква <<сигма>>, у которой есть две строчные версии: одна встречается на концах слов (<<\Verb|ς|>>), другая~--- в серединах (<<\Verb|σ|>>), и поэтому для приведения в нижний регистр надо смотреть на границы слов.\\
    Есть голландский, в котором есть диграф \Verb|ij|, и его с точки зрения грамматики надо капитализировать всей парой целиком (несмотря на то, что обычно его пишут именно как два символа, а не как диграф, и, более того, это Юникод не рекомендует этот диграф).\\
    Мораль: капитализировать буквы~--- порочное занятие. Большие и маленькие буквы вообще встречаются в не таком большом количестве систем письма. Вот, грузины живут без регистра вообще, и всё у них хорошо.
    \subparagraph{Лексикографическая сортировка.}
    Ещё одна задача: лексикографическая сортировка. Тоже, на самом деле, очень странное занятие. Буква <<\Verb|Ё|>> находится до всех заглавных букв, а <<\Verb|ё|>>~--- после. Да более того, в разных языках разные буквы могут стоять в разных местах. В немецком языке есть умляуты ({\"A}, {\"O}, {\"U}). Они должны сортироваться так, как будто они~--- одно и то же. А в эстонском эти же буквы находятся в конце алфавита.
    \paragraph{Взаимодействие с операционными системами.}
    Пока вы сидите на Linux'е, там почти всё живёт с UTF-8, и всё у вас хорошо. Есть исключения (QT, например, использует UTF-16, так как она была создана давно, когда Юникод был 16-битным). Впрочем, в Linux можно использовать другую восьмибитную кодировку (при помощи переменной окружения \mintinline{bash}{LANG}), но некоторые программы полностью это игнорирует, считая, что у нас всё в UTF-8.\\
    Про MacOS так много не расскажем, но там тоже есть какое-то API с UTF-8, какое-то с UTF-16, но тут у нас нет столько информации, так что не будем больше ничего говорить.\\
    А вот с Windows ситуация интересная. Она внутри себя использует UTF-16. Но у них всё ещё есть совместимость с восьмибитными кодировками, правда, долгое время нельзя было в качестве неё поставить UTF-8. И приводило это к совершенно упоротым эффектам: если вы пользуетесь набором функций с 8-битной кодировкой (которая 1251), то не существует способа конвертировать, например, название файла, так, чтобы оно конвертировалось в то, что вам хочется. Поэтому Microsoft советовали использовать их функции формата \mintinline{c++}{_wfopen}, с которой всё хорошо, но тогда программа теряет в платформонезависимости. Поэтому многе чуваки делали свои библиотеки (см. Boost.Nowide), которые на Windows конвертировали строки в 16 бит и вызывали \mintinline{c++}{_wfopen}, а на Linux делали просто \mintinline{c++}{fopen}. В Windows 10, впрочем, таких приколов нет, так что вам с этим заморачиваться не надо.\\
    Второй прикол в Windows~--- наличие двух разных восьмибитных кодировок. Первая~--- ACP (ANSI code page) (для русской Windows~--- 1251),  вторая~--- OEMCP (OEM code page) (для русской Windows~--- 866). И разные восьмибитные функции работали в разных кодировках. Поэтому получив строку из одной функции и отдав в другую, вы могли увидеть, что строка попортилась. Что ещё интереснее, некоторые функции могут использовать одно или другое (функция \mintinline{c++}{SetFileApisToOEM} переключает кодировку для работы с файлами, например).\\
    Мораль: на Windows ставьте обеими текущими кодировками UTF-8 и живите счастливо. А если уж вам нужно что-то старое, то вам можно только посочувствовать (но вообще выберите одну кодировку для своей программы и при необходимости конвертируйте туда-обратно).
    \subparagraph{Имена файлов.}
    Впрочем, это не поможет вам делать \mintinline{c++}{fopen}'ы. Потому что имена файлов во многих ОС (и Windows, и Linux) не обязаны являться корректными строками. В Linux, как мы знаем, файлы могут содержать любые символы, кроме \mintinline{c++}{'\0'} и \mintinline{c++}{'/'}. Например, файл может быть назван \mintinline{c++}{"Ha\bello"}, и многие утилиты будут выводить название файла как \mintinline{c++}{"Hello"}. И это то ладно. У нас может быть некорректные октеты (head octet без tail octet'а или наоборот или ещё чего). В Windows ситуация такая же: у вас может быть первый символ суррогатной пары без второго. Мораль: не пытайтесь преобразовать путь в строку и обратно, надеясь, что он не испортится. И не все пути можно нормально в строку преобразовать вообще.\\
    А теперь вспомним, что имена файлов на Windows не зависят от регистра. Некорректные UTF-16 строки, не зависящие от регистра. Это, простите, что за срань? А ситуация такая: правило сопоставления маленьких букв большим прошито в файловой системе NTFS. На NTFS создаётся файлик (называется UpCase), в котором и хранится информация о сопоставлении маленьких букв большим. И в разных файловых системах (а значит и в разных разделах вашего компьютера) это сопоставление может быть разным. Да и более того. В EXT4 вы можете повесить себе на каталог опцию, чтобы в нём имена были регистронезависимы, а потом и в Windows~--- обратную опцию.
    \section{Многопоточность.}
    Многопоточность в терминах C++ довольно важна многопоточность не только для того, чтобы знать, как она есть, но и, например, чтобы понимать, почему аллокаторы или shared pointer работают так, как работают, потому что сильно связаны с дизайном многопоточки.\\
    Зачем многопоточка, можно понять из курса АрхЭВМ и OS-lite. Но чего там нет, так это то, что вообще для использования ядер не нужно использовать потоки. Мы можем просто запускать процессы несколько раз (так компиляторы работают, например).
    \paragraph{Создание и завершение потоков на примерах.}
    \begin{minted}{c++}
        #include <iostream>
        #include <thread>

        int main()
        {
            std::thread th([]
            {
                std::cout << "Hello, world!\n";
            });
            th.join();
        }
    \end{minted}
    В стандартной библиотеке есть класс \mintinline{c++}{thread}. В конструкторе он стартует поток и потом можно дождаться, пока он закончит (\mintinline{c++}{join}). Помимо к ней есть операция \mintinline{c++}{detach}. Она отвязывает наш \mintinline{c++}{thread} от потока ОС, но поток ОС никто не завершает. Такое бывает нужно очень редко. Например, вот такая программа просто некорректна:
    \begin{minted}{c++}
        #include <iostream>
        #include <thread>
        
        int main()
        {
            std::thread th([]
            {
                std::cout << "Hello, world!\n";
            });
            th.detach();
        }
    \end{minted}
    Поток быдет выполняться тогда, когда мы уже будем при выходе из программы вызывать деструкторы. В частности, деструкторы \mintinline{c++}{std::cout}. И отвязанный поток будет писать в то место, чего нет.\\
    Хорошо, а если мы не напишем ни \mintinline{c++}{join}, ни \mintinline{c++}{detach}, что будет? Ну, будет деструктор \mintinline{c++}{thread}, объективно. А что там? А там \mintinline{c++}{std::terminate}. Возникает вопрос: зачем? А потому что у нас бывают потоки, которые работают бесконечно долго. Поэтому по умолчанию сделать \mintinline{c++}{join}~--- не очень затея. Но если вы всё же хотите \mintinline{c++}{join} по-умолчанию, то ваш выбор~--- \mintinline{c++}{std::jthread}. Он в деструкторе делает \mintinline{c++}{join}. Но на самом деле у него ещё есть способ сказать потоку <<так, ты это, выходи пожалуйста>>, и после этого делает \mintinline{c++}{join}.\\
    Ну, хорошо, а если поток не хочет с вами кооперироваться и выполнять вашу просьбу о завершении? Тогда вы проиграли. В C++ никак нельзя заставить поток умереть, потому что иначе могут быть неконсистентные данные. Несмотря на то, что в операционных системах есть какие-нибудь операции по типу TerminateThread, на всех них написано <<опасная функция, которую стоит использовать в совсем экстренных случаях>>. Если вы убьёте поток в критической секции, вы проиграли. Если вы убили поток в тот момент, когда он выделял память, то вы совсем больше не сможете выделять память в вашей программе.
    \paragraph{Проблемы в использовании потоков и способы с ними жить.}
    \subparagraph{Гоночки.}
    Пусть мы делаем банковское приложение и у нас есть 10000 счетов. И мы хотим сделать операцию \mintinline{c++}{transfer}, которая переводит заданную сумму со счёта на счёт.
    \begin{minted}{c++}
        std::array<uint32_t, 10'000> accounts;

        void transfer(size_t from, size_t to, uint32_t amount)
        {
            if (accounts[from] < amount)
                throw std::runtime_error("insufficient funds");

            accounts[from] -= amount;
            accounts[to] += amount;
        }
    \end{minted}
    Чудесная функция для однопоточного случая. И даже если не иметь проблем с \mintinline{c++}{+=} и \mintinline{c++}{-=}, то мы можем переводить деньги с одного счёта на два разных, и тогда мы можем два раза подряд проверить, потом два раза вычесть. А денег изначально только на один перевод хватало. Ой.\\
    Ещё мы не знаем, как работает \mintinline{c++}{+=}. Это может быть единая неделимая операция, а может быть сначала чтение, потом запись. И тут у нас ещё одна гонка: когда мы сначала читаем два раза, потом оба вычитают и записывают. И эффект от одного \mintinline{c++}{+=} не применяется.\\
    Это чудо называется \textbf{состояние гонки}, \textbf{race condition}. Если воспринимать это чудо как псевдокод, если же написать это честно на C++, то это жёсткое UB.
    \subparagraph{\mintinline{c++}{std::mutex}.}
    Хто это такой? Это класс, поддерживающий две операции: \mintinline{c++}{lock} и \mintinline{c++}{unlock}. Первая ждёт, пока \mintinline{c++}{std::mutex} не разблокируют, после чего блокирует сам, вторая~--- разблокирует:
    \begin{minted}{c++}
        std::mutex accounts_mutex;
        std::array<uint32_t, 10'000> accounts;
        
        void transfer(size_t from, size_t to, uint32_t amount)
        {
            accounts_mutex.lock();

            if (accounts[from] < amount)
                    throw std::runtime_error("insufficient funds");
            
            accounts[from] -= amount;
            accounts[to] += amount;

            accounts_mutex.unlock();
        }
    \end{minted}
    Что важно понимать: \Verb|mutex| идеологически ассоциирован с данными, а не функциями. Если бы мы написали ещё какую-то операцию с \mintinline{c++}{accounts}, надо там тоже работать с \Verb|mutex|'ом.\\
    Что с данной программой не так? \mintinline{c++}{throw} не разблокирует \mintinline{c++}{std::mutex}. Потому что не RAII. Наше счастье, что в стандартной библиотеке есть RAII-шная обёртка: \mintinline{c++}{std::lock_guard}:
    \begin{minted}{c++}
        std::mutex accounts_mutex;
        std::array<uint32_t, 10'000> accounts;
        
        void transfer(size_t from, size_t to, uint32_t amount)
        {
            std::lock_guard<std::mutex> lock(accounts_mutex);
            
            if (accounts[from] < amount)
                throw std::runtime_error("insufficient funds");
            
            accounts[from] -= amount;
            accounts[to] += amount;
        }
    \end{minted}
    Кстати, \mintinline{c++}{std::lock_guard<std::mutex>} в данном коде можно заменить на просто \mintinline{c++}{std::lock_guard} (начиная с C++17). Это называется \href{https://en.cppreference.com/w/cpp/language/class_template_argument_deduction}{CTAD (class template argument deduction)}, но это сейчас не важно.\\
    Давайте вот ещё что скажем: у нас была хорошая однопоточная функция \mintinline{c++}{transfer}. А теперь её можно вызывать их разных потоков, но параллельной эта функция не стала. Не проблема ли это? Ну, разумеется, нет, если у нас программа не только \mintinline{c++}{transfer} делает, а ещё что-то делает, то всё остальное можно делать многопоточно, однопоточный у нас только \mintinline{c++}{transfer}~--- скорее всего, малая часть однопоточной программы.
    \subparagraph{Закон Амдала.}
    У нас есть части кода, которые параллелятся, и части, которые нет. И чем больше процент первого, тем больше ускорение программы мы можем получить. Если у нас 50\% программы можно распараллелить, то как много у нас потоков не было бы, ускорение больше чем вдвое мы не получим никак. Хотя на самом деле ст\'{о}ит ещё учитывать то, что чем больше у нас потоков, тем больше накладных расходов у нас есть.
    \subparagraph{Deadlock.}
    У нас однопоточный \mintinline{c++}{transfer}. Это плохо и совершенно не нужно. Давайте просто положим \mintinline{c++}{std::mutex} в account:
    \begin{minted}{c++}
        struct account
        {
            std::mutex m;
            uint32_t amount;
        };
        std::array<account, 10'000> accounts;
        
        void transfer(size_t from, size_t to, uint32_t amount)
        {
            std::lock_guard lock1(accounts[from].m);
            std::lock_guard lock2(accounts[to].m);
            
            if (accounts[from] < amount)
                throw std::runtime_error("insufficient funds");
            
            accounts[from] -= amount;
            accounts[to] += amount;
        }
    \end{minted}
    Здравствуйте, обедающие философы. Если у нас цикл из transfer'ов и каждый успеет взять первый нужный ему \Verb|mutex|, и будет ждать второго. Все стоят, ждут. Ничего нельзя сделать. \textbf{Deadlock} называется.\\
    Как решить? Ну, вот так:
    \begin{minted}{c++}
        void transfer(size_t from, size_t to, uint32_t amount)
        {
            std::lock_guard lock1(accounts[std::min(from, to)].m);
            std::lock_guard lock2(accounts[std::max(from, to)].m);
            
            if (accounts[from] < amount)
               throw std::runtime_error("insufficient funds");
            
            accounts[from] -= amount;
            accounts[to] += amount;
        }
    \end{minted}
    Почему такое корректно? Тут можно нарисовать граф, где вершины~--- \Verb|mutex|'ы, а рёбро есть, если в программе есть случай, когда мы взяли один \Verb|mutex| и пытаемся взять другой. Если в таком графе нет цикла, мы победили. И у нас его в нашем случае действительно нет.
    \subparagraph{\mintinline{c++}{std::recursive_mutex}.}
    Но жизнь~--- боль. Так как то написано, у нас UB. Когда поток уже владеет \mintinline{c++}{std::mutex}'ом и пытается получить его ещё раз, это UB. Поэтому
    \begin{minted}{c++}
        void transfer(size_t from, size_t to, uint32_t amount)
        {
            if (from == to)
                return;

            std::lock_guard lock1(accounts[std::min(from, to)].m);
            std::lock_guard lock2(accounts[std::max(from, to)].m);
            
            if (accounts[from] < amount)
                throw std::runtime_error("insufficient funds");
            
            accounts[from] -= amount;
            accounts[to] += amount;
        }
    \end{minted}
    И это в данном случае всё легко правится, но вообще, иногда нам очень хочется уметь брать \Verb|mutex| несколько раз, и в стандартной библиотеке есть такой вид \Verb|mutex|'ов: \mintinline{c++}{std::recursve_mutex}. И вообще в стандартной библиотеке есть \href{https://en.cppreference.com/w/cpp/thread#Mutual_exclusion}{много интересных \Verb|mutex|'ов}, и ещё больше есть в сторонних библиотеках.
    \paragraph{Другие примитивы синхронизации в попытках написать многопоточную очередь.}
    Представьте, что у нас есть какие-то многопоточные запросы, и мы хотим поддерживать очередь из них.
    \begin{minted}{c++}
        template <class T>
        struct concurrent_queue
        {
        private:
            std::mutex m;
            std::deque<T> queue;

        public:
            void push(T val)
            {
                std::lock_guard lock(m);
                queue.push_back(std::move(value));
            }

            bool empty() const
            {
                std::lock_guard lock(m);
                return queue.empty();
            }

            T pop()
            {
                std::lock_guard lock(m);
                T result = queue.back();
                queue.pop();
                return result;
            }
        };
    \end{minted}
    Нормально ли такое? Да нифига. Потому что мы не можем вызывать \mintinline{c++}{empty} и сразу после этого \mintinline{c++}{pop}. Потому что между этими вызовами у нас нет замка. Поэтому правильнее будет изменить интерфейс.
    \begin{minted}{c++}
        template <class T>
        struct concurrent_queue
        {
        private:
            std::mutex m;
            std::deque<T> queue;
            
        public:
            void push(T val)
            {
                std::lock_guard lock(m);
                queue.push_back(std::move(value));
            }

            std::optional<T> try_pop()
            {
                std::lock_guard lock(m);
                if (queue.empty())
                    return std::nullopt;
                std::optional<T> result = queue.back();
                queue.pop();
                return result;
            }
        };
    \end{minted}
    В чём тут ещё проблема? В том, что у нас есть чуваки, которые сидят и ждут, пока будут данные. Они не хотят писать \mintinline{c++}{while}, это активное ожидание. Давайте сделаем \mintinline{c++}{pop}, который ждёт.
    \subparagraph{\mintinline{c++}{std::condition_variable}.}
    Вот какая эта штука. У него есть 3 операции: \mintinline{c++}{wait}, \mintinline{c++}{notify_one} и \mintinline{c++}{notify_all}. Первая ждёт, вторая пробуждает одного ждущего, третья~--- пробуждает всех. Пока что наш код не будет компилироваться, но давайте всё равно его напишем:
    \begin{minted}{c++}
        template <class T>
        struct concurrent_queue
        {
        private:
            std::mutex m;
            std::deque<T> queue;
            std::condition_variable cv;
            
        public:
            void push(T val)
            {
                std::lock_guard lock(m);
                queue.push_back(std::move(value));
                cv.notify_one();
            }
            
            T pop()
            {
                std::lock_guard lock(m);
                if (queue.empty())
                   cv.wait();
                T result = queue.back();
                queue.pop();
                return result;
            }
        };
    \end{minted}
    Тут понятно какая проблема, мы спим с \mintinline{c++}{mutex}'ом. Исправляем:
    \begin{minted}{c++}
        T pop()
        {
            std::unique_lock lock(m); // Как lock_guard, но можно делать lock и unlock.
            if (queue.empty())
            {
                lock.unlock()
                cv.wait();
                lock.lock();
            }
            T result = queue.back();
            queue.pop();
            return result;
        }
    \end{minted}
    И тут уже сильно лучше, но если один поток пробудился и ещё не взял блокировку, а другой тем временем зашёл, увидел непустую очередь и опустошил её. И всё, мы проиграли. Поэтому вместо \mintinline{c++}{if}'а надо взять \mintinline{c++}{while}.
    \begin{minted}{c++}
        T pop()
        {
            std::unique_lock lock(m);
            while (queue.empty())
            {
                lock.unlock()
                cv.wait();
                lock.lock();
            }
            T result = queue.back();
            queue.pop();
            return result;
        }
    \end{minted}
    Кстати, есть ещё одна причина, почему \mintinline{c++}{while}: \href{https://en.wikipedia.org/wiki/Spurious_wakeup}{спонтанные пробуждения}. \mintinline{c++}{condition_variable} может сам внезапно пробудиться ни с чего.\\
    И эту проблемы мы починили, но ещё есть другая: если мы уже сделали \mintinline{c++}{unlock}, нам в это время сделали \mintinline{c++}{push}, но \mintinline{c++}{notify_one} произошёл до того, как мы стали ждать. И всё, мы ждём при непустой очереди. Поэтому \mintinline{c++}{wait} на самом деле принимает один аргумент: \mintinline{c++}{unique_lock}, чтобы сделать \mintinline{c++}{unlock} и \mintinline{c++}{wait} неделимо:
    \begin{minted}{c++}
        T pop()
        {
            std::unique_lock lock(m);
            while (queue.empty())
                cv.wait(lock);
            T result = queue.back();
            queue.pop();
            return result;
        }
    \end{minted}
    На самом деле такой паттерн с \mintinline{c++}{while}'ом настолько частый, что под это специальная перегрузка есть:
    \begin{minted}{c++}
        T pop()
        {
            std::unique_lock lock(m);
            cv.wait(lock, [&]{ return !queue.empty(); });
            T result = queue.back();
            queue.pop();
            return result;
        }
    \end{minted}
    \subparagraph{Thundering herd problem.}
    Общего развития ради: не надо использовать \mintinline{c++}{notify_all} там, где можно \mintinline{c++}{notify_one}. Такое даже название имеет: \href{https://en.wikipedia.org/wiki/Thundering_herd_problem}{Thundering herd problem}.
    \subparagraph{Worst practices.}
    Может показаться, что \mintinline{c++}{notify}~--- штука долгая, и её можно пытаться оптимизировать. Давайте не будем никого уведомлять, если очередь не была пуста.
    \begin{minted}{c++}
        void push(T val)
        {
            std::lock_guard lock(m);
            bool was_empty = queue.empty();
            queue.push_back(std::move(value));
            if (!was_empty)
               cv.notify_one();
        }
    \end{minted}
    Кто видит проблему? А она есть.\\
    Пусть у нас есть несколько спящих потоков на \mintinline{c++}{pop}'е. К ним приходит несколько \mintinline{c++}{push}'ей сразу. Первый уведомляет одного, остальные — нет, все спящие потоки, кроме одного, продолжат спать при непустой очереди.
    \subparagraph{Best practices.}
    Если производителей данных больше, чем потребителей, очередь может бесконечно расти. Давайте ненадо. Ну, тривиально правится: заводим ещё \mintinline{c++}{std::conditional_variable}, который будем ждать в \mintinline{c++}{push} и сообщать в \mintinline{c++}{pop}. Это, кстати, объясняет, зачем нам отдельно \Verb|mutex|'ы и отдельно \Verb|condition_variable|.
    \paragraph{Реализация.}
    Понятно, что для всего этого необходимы специальные инструкции со стороны процессора. А ещё что \Verb|mutex|'у, что \Verb|condition_variable|'у надо уметь засыпать, и это уже поддержка со стороны ОС.
    \subparagraph{Worst practices.}
    Во-первых, не надо делать \mintinline{c++}{std::this_thread::yield}. Никогда. Любой хоть сколько-нибудь продвинутый планировщик старается минимально мигрировать задачи между ядрами (кэши охлаждаются, например). Поэтому планировщики могут игнорировать \mintinline{c++}{yield}. Зачем эта функция существует~--- ничуть не для примитивов синхронизации, а только если вы знаете всё про планировщик и про приоритеты.\\
    А что использовать для реализации? То, что ожидает ОС, объективно. И то что разработчики ОС рекомендуют. В POSIX есть такая штука как \href{https://en.wikipedia.org/wiki/Futex}{futex}, и всё реализуются через него.
    \subparagraph{Busy wait/spinlock.}
    Может нам не надо идти в ядро для каждого \Verb|mutex|'а, может его только вот прямо сейчас отпустят? Такая стратегия называется spinlock, и обычно \mintinline{c++}{mutex}'ы реализуют как комбинацию этого и нормальных \Verb|mutex|'ов.\\
    Кстати, многие процессоры имеют в себе инструкции-подсказки для ОС (\href{https://www.felixcloutier.com/x86/pause}{\mintinline{nasm}{PAUSE} на x86}, например).
    \paragraph{Атомики.}
    Про это можно говорить очень много, но этим мы будем заниматься на специальном курсе про многопоточность.
    \subparagraph{Мотивация.}
    В прошлый раз у нас была программа с банковскими счетами. Там мы делали \Verb|mutex|'ы на каждый счёт. Мы помним, что у нас куча памяти тратится, возможно, стоило бы сделать что-то другое? А вот да: в процессоре чтения и записи даже из разных потоков как-то определены. Тогда почему в C++ не определено многопоточное поведение для встроенных типов? Ну, потому что на разных процессорах чтения и записи определены по-разному. И можно наблюдать самые разные эффекты, смотря в ассемблер.\\
    Например, поскольку процессор может переупорядочивать инструкции, он может переупорядочивать записи и чтения. И на разных процессорах можно получить самые разные мемы. Есть даже \href{http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.06.07c.pdf}{весёлая статейка}, в которой на 16 странице есть табличка о том, какие архитектуры что могут переупорядочивать. И эта табличка очень сильно упрощена, потому что почти все архитектуры имеют разные команды, которые позволяют разную степень переупорядочивания.\\
    Так вот, поэтому нельзя специфицировать многопоточное поведение для встроенных типах: когда процессор переупорядочит инструкции, ваше специфицирование вам же выйдет боком. Причём компилятор-то не знает, многопоточное ли у вас приложение, или нет, ему придётся использовать тяжёлые инструкции всегда.\\
    Чтение и запись~--- это, конечно, хорошо, но разве мы не хотим делать инкремент неделимо. То есть так, что весь остальной мир не видит промежуточных состояний: либо операция не началась, либо закончилась (это \textit{атомарностью} и называется). Такие операции, кстати, и в процессорах нередко есть (так атомарный инкремент называется \mintinline{nasm}{lock add} на x86). И вообще в \mintinline{c++}{std::atomic} есть много весёлых сложных операций, например \href{https://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange}{обмен со сравнением}.\\
    Кстати, ещё важный момент: в атомарности очень важно выравнивание. В процессоре нельзя атомарно поменять значение, лежащее на границе кэш-линий. Почти во всех архитектурах. В x86 можно, но это работает медленно (существенно замедляет всю систему). Если вам зачем-то это нужно, то знайте, что это называется split lock'ами, почитать про них можно \href{https://lwn.net/Articles/790464/}{тут}, но оно вам таки не нужно.
    \subparagraph{Пример.}
    Давайте переделаем наш пример с банковскими счетами и переделаем его на атомарные операции.
    \begin{minted}{c++}
        std::array<std::atomic<int32_t>>, 10'000> accounts;

        void transfer(size_t from, size_t to, uint32_t amount)
        {
            if (from == to)
                return;
            
            if (accounts[from] < amount)
                throw std::runtime_error("insufficient funds");
            
            accounts[from] -= amount;
            accounts[to] += amount;
        }
    \end{minted}
    Пока что оно не работает. По понятным причинам, нам нужно не только атомарно делать \mintinline{c++}{-=}, нам надо атомарно сделать проверку и вычитание. Ну, это можно. Есть очень весёлая операция \mintinline{c++}{compare_exchange}, которая сравнивает значение атомарной переменной с заданным и если совпадает, то происходит присваивание:
    \begin{minted}{c++}
        std::array<std::atomic<int32_t>>, 10'000> accounts;
        
        void transfer(size_t from, size_t to, uint32_t amount)
        {
            if (from == to)
                return;
            
            int32_t old = accounts[from];
            do
            {
                if (old < amount)
                    throw std::runtime_error("insufficient funds");
            } while (!accounts[from].compare_exchange_weak(old, old - amount))

            accounts[to] += amount;
        }
    \end{minted}
    То есть мы берём значение, проверяем, если оно не поменялось, вычитаем. Иначе в переменную \mintinline{c++}{old} присваивается новое значение \mintinline{c++}{accounts[from]} и мы пытаемся снова.\\
    Хорошо, а почему \mintinline{c++}{compare_exchange_weak} назван <<weak>>? Потому что он может спонтанно обвалиться. Зачем он такой? Потому что на некоторых процессорах (POWER, например) нет инструкции под <<strong>>, поэтому там в ассемблере будет написан цикл. А если у нас уже цикл, зачем нам ещё один внутри.
    \subparagraph{Relaxed atomic.}
    Вот есть у нас чтение \mintinline{c++}{atomic}'а. Там есть метод \mintinline{c++}{load}, который принимает \mintinline{c++}{std::memory_order}. Это хто? Подробно об этом \href{https://www.youtube.com/watch?v=A8eCGOqgvH4}{тут}, но мы вкратце обсудим.\\
    Проблема с обычными операциями (которые работают с \mintinline{c++}{std::memory_order_seq_cst}) в том, что все операции гарантируют, что их можно чётко расположить на временной оси и определить порядок. Но реальное железо работает совсем иначе, и поддержание иллюзии последовательности стоит недёшево. И только на x86 \mintinline{c++}{std::memory_order_seq_cst} работает нормально. Там вообще почти все \mintinline{c++}{std::memory_order}'ы работают почти одинаково. Но вот на POWER'ах или ARM'ах \href{https://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html}{все они порождают разные операции}.\\
    Окей, так что такое не sequential-consistent операции? Какие могут быть эффекты?
    \begin{minted}{c++}
        int x = 0, y = 0;

        void thread_1()
        {
            x = 1;
        }
        void thread_2()
        {
            x = 1;
        }
        void thread_3()
        {
            int x3 = x;
            int y3 = y;
            if (x3 == 1 && y3 == 0)
                std::cout << "x was written to before y" << std::endl;
        }
        void thread_4()
        {
            int y4 = y;
            int x4 = x;
            if (x4 == 0 && y4 == 1)
                std::cout << "y was written to before x" << std::endl;
        }
    \end{minted}
    Так вот в relaxed-модели вполне возможна ситуация, когда поток 3 увидит, что \mintinline{c++}{x} был записан до \mintinline{c++}{y}, а поток 4~--- что \mintinline{c++}{y} до \mintinline{c++}{x}. Потому что у нас есть кэши, они портят нам наивное представление о работе памяти. В sequential-consistent модели такого тоже не бывает, а в relaxed можно интерпретировать ситуацию так, что данные о записи в переменную не доставляются всем сразу.\\
    Так а что, в x86 не бывает такого? Нет, там тоже бывает. Конкретно такой пример (если его на ассемблере написать) будет работать, но на x86 сами потоки, которые пишут, могут разойтись во мнениях, кто записал раньше (см \href{https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html}{Intel\textregistered\ 64 and IA-32 Architectures Software Developer's Manual Combined Volumes: 1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4}? страница 3094, раздел 8.2.3.5, пример 8-5).\\
    Хорошо, давайте разбираться в \mintinline{c++}{std::memory_order}'ах.
    \begin{itemize}
        \item Если один поток сделал запись с \mintinline{c++}{release}, а второй~--- чтение с \mintinline{c++}{acquire}, то все чтения, сделанные до записи, будут видны во втором потоке. Можно применить например тогда, когда мы имеем две переменных: значение и флаг, посчитано ли оно.
        \begin{minted}{c++}
            int computation_result;
            atomic<bool> computation_result_ready;

            void thread_1()
            {
                computation_result = 42;
                computation_result_ready.store(true, std::memory_order::release);
            }
            void thread_2()
            {
                if (computation_result_ready.load(std::memory_order::acquire)
                {
                    int tmp = computation_result;
                    // ...
                }
            }
        \end{minted}
        \item Представим себе вот такой пример:
        \begin{minted}{c++}
            atomic<uint64_t> event_counter;

            void thread_proc()
            {
                while (true)
                {
                    // ...
                    event_counter++;
                    // ...
                }
            }

            int main()
            {
                std::thread th1(&thread_proc);
                std::thread th2(&thread_proc);
                th1.join();
                th2.join();
                
                uint64_t tmp = event_counter;
            }
        \end{minted}
        Насколько нам важен конкретный порядок инкрементов \mintinline{c++}{event_counter}? Да ни насколько не важен. Важно только то, что все они произойдут. Ну и хорошо:
        \begin{minted}{c++}
            atomic<uint64_t> event_counter;
            
            void thread_proc()
            {
                while (true)
                {
                    // ...
                    event_counter.fetch_add(1, std::memory_order::relaxed);
                    // ...
                }
            }
            
            int main()
            {
                event_counter.store(0, std::memory_order::relaxed);

                std::thread th1(&thread_proc);
                std::thread th2(&thread_proc);
                th1.join();
                th2.join();
                
                uint64_t tmp = event_counter;
            }
        \end{minted}
        \item \mintinline{c++}{std::memory_order::acq_rel}~--- комбинация \mintinline{c++}{acquire} и \mintinline{c++}{release}, применяется в некоторых операциях, которые и читают, и пишут.
        \item А кто же такой \mintinline{c++}{std::memory_order::consume}? Вообще это нечто среднее между \mintinline{c++}{acquire} и \mintinline{c++}{relaxed}. Нужен он бывает редко, поддерживается не всеми, так что фиг с ним, неважно, кто это.
    \end{itemize}
    \subparagraph{Worst practices.}
    Никогда, слышите, никогда не используйте один \mintinline{c++}{memory_order} вместо другого, опираясь на то, что на вашей архитектуре они одно и то же. Это не только очень платформозависимо, это ещё и от компилятора зависит, потому что он тоже имеет право инструкции переставлять. Поэтому руководствуйтесь только свойствами языка.
    \subparagraph{Ненативные атомики.}
    Вообще в \mintinline{c++}{std::atomic} можно запихнуть любой тривиально копируемый (и просто перемещаемый) тип. Но не для любого же размера процессор имеет инструкции. Ну, да. Поэтому для некоторых типов \mintinline{c++}{std::atomic} будет скрафчен руками на основе \Verb|mutex|'ов. Это даже \href{https://en.cppreference.com/w/cpp/atomic/atomic/is_always_lock_free}{проверить} можно.
    \subparagraph{Цена атомиков. Sharing.}
    Рассмотрим следующую программу:
    \begin{minted}{c++}
        #include <boost/program_options.hpp>
        #include <atomic>
        #include <iostream>
        #include <thread>
        #include <vector>
        #include <memory>
        
        namespace po = boost::program_options;
        
        void thread_proc(std::atomic<int>& v, std::atomic<bool>& finish)
        {
            while (!finish.load())
                v += 1;
        }
        
        int main(int argc, char* argv[])
        {
            try
            {
                po::options_description desc("Allowed options");
                desc.add_options()
                    ("threads,j", po::value<size_t>(), "set number of threads")
                    ;
                
                po::variables_map vm;
                po::store(po::parse_command_line(argc, argv, desc), vm);
                po::notify(vm);
                
                size_t number_of_threads = 1;
                if (vm.count("threads") != 0)
                    number_of_threads = vm["threads"].as<size_t>();
                
                for (;;)
                {
                    std::cout << number_of_threads << " threads";
                    
                    std::atomic<int> val(0);
                    std::atomic<bool> finished(false);
                    
                    std::vector<std::thread> threads;
                    for (size_t i = 0; i != number_of_threads; ++i)
                        threads.emplace_back(&thread_proc, std::ref(val), std::ref(finished));
                    
                    std::this_thread::sleep_for(std::chrono::seconds(2));
                    finished.store(true);
                    
                    for (auto i = threads.rbegin(); i != threads.rend(); ++i)
                    {
                        auto& th = *i;
                        th.join();
                    }
                    
                    std::cout << ", " << val.load() << " iterations" << std::endl;
                }
            }
            catch (std::exception const& e)
            {
                std::cerr << e.what() << std::endl;
                return EXIT_FAILURE;
            }
        }
    \end{minted}
    Как думаете, как будет меняться вывод в зависимости от количества потоков? А вот будет сильно уменьшаться. Например, на двух потоках значение вчетверо меньше, чем на одном. Причём что ещё хуже, в зависимости от того, на каких ядрах мы запускаем программу, получаются существенно различающиеся результаты.\\
    И тут можно догадаться, что дело всё в кэшах. Её периодически бывает нужно забрать с другого ядра. Тут у нас одна переменная на кучу потоков, что порождает проблему с производительностью, которая называется sharing. И решается она обычно созданием разных переменных под каждый поток и последующим объединением результатов.\\
    Хорошо, фикс на 100 рублей: вместо одной переменной \mintinline{c++}{val} массив. Поможет? Ну, разумеется, нет, массив не пораскидаешь по разным кэш-линиям. Такое false-sharing называется (как и в принципе если две переменные в одной кэш-линии лежат).
    \paragraph{Аллокаторы памяти.}
    На самом деле дизайн аллокаторов памяти сильно определяется наличием нескольких потоков. В нулевых аллокаторы были однопоточными, просто рядом с ними лежал \Verb|mutex|. Но по мере развития многоядерности аллокаторы стали узким местом. И там появились разные решения по типу \href{https://people.cs.umass.edu/~emery/pubs/berger-asplos2000.pdf}{hoard}'а, который считает хэш от номера потока и блокирует не всё вообще после этого. И уже на этих идеях создали свои аллокаторы.
    \paragraph{\mintinline{c++}{volatile}.}
    \subparagraph{Исторический контекст.}
    Многопоточка появилась в C++11. Но многопоточные программы писались и до этого. Как? Конкретные ОС, библиотеки могли предоставлять свои способы делать многопоточку. И некоторые библиотеки для разных целей использовали \mintinline{c++}{volatile}. В интерпретации стандарта \mintinline{c++}{volatile} к многопоточке не имеет никакого отношения. А к чему имеет?
    \subparagraph{Применения \mintinline{c++}{volatile}.}
    У нас могут быть какие-то устройства, которые тупо отображаются в память по каким-то адресам. Вы делаете запись, а это не честная запись в память, а интерфейс для взаимодействия с устройством. И вполне нормальное применение~--- читать несколько раз подряд. Любой нормальный компилятор охуеет от такого и заменить все чтения на одно. Для обычной памяти это норм, но вот в случае с устройствами нам такое не надо. Это первое применение \mintinline{c++}{volatile}.\\
    Второй случай~--- \mintinline{c++}{setjmp} и \mintinline{c++}{longjmp}. На C++ вам это не надо, но вообще это в некотором смысле C'шный аналог исключений. И там тоже при записи в переменную после \mintinline{c++}{setjmp} может иметь смысл делать \mintinline{c++}{volatile}.\\
    И третий случай~--- UNIX-сингалы (ничего общего с сигналами, которые мы обсуждали). Вас на любой инструкции могут дёрнуть и сказать разные интересные вещи. И поскольку вас могут позвать на любую инструкцию, делать обработчики UNIX-сигналов могут не всё. Например, могут обращаться к \mintinline{c++}{volatile}-переменным. Это более применимый случай, но тоже довольно нишевый.
    \subparagraph{Почему это не атомики.}
    Ни для каких других случаев \mintinline{c++}{volatile} не используется, не надо пытаться использовать из вместо \mintinline{c++}{std::atomic}'ов. У них есть некоторые схожие гарантии, но они \href{https://www.drdobbs.com/parallel/volatile-vs-volatile/212701484}{во многих местах различны}.
    \begin{minted}{c++}
        volatile int x;
        int y;

        void foo()
        {
            int x_copy = x;
            if (x_copy)
                int y_copy = y;
        }
    \end{minted}
    Тут с \mintinline{c++}{volatile}-переменными мы можем их переупорядочить, как нам хочется (ну а какая разница, если первое из памяти устройства, а второе~--- из памяти). А с атомиками это не так.\\
    Есть и обратный пример:
    \begin{minted}{c++}
        volatile int z;

        void bar()
        {
            z = 1;
            z = 2;
        }
    \end{minted}
    В случае с \mintinline{c++}{volatile} мы никак не можем убрать первую инструкцию, а в случае \Verb|atomic|'ов~--- можем, почему нет. Другое дело, что компиляторы её не делают, но могут: вполне возможна ситуация, когда никто не увидит первую запись, такая она быстрая. На тему того, что компилятор не оптимизирует \mintinline{c++}{std::atomic}'и есть даже \href{https://wg21.link/n4455}{статья} и \href{https://wg21.link/p0062}{другая статья}, в которых написано, что компилятор не будет пытаться оптимизировать атомики, хотя на самом деле есть несколько случаев, когда этого хочется и это будет корректно.
    \subparagraph{Мораль.}
    \href{https://isvolatileusefulwiththreads.in/cxx/}{Применим ли \mintinline{c++}{volatile} в потоках в C++?}
    \paragraph{Ещё немного про не sequential-consistent атомики.}
    Есть версия, что их не надо использовать по причине их неинтуитивности. Причём иногда максимально неинтуитивная. Можете открыть \href{https://youtu.be/VogqOscJYvk?t=3212}{презентацию о том, как атомики пихали в CUDA} и найти там несколько примеров. Там модель памяти чем-то похожа на POWER и 32-битный ARM. И эти чуваки из NVIDIA начали проверять свою трансляцию формальными методами: они брали пример плюсовой программы, смотрели, как позволяет стандарт и сравнивали со своей трансляцией. И столкнулись они с тем, что стандарт и трактовка большинства компиляторов не согласована (компиляторы слишком много себе позволяют). После этого стандарт пофиксили, но пример всё ещё очень показателен: куча чуваков, которые очень долго шарили в многопоточке, не замечали это очень долго. Поэтому очень сильно думайте, насколько вам нужны relaxed-атомики, особенно в комплексных случаях.\\
    Да и вообще, писать многопоточку сложно. Вы не можете найти случай, когда программа не работает, например. Тут вам помогут thread-sanitizer'ы, cppmem и средства формальной проверки, но боже, оно вам точно надо?
    \paragraph{Cancellation.}
    Представьте себе какую-нибудь UI-ную программу, которая что-то делает по подсчёту кнопки. Обычно в таком случае пользователь хочет видеть какие-то результаты. Но бывают и ситуации, когда посреди вычисления мы понимаем, что результат нам не нужен. Если мы реализуем долгую операцию как вычисление в потоке, надо думать о том, как можно отменять. Мы помним, что операции \mintinline{c++}{terminate} у потока нет. Поэтому было бы неплохо предусмотреть механизм <<выходи, пожалуйста>>.\\
    Если мы не пользуемся никакими библиотеками, мы могли бы завести \mintinline{c++}{bool}'овый флажок, который в потоке периодически опрашивать.\\
    Ещё есть прерывания, которые вообще говоря встречаются на низком уровне (те же UNIX'овые сигналы). Однако внутри обработчиков этих прерываний можно делать не так много полезного. Когда вас прервали посреди непонятно какой инструкции, у вас с инвариантами происходит лютый ужас. Вы, конечно, могли быть просто считать, что из каждой инструкции процессора может вылететь исключение, но с таким жить ой как непросто.
    \subparagraph{\mintinline{c++}{std::jthread}, \mintinline{c++}{std::stop_token}.}
    В C++20 есть \mintinline{c++}{std::jthread}, в который уже встроенный механизм <<остановись, пожалуйста>>. Там есть \mintinline{c++}{std::stop_token}, он позволяет проверять, что остановили. И есть ещё \mintinline{c++}{std::stop_source}, при помощи которого и можно останавливать. Но второй вам не нужен, вам нужен метод \mintinline{c++}{request_stop} у класса \mintinline{c++}{std::jthread}.\\
    Но в чём проблема? В том, что у нас есть блокирующие операции. Любая операция с файловыми дескрипторами сидит и ждёт, пока ей дадут данные. А пока мы сидим и ждём данные, мы не можем проверять \mintinline{c++}{std::stop_token}. И ладно ввод-вывод, но у вас есть совершенно естественные для потоков операции~--- \mintinline{c++}{std::thread::join}, \mintinline{c++}{std::mutex::lock} и \mintinline{c++}{std::condition_variable::wait}. Для \mintinline{c++}{std::mutex::lock} вообще неестественно, что он не прерывается.\\
    В общем случае с блокирующими операциями вам нечего делать. Но в некоторых специфичных случаях, зная предметную область блокирующей операции, есть способы что-то сделать. Если вы пользуетесь какими-то библиотеками, то в них написано, что происходит. Если библиотека претендует на совместимость с STL, в них будет появляться поддержка \mintinline{c++}{std::stop_token}, и всё у вас будет хорошо. Да и в самой стандартной библиотеке есть способы. Например, у \mintinline{c++}{std::condition_variable} есть перегрузка \mintinline{c++}{wait}, которая принимает \mintinline{c++}{std::stop_token}. А ещё есть такая штука как \mintinline{c++}{std::stop_callback}, которая регистрирует обработчик на \mintinline{c++}{std::stop_token}. Если вам чем-то это поможет, конечно.
    \subparagraph{Прикол про pthread cancellation.}
    Смотрите, если взять C++20, то нам надо таскать \mintinline{c++}{std::stop_token} во все функции. Это не звучит очень удобно. Поэтому в pthread'ах сказали, что это \mintinline{c++}{thread_local}-переменная. Чтобы с ней взаимодействовать~--- есть \mintinline{c}{pthread_testcancel}, которая проверяет их аналог \mintinline{c++}{std::stop_token}'а и делает нечто похожее на бросок исключения. glibc, например, именно что бросает \mintinline{c++}{abi::__forced_unwind}. Его, кстати, нельзя ловить, как помнят читатели конспектов. Если вы его поймаете и зажуёте, вы совсем проиграете. Ещё в POSIX можно сделать \mintinline{c}{pthread_set_cancelstate}, который позволяет сделать вам аналог \mintinline{c++}{noexcept} (т.е. сделать так, чтобы какой-то кусок кода не реагировал на прерывание). В C++, кстати, для этого есть конструктор \mintinline{c++}{std::stop_token} по умолчанию.\\
    В POSIX, кстати, что удобно, так это то, что все системные операции там прерываемые. Это, с одной стороны, замечательно, а с другой~--- а насколько это поддерживается? И этому есть причина. Поскольку прерывание \mintinline{c}{pthread}'ов работает как будто у вас исключения в C, кучка программистов на C сидят без знаний о гарантиях безопасности, RAII и всего остального такого. Разумеется, им не нравятся исключения. Потому что, блин, у них даже деструкторов нет нормальных, вам придётся руками их делать через \mintinline{c}{pthread_cleanup_push} и \mintinline{c}{pthread_cleanup_pop}.
    \paragraph{Асинхронщина.}
    Представьте, что у нас сотня клиентов. Мы не знаем, как они посылают данные. И мы не можем выбрать одного и начать получать данные от него, потому что это блокирующая операция. Если этот ничего не отправляет, значит другие ждут, даже если данные они уже отправили. Вряд ли это то, чего мы хотим.\\
    Можно создать по одному потоку на каждого нашего клиента, но это как-то не то, чего мы хотим. Мы создаём поток, чтобы он ждал. Как-то не очень логично. Да и клиентов у нас может быть очень много, намного больше, чем логичнее будет создавать потоков.\\
    Есть другой вариант~--- в некоторых местах есть возможность сделать неблокирующее чтение, которое просто вернёт вам что-то, что скажет вам, что данных нет. Только вот что вы будете с этим делать? В цикле спрашивать? Ну, тогда вы выжираете ядро подчистую, а значит и когда вы дойдёте до того, у кого есть данные, куча инструкций (следовательно и времени) пройдёт.\\
    Окей, а как это в операционной системе происходит? Там есть несколько механизмов. Например функция \mintinline{c}{poll}, которой вы передаёте массив файловых дескрипторов, а она говорит вам, у кого из них есть данные. Это в целом ок, но честно опрашивать все десять, когда данные приходят из двух -- трех~--- не очень. Да ещё и дальше надо самому по массиву проходиться. Проблему с производительностью побороли при помощи \mintinline{c}{epoll}, там список не снаружи, а внутри, и он сам даёт вам список готовых, так что вы не имеете холостых проходов.\\
    Такая концепция, когда у нас есть набор чуваков, которых мы ждём, и мы периодически опрашиваем, чо там готово, она очень сильно переплетается с GUI. GUI очень много ждёт. Ждёт каждую из возможных кнопок, например.
    \section{Примеры с использованием QT.}
    \begin{minted}{c++}
        #include <QApplication>
        #include <QWidget>
        int main(int argc, char *argv[])
        {
            QApplication a(argc, argv);
            QWidget w;
            w.show();
            
            return a.exec();
        }
    \end{minted}
    Что тут происходит? \mintinline{c++}{QApplication}~--- глобальная инициализация/деинициализация, надо создать его тогда, когда хотите использовать QT и не использовать QT после его удаления. \mintinline{c++}{QWinget}~--- любая хрень, любые кнопочки, например, наследуются от него. А вот \mintinline{c++}{a.exec()}~--- запуск цикла обмена сообщениями. Завершается тогда, когда мы закрываем все окна.\\
    Давайте сделаем что-то ещё:
    \begin{minted}{c++}
        #include <QApplication>
        #include <QWidget>

        int main(int argc, char *argv[])
        {
            QApplication a(argc, argv);
            QWidget w;
            QPushButton button(&w);
            button.setGeometry(50, 50, 100, 100);
            button.setText("Hello");
            w.show();
            
            return a.exec();
        }
    \end{minted}
    Ура, у нас кнопочка.\\
    Так, ладно. Давайте сделаем что-то полезное. Обычно, например, в тестовых проектах не в \mintinline{c++}{main}'е что-то пишут, а наследуются от, например, \mintinline{c++}{QMainWindow}. Что можно заметить, так это то, что помимо классов пишется XML-ка, в которой вы пишете, какие сущности у вас есть, и вот эта XML-ка уже компилируется в код на C++. Нужно это, чтобы XML-ки всякие дизайнеры делали.\\
    Хорошо, но вот эти XML-ки~--- не действие. А надо на кнопочки ещё действие привязать. И делается это при помощи таких сигналов, что мы обсуждали ранее. Нам интересно \mintinline{c++}{QAbstractButton::clicked}~--- сигнал, который кнопка emit'ит, когда кнопку нажимают. Что про это стоит знать, так это то, что сигналы там появились раньше, чем STL. Итак, там ест функция \mintinline{c++}{connect}, куда вы передаёте объект, его сигнал, слотовый объект и саму функцию-слот. То есть традиционно слоты~--- методы. В QT5 стало возможно передавать лямбду вместо метода.\\
    Ещё в QT можно увидеть кучу сырых указателей. Возникает вопрос: <<кто удаляет объекты>>? На самом деле каждый QT-шный класс наследуется от \mintinline{c++}{QObject}'а. И в нём можно заметить, что у каждого QT-шного объекта есть родитель, и каждый родитель знает всех всех детей. И родитель сам удаляет своих детей. Если вы свой объект привязали к родителю, то у вас нет никаких проблем с \mintinline{c++}{delete}'ом. Если не привязали, то применимо всё, что мы говорили про RAII.\\
    Кстати. Зачем в \mintinline{c++}{connect} передают \mintinline{c++}{this}? Потому что есть внезапно приёмник или владелец сигнала умирают, \mintinline{c++}{connection} моментально рвётся. Если вы не хотите привязываться к какому-то объекту, то вообще есть перегрузка \mintinline{c++}{connect} и без этого.\\
    Как, кстати, пишутся слоты и сигналы? Ну, вот так:
    \begin{minted}{c++}
        // inside a class
        signals:
            void something_changed();
        private slots:
            void button_clicked();
    \end{minted}
    Эти макросы созданы для того, чтобы специальный QT-штый компилятор прошёлся по этим макросами и нагенерировал кода сбоку. Этот компилятор называется MOC.
    \paragraph{Многопоточка.}
    Рассмотрим вот такую \url{https://github.com/sorokin/qfactor}{простую программку}:
    \begin{minted}{c++}
        #include "main_window.h"
        #include "ui_main_window.h"
        #include <cassert>
        #include <sstream>
        #include <QEventLoop>
        
        main_window::main_window(QWidget *parent)
            : QMainWindow(parent)
            , ui(new Ui::main_window)
        {
            ui->setupUi(this);
            connect(ui->input_edit, &QLineEdit::textChanged, this, &main_window::input_changed);
        }
        
        main_window::~main_window()
        {}
        
        void main_window::input_changed()
        {
            bool ok;
            unsigned long long val = ui->input_edit->text().toULongLong(&ok);
            if (!ok || val == 0)
            {
                QPalette p;
                p.setColor(QPalette::Text, Qt::red);
                ui->input_edit->setPalette(p);
                ui->output_label->setText("");
                return;
            }
            else
            {
                QPalette p;
                ui->input_edit->setPalette(p);
            }
            
            uint64_t uval = static_cast<uint64_t>(val);
            ui->output_label->setText(format_output(uval, factor(uval)));
        }
        
        std::vector<uint64_t> main_window::factor(uint64_t val)
        {
            assert(val >= 1);
            std::vector<uint64_t> result;
            
            while ((val % 2) == 0)
            {
                QApplication::processEvents(QEventLoop::AllEvents);
                result.push_back(2);
                val /= 2;
            }
            
            uint64_t current_divisor = 3;
            
            for (;;)
            {
                QApplication::processEvents(QEventLoop::AllEvents);
                if (val == 1)
                    break;
                
                if ((val % current_divisor) == 0)
                {
                    result.push_back(current_divisor);
                    val /= current_divisor;
                }
                else
                    current_divisor += 2;
            }
            
            if (result.empty())
            {
                assert(val == 1);
                result.push_back(1);
            }
            
            return result;
        }
        
        QString main_window::format_output(uint64_t val, std::vector<uint64_t> const& factors)
        {
            assert(!factors.empty());
            
            std::stringstream ss;
            ss << val << " =\n";
            
            for (size_t i = 0; i != factors.size(); ++i)
            {
                ss << "\t";
                ss << factors[i];
                if ((i + 1) != factors.size())
                    ss << " ×";
                ss << '\n';
            }
            
            return QString::fromStdString(ss.str());
        }
    \end{minted}
    Она факторизует число в текстовой панели, когда оно меняется. Понятно, что если число поменялось на большое, то факторизовать его мы будем долго, и программа будет делать вид, что зависнет.\\
    Что говорят делать, чтобы программа не зависала? Говорят сделать отрисовку в отдельном потоке. Каждый QT-штый объект не только имеет родителя, но ещё и принадлежит определённому потоку (тому же, что его родитель). Важно это потому, что сигналы и слоты работают по-другому, если сигнал и слот находятся в разных потоках. Тогда при emit'е отсылается событие потоку, и это самое событие обрабатывается в цикле обработке сообщений. А вообще в \mintinline{c++}{connect} есть пятый параметр: тип connection'а. Например, \mintinline{c++}{DirectConnection}~--- то, что происходит обычно, а \mintinline{c++}{QueuedConnection}~--- когда объекты в разных потоках.
    \begin{minted}{c++}
        #include "main_window.h"
        #include "ui_main_window.h"
        #include <sstream>
        
        main_window::main_window(QWidget *parent)
            : QMainWindow(parent)
            , ui(new Ui::main_window)
        {
            ui->setupUi(this);
            worker_obj.moveToThread(&worker_thread);
            connect(ui->input_edit, &QLineEdit::textChanged, this, &main_window::input_changed);
            connect(&worker_obj, &worker::factoring_finished, this, &main_window::factoring_finished);
            worker_thread.start();
        }
        
        main_window::~main_window()
        {
            worker_thread.quit();
            worker_thread.wait();
        }
        
        void main_window::input_changed()
        {
            bool ok;
            long long val = ui->input_edit->text().toLongLong(&ok);
            if (!ok || val <= 0)
            {
                QPalette p;
                p.setColor(QPalette::Text, Qt::red);
                ui->input_edit->setPalette(p);
                
                val = 0;
            }
            else
            {
                QPalette p;
                ui->input_edit->setPalette(p);
            }
            
            uint64_t uval = static_cast<uint64_t>(val);
            QMetaObject::invokeMethod(&worker_obj, "factor", Qt::QueuedConnection, Q_ARG(uint64_t, uval));
        }
        
        QString main_window::format_output(uint64_t val, std::vector<uint64_t> const& factors)
        {
            assert(!factors.empty());
            
            std::stringstream ss;
            ss << val << " =\n";
            
            for (size_t i = 0; i != factors.size(); ++i)
            {
                ss << "\t";
                ss << factors[i];
                if ((i + 1) != factors.size())
                ss << " ×";
                ss << '\n';
            }
            
            return QString::fromStdString(ss.str());
        }
        
        void main_window::factoring_finished(factoring_result result)
        {
            if (!result.success)
            {
                ui->output_label->setText("");
                return;
            }
            ui->output_label->setText(format_output(result.input_val, result.factors));
        }
    \end{minted}
    Это штука замечательна всем, кроме того, что для больших чисел она не печатает результат. Что логично, оно тупо долго считается. Но есть проблема: мы меняем число. Дописываем к нему 2 цифры. Он уже на первой начинает вычисляться (хотя оно не надо), а вычисление второго ждёт, пока посчитается ненужное первое. На эту тему и было cancellation.
    \begin{minted}{c++}
        #include "factoring_worker.h"
        #include <cassert>
        
        factoring_result::factoring_result(uint64_t input, std::vector<uint64_t> factors, bool incomplete)
            : input(input)
            , factors(std::move(factors))
            , partial(incomplete)
        {}
        
        factoring_worker::factoring_worker()
            : input_version(INPUT_VERSION_QUIT + 1)
            , worker_thread([this] { thread_proc(); })
        {}
        
        factoring_worker::~factoring_worker()
        {
            input_version = INPUT_VERSION_QUIT;
            input_changed.notify_all();
            worker_thread.join();
        }
        
        void factoring_worker::set_input(std::optional<uint64_t> val)
        {
            {
                std::lock_guard lg(m);
                input = val;
                ++input_version;
            }
            input_changed.notify_all();
        }
        
        std::optional<factoring_result> factoring_worker::get_output() const
        {
            std::lock_guard lg(m);
            return output;
        }
        
        void factoring_worker::thread_proc()
        {
            uint64_t last_input_version = 0;
            for (;;)
            {
                std::optional<uint64_t> input_copy;
                {
                    std::unique_lock lg(m);
                    input_changed.wait(lg, [&]
                    {
                        return input_version != last_input_version;
                    });
                    
                    last_input_version = input_version;
                    if (last_input_version == INPUT_VERSION_QUIT)
                        break;
                    
                    input_copy = input;
                }
                
                std::optional<factoring_result> result;
                if (input_copy)
                    factor(last_input_version, *input_copy);
                else
                    store_result(std::nullopt);
            }
        }
        
        void factoring_worker::factor(uint64_t last_input_version, uint64_t val)
        {
            assert(val >= 1);
            uint64_t const initial_val = val;
            std::vector<uint64_t> factors;
            store_result(factoring_result(initial_val, factors, true));
            
            while ((val % 2) == 0)
            {
                if (last_input_version != input_version)
                    return;
                
                factors.push_back(2);
                store_result(factoring_result(initial_val, factors, true));
                val /= 2;
            }
            
            uint64_t current_divisor = 3;
            
            for (;;)
            {
                if (last_input_version != input_version)
                    return;
                
                if (val == 1)
                    break;
                
                if ((val % current_divisor) == 0)
                {
                    factors.push_back(current_divisor);
                    store_result(factoring_result(initial_val, factors, true));
                    val /= current_divisor;
                }
                else
                    current_divisor += 2;
            }
            
            if (factors.empty())
            {
                assert(val == 1);
                factors.push_back(1);
            }
            
            store_result(factoring_result(initial_val, factors, false));
        }
        
        void factoring_worker::store_result(std::optional<factoring_result> const& result)
        {
            std::lock_guard lg(m);
            output = result;
            
            if (!notify_output_queued)
            {
                QMetaObject::invokeMethod(this, "notify_output");
                notify_output_queued = true;
            }
        }
        
        void factoring_worker::notify_output()
        {
            {
                std::lock_guard lg(m);
                notify_output_queued = false;
            }
            emit output_changed();
        }
    \end{minted}
    Эта программа, кстати, имеет ещё одно преимущество: она показывает, что мы в данный момент досчитываем.\\
    Мораль: от того, что у вас потоки, не значит, что ваша программа не виснет. Но более того, это и в обратную сторону работает: программа может и в одном потоке не виснуть. Всё, что нам надо~--- сделать обновление быстрым. Всё, что нам надо~--- чтобы мы регулярно возвращались в цикл обработки сообщений. Как это сделать в 1 потоке? Мы могли бы сделать часть работы и записать в цикл обработки сообщение о том, что нам нужно доработать. А есть другой вариант:
    \begin{minted}{c++}
        #include "main_window.h"
        #include "ui_main_window.h"
        #include <cassert>
        #include <sstream>
        
        main_window::main_window(QWidget *parent)
            : QMainWindow(parent)
            , ui(new Ui::main_window)
        {
            ui->setupUi(this);
            connect(ui->input_edit, &QLineEdit::textChanged, this, &main_window::input_changed);
        }
        
        main_window::~main_window()
        {}
        
        void main_window::input_changed()
        {
            bool ok;
            long long val = ui->input_edit->text().toLongLong(&ok);
            if (!ok || val <= 0)
            {
                QPalette p;
                p.setColor(QPalette::Text, Qt::red);
                ui->input_edit->setPalette(p);
                val = 0;
                return;
            }
            else
            {
                QPalette p;
                ui->input_edit->setPalette(p);
            }
            
            bool has_job = current_job.has_value();
            current_job = static_cast<uint64_t>(val);
            
            if (!has_job)
            {
                try
                {
                    factor();
                }
                catch (...)
                {
                    current_job = std::nullopt;
                    throw;
                }
                current_job = std::nullopt;
            }
        }
        
        void main_window::factor()
        {
            retry:
            uint64_t const initial_val = *current_job;
            uint64_t val = initial_val;
            if (val == 0)
            {
                ui->output_label->setText("");
                return;
            }
            
            std::vector<uint64_t> result;
            ui->output_label->setText(format_output(initial_val, result, true));
            
            while ((val % 2) == 0)
            {
                QApplication::processEvents(QEventLoop::AllEvents);
                if (initial_val != current_job)
                    goto retry;
                
                result.push_back(2);
                ui->output_label->setText(format_output(initial_val, result, true));
                val /= 2;
            }
            
            uint64_t current_divisor = 3;
            
            for (;;)
            {
                QApplication::processEvents(QEventLoop::AllEvents);
                if (initial_val != current_job)
                    goto retry;
                
                if (val == 1)
                    break;
                
                if ((val % current_divisor) == 0)
                {
                    result.push_back(current_divisor);
                    ui->output_label->setText(format_output(initial_val, result, true));
                    val /= current_divisor;
                }
                else
                    current_divisor += 2;
            }
            
            if (result.empty())
            {
                assert(val == 1);
                result.push_back(1);
            }
            
            ui->output_label->setText(format_output(initial_val, result, false));
        }
        
        QString main_window::format_output(uint64_t val, std::vector<uint64_t> const& factors, bool partial)
        {
            assert(!factors.empty() || partial);
            
            std::stringstream ss;
            ss << val << " =\n";
            
            for (size_t i = 0; i != factors.size(); ++i)
            {
                ss << "\t";
                ss << factors[i];
                if ((i + 1) != factors.size() || partial)
                ss << " ×";
                ss << '\n';
            }
            
            if (partial)
                ss << "\t…\n";
            
            return QString::fromStdString(ss.str());
        }
    \end{minted}
    Тут можно найти \mintinline{c++}{QApplication::processEvents(QEventLoop::AllEvents)}. Это что?\\
    Посмотрим на вот что. У нас могут быть сложенные циклы обработки сообщений. Вот открыли мы диалог <<открыть файл>>. Там запускается свой цикл обработки сообщений, который обрабатывает только её сообщения, но не сообщения основного окна. Но ведь крутить циклы обработки мы можем не только в подобных (модальных) диалогах. Мы можем сказать <<а давайте запустим обработку вот в этом месте>>. Главное, чтобы вы не обрабатывали такое же событие, как мы сами, иначе stack overflow. И ещё важно в этом моменте очень много думать про реентрабельность.
    \paragraph{Рисование в окне на Qt (для ДЗ).}
    Если мы хотим нарисовать в окне множество Мандельброта, то мы пока не занем, что делать. А делать вот что: надо переопределить paint event. Paint event~--- это то, что вызывается, когда содержимое окна надо перерисовать. То есть когда вы изменили его размер, например.
    \begin{minted}{c++}
        void main_window::paintEvent(QPaintEvent* event)
        {
            QPainter p(this);
            p.drawLine(QLine(50, 50, 100, 100));
        }
    \end{minted}
    Конкретно нам надо рисовать попиксельно. Делается это так:
    \begin{minted}{c++}
        void main_window::paintEvent(QPaintEvent* event)
        {
            QPainter p(this);
            QImage img(width(), height(), QImage::Format_RGB888);

            for (int y = 0; y < img.height; y++)
                for (int x = 0; x < img.width; x++)
                    img.bits[...] = ...;

            p.drawImage(0, 0, img);
        }
    \end{minted}
    \mintinline{c++}{bits}~--- массив битов, в котором ещё и дырки между строками могут быть. Размер строки целиком~--- \mintinline{c++}{img.bytesPerLine()}. То есть заполнение выглядит примерно так:
    \begin{minted}{c++}
        void fill(QImage& img)
        {
            uchar* image_start = img.bits();
            for (int y = 0; y < img.height; y++)
            {
                uchar* p = image_start + y * img.bitsPerLine();
                for (int x = 0; x < img.width; x++)
                {
                    *p++ = red_component;
                    *p++ = green_component;
                    *p++ = blue_component;
                }
            }
        }
    \end{minted}
    Очевидно, если честно рисовать мандельброта, нам никакого времени не хватит. Поэтому имеет смысл сначала рисовать его очень пиксельно, а потом уточнять.\\
    Ещё нам понадобится \mintinline{c++}{wheelEvent}, \mintinline{c++}{mousePressEvent}, \mintinline{c++}{mouseMoveEvent} и \mintinline{c++}{mouseReleaseEvent}, чтобы реализовать перетаскивание и масштабирование, а также \mintinline{c++}{resiseEvent}, чтобы масштабирование работало.
    \section{Модули.}
    \begin{minted}{c++}
        // test.ixx
        export module test;
        export int sum(int a, int b)
        {
            return a + b;
        }

        // main.cpp
        #include <iostream>
        import test;
        
        int main()
        {
            std::cout << sum(2, 3) << std::endl;
        }
    \end{minted}
    \paragraph{Мотивация.}
    Мы помним, что при работе с заголовочными файлами надо соблюдать осторожность. Например, нам очень надо предотвращение повторного включения. Или ещё мы не можем писать определение функции в заголовочном файле (или можем, но помечая её как \mintinline{c++}{inline}, со всеми вытекающими последствиями). И на крупных проектах текст заголовочного файла проходится в каждом \mintinline{console}{cpp}-файле. И какое-то время компиляции отжирает на это. Если у нас $n$ cpp-файлов и $m$ заголовочных, то в худшем случае у нас время компиляции равно $O(nm)$. Каждая новая версия стандартной библиотеки увеличивает размер заголовочных файлов STL, а значит увеличивает время компиляции.\\
    Отсутствие такой проблемы~--- не единственный бонус модулей. Написав какой-то код в заголовочных файлах очень легко получить нарушение ODR:
    \begin{minted}{c++}
        // header.h
        #pragma once
        #include <cassert>
        #include <cstdint>
        
        inline int32_t isqrt(int32_t arg)
        {
            assert(arg >= 0);

            // ...
        }
    \end{minted}
    Уже даже тут можно получить нарушение ODR, если мы скомпилируем несколько файлов отдельно, и в одном включим \mintinline{c++}{assert}'ы, а в другом~--- нет. Тут нарушение ODR, конечно, относительно безобидное, но UB есть UB. Понятно, что \mintinline{console}{g++ -flto -Wodr} может нам это найти, но знаете ли, LTO не всегда применимо. А ещё можно получить значительно более жёсткое нарушение ODR, если мы не у себя \mintinline{c++}{assert} будем включать-выключать, а если у нас аналогичная ситуация будет с дебажными версиями контейнеров STL.\\
    Да и вообще: препроцессор~--- зло.\\
    А ещё подумайте, насколько удобно жить, когда определение и объявление постоянно разделены. Да, иногда это полезно, но всегда ли?..\\
    Ещё в заголовках нельзя писать \mintinline{c++}{using}-директиву (иначе она повлияет на всё, что написано во всех файлах, которые данный заголовок подключают).\\
    Ещё когда у нас есть шаблон, который мы хотим сделать от конкретных параметрах всегда одинаково, нам может захотеться в заголовочном файле подавить инстанцирование, а в cpp-файле явно проинстанцировать. Оно вам надо так заморачиваться?
    \paragraph{Visible vs reachable.}
    В целом понятно: пишем \mintinline{c++}{export} в модулях, и хорошо. Давайте обсудим некоторые детали.
    \begin{minted}{c++}
        // test.ixx
        export module test;
        
        export struct pair
        {
            int x;
            int y;
        };

        export pair make_pair(int a, int b)
        {
            return { a, b };
        }
    \end{minted}
    Тут всё понятно, у нас есть \mintinline{c++}{pair}, и хорошо. Но вот вопрос: а что если у нас не будет экспортироваться \mintinline{c++}{pair}? Ошибка компиляции? Ну, могло бы быть и так, но заметьте вот какой пример: у нас есть \mintinline{c++}{std::bind}. Он возвращает неизвестно какой функциональный объект. И вы не хотите давать пользователю самому создавать объекты такого типа, он вам просто не нужен. И тут вы вынуждены прятать его в пространство имён \mintinline{c++}{__detail} или называть как-нибудь типа \mintinline{c++}{_Binder}.\\
    И вообще у нас нередко бывает ситуация, когда мы не можем обратиться к классу по имени: у нас есть лямбды, у нас есть локальные классы, объект которого мы можем вернуть из функции. Бывают, короче, ситуации такие.\\
    Поэтому вы вполне можете не экспортировать структуру \mintinline{c++}{pair}, а экспортировать только \mintinline{c++}{make_pair}.\\
    Надо понимать, что все свойства имени известны. Просто вы не можете по имени на него сослаться. Научно это называется visible и reachable. Visible~--- когда вы можете сослаться по имени. Reachable~--- когда вы можете сделать какой-то \mintinline{c++}{decltype} или ещё чего, чтобы добраться до типа.
    \paragraph{Интересный факт.}
    Кстати, в именах модулей допускаются точки. Но, что стоит сказать, с точки зрения языка модули \mintinline{c++}{info} и \mintinline{c++}{info.kgeorgiy} не связаны никак.
    \paragraph{Поддержка модулей.}
    Заявляется, что модули полностью поддерживаются в MSVC и частично пожжерживаются в GCC и clang. В GCC работают какие-то простые примеры, а комплексные примеры не работают и весь трекер у них завален примерами, которые не работают. В clang'е ещё более интересная ситуация: там были модули ещё до C++20 (потомум что у них один фронтенд для C, C++, Objective-C, CUDA и ещё куча всего) и ещё из Objective-C модули были. Когда появился C++20, стало надо доделать ещё много всего (так как они в C++20 там отличаются от Objective-C), но что конкретно там происходит, не расскажем.
    \paragraph{Кто такой модули и как они работают.}
    У нас были мир с заголовками, а сейчас мир с модулями. Что происходит при компиляции модуля? А вот помимо объектного файла создают IFC-файл (так он в MSVC называется), в котором хранится публичный интерфейс модуля. И компиляторы умеют из этих файлов тянуть информацию об объявлениях (соответственно, тянут они только те объявления, что нужны).\\
    То есть модуль~--- это обычный cpp-файл, который просто создаёт не только объктник, а ещё и информацию о публичном интерфейсе. При этом у нас ещё и inlin'инг бывает: компилятор может позволить себе в IFC-файл записать само тело функции, чтобы inlin'ить.\\
    Вопрос: правда ли, что модули всегда дают нам более быструю компиляцию, чем заголовки? А вот не факт. В старом мире файлы можно было бы компилировать параллельно. А тут у нас могут быть зависимости, так что такой прикол не работает. Может ли это привести к тому, что программа в заголовками будет компилироваться быстрее? Да, может. Представим себе функцию с очень простым интерфейсом и длинным телом. Тогда с заголовками у нас заголовок содержал бы только объявление, и мы бы параллельно компилировали бы два больших файла. А в случае с модулями параллельность умирает.\\
    Что с этим делать? Ну, во-первых, есть вероятность, что ничего: просто с развитием компиляторов, всё хорошо будет. Правда, тут нужно исправить системы сборки, чтобы они могли в разные времена выдавать IFC и OBJ. Но вообще, если вам очень важна параллельность компиляции, есть...
    \subparagraph{Разделение модулей на куски.}
    Для каждого модуля надо написать <<главный файл>>~--- primary module interface unit. Там надо объявить, что модуль будет экспортировать. А дальше можно написать implementation unit.
    \begin{minted}{c++}
        // test.ixx
        export module test;
        
        export int sum(int a, int b);

        // test_implementation.ixx
        module test;
        int sum(int a, int b)
        {
            return a + b;
        }
    \end{minted}
    Что ещё нужно бывает нужно иногда~--- экспортировать структуру как incomplete-тип:
    \begin{minted}{c++}
        // test.ixx
        export module test;

        export struct foo;

        // test_impl.ixx
        struct foo {
            // implementation.
        };
    \end{minted}
    \subparagraph{\mintinline{c++}{export import}.}
    Ещё про разделение модулей на куски: если мы хотим и публичный интерфейс разделить на куски, что делать? А вот смотрите как можно. Представьте, что в модуле \mintinline{c++}{inner} у нас есть кусок модуля. Тогда мы можем написать такое:
    \begin{minted}{c++}
        // test.ixx
        export module test;

        export import inner; // добавить в публичный интерфейс всё, что есть в публичном интерфейсе inner.
        export int sum(int, int);
    \end{minted}
    Но вообще так не надо, потому что если у вас была функция в модуле \mintinline{c++}{test}, а вы перенести её в \mintinline{c++}{inner}, то у вас сломается ABI-совместимость, потому что декорированное имя этой функции изменится. Поэтому есть другой механизм
    \subparagraph{Partition'ы}
    \begin{minted}{c++}
        export module test:part1;
    \end{minted}
    Подобная штука позволяет вам распилить модуль на несколько кусков и импортировать в одном модуле partition'ы:
    \begin{minted}{c++}
        export modute test;

        export import :part1;
    \end{minted}
    При этом если у нас есть \textbf{implementation partition} (он пишется без \mintinline{c++}{export} перед \mintinline{c++}{module}), его нельзя пере-\mintinline{c++}{export}'ировать, а если есть \textbf{interface partition} (который с \mintinline{c++}{export module}), то его именно что необходимо пере-\mintinline{c++}{export}'ировать.
    \paragraph{Приватный фрагмент модуля.}
    Помните экспортирование incomplete-типа из модуля? Мы для этого создавали два файла, и в одном писали \mintinline{c++}{export struct foo;} в одном файле, а \mintinline{c++}{struct foo { /* ... */ };} в другом. Но можно и не так: можно написать \mintinline{c++}{module :private;}, и всё до конца файла не будет экспортироваться совсем никак. Соответственно, вам поможет что-то такое
    \begin{minted}{c++}
        export struct foo;

        module :private;

        struct foo
        {
            // implementation.
        };
    \end{minted}
    \paragraph{Transition. Global module fragment и \mintinline{c++}{import} header unit.}
    Прекрасные модули будущего~--- это, конечно, хорошо, но хочется же ещё уже имеющиеся кодовые базы переводить на модули. И не хочется при этом останавливать разработку.\\
    Так что нам надо сделать что-то, чтобы разработчики boost'а не писали две копии своей библиотеки: для тех, кто на модулях, и для тех, кто нет.\\
    Значит, смотрите. Использовать модули где попало~--- на здоровье. Но вот использовать заголовочные файлы там, где уже всё переписано на модули~--- непонятно как. Мы не можем написать
    \begin{minted}{c++}
        export module test;

        #include <vector>

        // sth
    \end{minted}
    Это просто не сработает, потому что у нас в каждом модуле будет свой вектор. Это не то, чего мы хотим. Поэтому у нас есть \textbf{global module fragment}:
    \begin{minted}{c++}
        module;
        #include <vector>

        export module test;
        export std::vector<int> foo();
    \end{minted}
    Так можно было бы создать модульную обёртку стандартной библиотеки.\\
    В global module fragment'е можно писать только препроцессорные директивы, если что.\\
    Второе, что есть для переноса~--- header unit'ы. Вы можете сказать, что у нас есть заголовочный файл и вы хотите импортировать его как модуль:
    \begin{minted}{c++}
        import <vector>;
    \end{minted}
    При этом если вы хотите сделать так со своими файлами, вы тоже можете так написать, правда у MSVC надо в настройках проекта пометить свой файл как header unit. При этом у нас нет никаких проблем с ODR или ещё чем, если мы делаем \mintinline{c++}{import} нескольких header unit'ов, в которых внутри где-то определено одно и то же.
    \subparagraph{Модули в стандартной библиотеке.}
    В C++23, кстати, даже стандартная библиотека начала пилиться на модули, все ругались на тему, как же её распилить и в итоге решили сделать очень просто~--- вся стандартная библиотека один модуль~--- \mintinline{c++}{std}. Попутно они решили проблему, что в C++ на самом деле нет \mintinline{c++}{size_t}, а есть только \mintinline{c++}{std::size_t}, но все это игнорируют. Это решено так: есть модуль \mintinline{c++}{std}, а есть модуль \mintinline{c++}{std.compat}, который выдаёт не только имена через \mintinline{c++}{std::}, но и C-шные \mintinline{c++}{typedef}'ы.
\end{document}
